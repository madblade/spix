{"version":3,"sources":["../../../../../../../server/app/engine/game3d/engine_topology/selector/selector.js"],"names":[],"mappings":";;;;AAIA;;;;;;;;;;;;;;;;;;;;IAEM;AAEF,aAFE,QAEF,CAAY,cAAZ,EAA4B;4CAF1B,UAE0B;KAA5B;;+BAFE;;qDAK2B,QAAQ,YAAY,kBACpB;AACA;UAC3B;AACE,gBAAI,CAAC,KAAK,8BAAL,CAAoC,MAApC,EAA4C,kBAA5C,CAAD,EAAkE,OAAtE;;AAEA,gBAAI,kBAAkB,EAAlB,CAHN;AAIE,gBAAI,MAAM,OAAO,MAAP,CAAc,EAAd,CAJZ;;AAME,+BAAmB,OAAnB,CAA2B,UAAC,UAAD,EAAa,OAAb,EAAyB;AAChD,oBAAI,QAAQ,WAAW,QAAX,CAAoB,OAApB,CAAR,CAD4C;AAEhD,oBAAI,oCAAJ,CAFgD;AAGhD,oBAAI,oBAAJ,EAA0B,8BAA8B,qBAAqB,OAArB,CAA9B,CAA1B;;AAEA,2BAAW,OAAX,CAAmB,mBAAW;AAC1B,wBAAI,CAAC,MAAM,YAAN,CAAmB,OAAnB,CAAD,EAA8B,OAAlC;;AAEA,wBAAI,CAAC,iBAAiB,QAAjB,CAA0B,GAA1B,EAA+B,OAA/B,EAAwC,OAAxC,CAAD;;AAEC,mDAA+B,4BAA4B,cAA5B,CAA2C,OAA3C,CAA/B,IAAsF,4BAA4B,OAA5B,CAAtF,EACE;;;;;;;AAOH,+BAPG;qBAHP;;AAaA,wBAAI,eAAe,MAAM,YAAN,CAAmB,OAAnB,CAAf,CAhBsB;AAiB1B,wBAAI,gBAAgB,cAAhB,CAA+B,OAA/B,CAAJ,EAA6C;AACzC,wCAAgB,OAAhB,EAAyB,aAAa,OAAb,CAAzB,GAAgD,aAAa,OAAb,CADP;qBAA7C,MAEO;AACH,wCAAgB,OAAhB,sCAA6B,aAAa,OAAb,EAAuB,aAAa,OAAb,CAApD,CADG;qBAFP;iBAjBe,CAAnB,CALgD;aAAzB,CAA3B,CANF;;AAoCE,mBAAO,eAAP,CApCF;;;;uDAuC6B,QAAQ,QAAQ;;AAE3C,mBAAQ,OAAO,IAAP,GAAc,CAAd,CAFmC;;;WA/C7C;;;kBAsDS","file":"selector.js","sourcesContent":["/**\n * Ensure player model consistency.\n */\n\n'use strict';\n\nclass Selector {\n\n    constructor(topologyEngine) {\n    }\n\n    selectUpdatedChunksForPlayer(player, worldModel, consistencyModel,\n                                 modelUpdatedChunks,    // topology output      Map(world id -> set of updtd chks)\n                                 addedOrDeletedChunks   // consistency output   {world id => {cid => [fc, fcids]} }\n    ) {\n        if (!this.playerConcernedByUpdatedChunks(player, modelUpdatedChunks)) return;\n\n        var chunksForPlayer = {};\n        let aid = player.avatar.id;\n\n        modelUpdatedChunks.forEach((chunkIdSet, worldId) => {\n            let world = worldModel.getWorld(worldId);\n            let addedOrDeletedChunksInWorld;\n            if (addedOrDeletedChunks) addedOrDeletedChunksInWorld = addedOrDeletedChunks[worldId];\n\n            chunkIdSet.forEach(chunkId => {\n                if (!world.hasChunkById(chunkId)) return;\n\n                if (!consistencyModel.hasChunk(aid, worldId, chunkId) ||\n                    // not null, has {chunkId: !null}\n                    (addedOrDeletedChunksInWorld && addedOrDeletedChunksInWorld.hasOwnProperty(chunkId) && addedOrDeletedChunksInWorld[chunkId]\n                    )) {\n                    // At this point, topology output is being accessed.\n                    // So, topology engine has updated and its topology model is up-to-date.\n                    // Therefore, there is no need to access updates concerning non-loaded chunks,\n                    // for full, up-to-date, extracted surfaces are available to consistencyEngine.\n                    // (reminder: updates are kept for lazy server-client communication)\n                    // (reminder: consistencyEngine does not update before topologyEngine performs model transactions)\n                    return;\n                }\n\n                let currentChunk = world.getChunkById(chunkId);\n                if (chunksForPlayer.hasOwnProperty(worldId)) {\n                    chunksForPlayer[worldId][currentChunk.chunkId]= currentChunk.updates;\n                } else {\n                    chunksForPlayer[worldId] = {[currentChunk.chunkId]: currentChunk.updates};\n                }\n            });\n        });\n\n        return chunksForPlayer;\n    }\n\n    playerConcernedByUpdatedChunks(player, chunks) {\n        // TODO [LOW] extract connected subsurface.\n        return (chunks.size > 0);\n    }\n\n}\n\nexport default Selector;\n"]}