{"version":3,"sources":["../../../../../../../server/app/engine/game3d/engine_topology/updater/updater_face.js"],"names":[],"mappings":"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","file":"updater_face.js","sourcesContent":["/**\n *\n */\n\n'use strict';\n\nimport CollectionUtils from '../../../math/collections';\n\nclass UpdaterFace {\n\n    static detectProbableTopologyChangeAfterAddition(chunk, id, x, y, z, faces) {\n        // Criterion: at least 2 surface faces that do not link on the inserted cube.\n        // i.e. if blocking edges form a cycle.\n        // Detects POTENTIAL local topology changes.\n\n        // Compute blocking edges.\n        let blockingEdges = [];\n        // x-\n        if (faces[0] && faces[2] && chunk.contains(x-1, y-1, z)) blockingEdges.push([0, 4]);\n        if (faces[0] && faces[3] && chunk.contains(x-1, y+1, z)) blockingEdges.push([3, 7]);\n        if (faces[0] && faces[4] && chunk.contains(x-1, y, z-1)) blockingEdges.push([4, 7]);\n        if (faces[0] && faces[5] && chunk.contains(x-1, y, z+1)) blockingEdges.push([0, 3]);\n        // x+\n        if (faces[1] && faces[2] && chunk.contains(x+1, y-1, z)) blockingEdges.push([1, 5]);\n        if (faces[1] && faces[3] && chunk.contains(x+1, y+1, z)) blockingEdges.push([2, 6]);\n        if (faces[1] && faces[4] && chunk.contains(x+1, y, z-1)) blockingEdges.push([5, 6]);\n        if (faces[1] && faces[5] && chunk.contains(x+1, y, z+1)) blockingEdges.push([1, 2]);\n        // y+-z\n        if (faces[2] && faces[4] && chunk.contains(x, y-1, z-1)) blockingEdges.push([4, 5]);\n        if (faces[2] && faces[5] && chunk.contains(x, y-1, z+1)) blockingEdges.push([0, 1]);\n        if (faces[3] && faces[4] && chunk.contains(x, y+1, z-1)) blockingEdges.push([6, 7]);\n        if (faces[3] && faces[5] && chunk.contains(x, y+1, z+1)) blockingEdges.push([2, 3]);\n\n        // Detect loop.\n        let ls = [];\n        for (let i = 0; i < blockingEdges.length; ++i) {\n            let bi = blockingEdges[i];\n            let found = false;\n\n            for (let j = 0; j < ls.length; ++j) {\n                let last = ls[j].length - 1;\n                if (ls[j][last] === bi[0]) {\n                    ls[j].push(bi[1]);\n                    found = true;\n                }\n                if (ls[j][last] === bi[1]) {\n                    ls[j].push(bi[0]);\n                    found = true;\n                }\n                if (ls[j][0] === ls[j][last+1]) { // Loop detected.\n                    if (ls[j].length < 4) console.log(\"invalid detectProbableTopologyChangeAfterAddition algorithm\");\n                    return true;\n                }\n            }\n\n            if (!found) {\n                ls.push([bi[0], bi[1]]);\n            }\n        }\n\n        // No topology change by default.\n        return false;\n    }\n\n    // BLOCK ADDITION\n    // The difficulty is to determine which surface faces belong to which component after an addition.\n    static updateSurfaceFacesAfterAddition(chunk, id, x, y, z) {\n        let dimensions = chunk.dimensions;\n\n        // Compute concerned faces.\n        let addedFaces = [\n            false, // x-\n            false, // x+\n            false, // y-\n            false, // y+\n            false, // z-\n            false  // z+\n        ];\n\n        if (x > 0 && !chunk.contains(x-1, y, z)) addedFaces[0] = true;\n        if (x < dimensions[0]-1 && !chunk.contains(x+1, y, z)) addedFaces[1] = true;\n        if (y > 0 && !chunk.contains(x, y-1, z)) addedFaces[2] = true;\n        if (y < dimensions[1]-1 && !chunk.contains(x, y+1, z)) addedFaces[3] = true;\n        if (z > 0 && !chunk.contains(x, y, z-1)) addedFaces[4] = true;\n        if (z < dimensions[2]-1 && !chunk.contains(x, y, z+1)) addedFaces[5] = true;\n\n        let removedFaces = [\n            !addedFaces[0] && x > 0,             // x-\n            !addedFaces[1] && x < dimensions[0]-1, // x+\n            !addedFaces[2] && y > 0,             // y-\n            !addedFaces[3] && y < dimensions[1]-1, // y+\n            !addedFaces[4] && z > 0,             // z-\n            !addedFaces[5] && z < dimensions[2]-1  // z+\n            // N.B. whatever the block update, there will always be 6 modified faces (non-boundary case).\n        ];\n\n        UpdaterFace.rawUpdateAfterEdition(chunk, id, x, y, z, addedFaces, removedFaces, true);\n\n        if (UpdaterFace.detectProbableTopologyChangeAfterAddition(chunk, id, x, y, z, addedFaces))\n        // N.B. a necessary yet not sufficient condition for effective division of components within the chunk.\n            UpdaterFace.divideConnectedComponents(chunk, id, x, y, z, addedFaces);\n\n        // Topology-preserving boundary faces edition\n        return UpdaterFace.updateFacesOnBoundary(chunk, x, y, z, true);\n    }\n\n    /**\n     * Gets the id of a face taken from a block.\n     * @param id block id\n     * @param normal which of the 6 faces (+/- x/y/z)\n     * 0 -> x-, 1 -> x+, 2 -> y-, 3 -> y+, 4 -> z-, 5 -> z+.\n     * @param dimensions chunk size\n     */\n    static getFaceIdFromCoordinatesAndNormal(id, normal, dimensions) {\n        let ddd = dimensions[0]*dimensions[1]*dimensions[2];\n        switch (normal) { // TODO boundary management...\n            case 0: return id - 1;\n            case 2: return ddd + id - dimensions[0];\n            case 4: return 2*ddd + id - dimensions[0]*dimensions[1];\n\n            case 1: return id;\n            case 3: return ddd + id;\n            case 5: return 2*ddd + id;\n            default:\n        }\n    }\n\n    // ADDITION ONLY\n    static getFaceColorFromIdAndNormal(chunk, x, y, z, direction) {\n        let _this = chunk.what(x, y, z);\n        let thisEmpty = (_this === 0);\n        let dimensions = chunk.dimensions;\n        if (thisEmpty) {\n            switch (direction) {\n                case 0: // x-\n                    if (x > 0) return chunk.what(x-1, y, z);\n                    break;\n\n                case 1: // x+\n                    if (x+1 < dimensions[0]) return chunk.what(x+1, y, z);\n                    break;\n\n                case 2: // y-\n                    if (y > 0) return chunk.what(x, y-1, z);\n                    break;\n\n                case 3: // y+\n                    if (y+1 < dimensions[1]) return chunk.what(x, y+1, z);\n                    break;\n\n                case 4: // z-\n                    if (z > 0) return chunk.what(x, y, z-1);\n                    break;\n\n                case 5: // z+\n                    if (z+1 < dimensions[2]) return chunk.what(x, y, z+1);\n                    break;\n\n                default:\n            }\n        } else {\n            return _this;\n        }\n        return 0;\n    }\n\n    static rawUpdateAfterEdition(chunk, id, x, y, z, addedFaces, removedFaces, isAddition) {\n        // Compute updated faces.\n        let dimensions = chunk.dimensions;\n\n        let removedFaceIds = new Int32Array(removedFaces.length);\n        let addedFaceIds = new Int32Array(addedFaces.length);\n\n        for (let normal = 0, l = removedFaces.length; normal < l; ++normal) {\n            if (!removedFaces[normal] && !addedFaces[normal]) {\n                removedFaceIds[normal] = addedFaceIds[normal] = -1;\n                continue;\n            }\n            let faceId = UpdaterFace.getFaceIdFromCoordinatesAndNormal(id, normal, dimensions);\n\n            if (removedFaces[normal]) removedFaceIds[normal] = (faceId);\n            else removedFaceIds[normal] = -1;\n            if (addedFaces[normal]) addedFaceIds[normal] = (faceId);\n            else addedFaceIds[normal] = -1;\n        }\n\n        //console.log('UPDATING COMPONENTS');\n        //console.log(removedFaceIds);\n        //console.log(addedFaceIds);\n\n        // Update components.\n        let connectedComponents = chunk.connectedComponents;\n        let fastComponents = chunk.fastComponents;\n        let fastComponentsIds = chunk.fastComponentsIds;\n\n        // Remove\n        let oldComponent = null;\n        for (let i = 0, l = removedFaceIds.length; i < l; ++i) {\n            const fid = removedFaceIds[i];\n            if (fid === -1) continue;\n\n            const componentId = connectedComponents[fid];\n            if (componentId === undefined) console.log('Face id ' + fid);\n            if (componentId < 1) {\n                console.log(\"WARN: trying to remove a face that is not registered as boundary: \" +\n                    \"component id = \" + componentId + \".\");\n                continue;\n            }\n            oldComponent = componentId;\n\n            let currentComponent = fastComponents[componentId];\n            if (currentComponent === undefined) {\n                let e = new Error('BLD: skipping removal on component ' + componentId);\n                console.log(e.stack);\n                continue;\n            }\n            let index = CollectionUtils.removeFromArray(currentComponent, fid);\n            if (currentComponent.length === 0) delete fastComponents[componentId];\n\n            let currentComponentsIds = fastComponentsIds[componentId];\n            CollectionUtils.removeFromArrayWithId(currentComponentsIds, index);\n            if (currentComponentsIds.length === 0) delete fastComponentsIds[componentId];\n\n            connectedComponents[fid] = 0;\n        }\n\n        // Insert\n        let newColor = {};\n        for (let i = 0, l = addedFaceIds.length; i < l; ++i) {\n            const fid = addedFaceIds[i];\n            if (fid === -1) continue;\n\n            // WARN this step is not topology-aware. Components are to be recomputed properly in the \"divide\" stage.\n            const componentId = oldComponent === null ? CollectionUtils.generateId(fastComponents): oldComponent;\n            if (fastComponents[componentId] === undefined) {\n                // TODO check in divide...\n                // TODO check borders with this approach\n                // TODO provide non-topo approach\n                // Somehow getting here means that the added block isn't topologically linked to any other\n                // component. So we have to create a new component id.\n                let e = new Error('BLD: invalid component id: ' + componentId + ' for insertion... BLDing.');\n                console.log(e.stack);\n\n                fastComponents[componentId] = [];\n                fastComponentsIds[componentId] = [];\n                oldComponent = componentId;\n            }\n            const location = CollectionUtils.insert(fid, fastComponents[componentId]);\n            var fastIds = fastComponentsIds[componentId];\n\n            let faceColor = UpdaterFace.getFaceColorFromIdAndNormal(chunk, x, y, z, i);\n            if (faceColor == 0) continue;\n\n            if (isAddition) {\n                if (i%2 === 0) faceColor *= -1;\n            } else {\n                if (i%2 !== 0) faceColor *= -1;\n            }\n\n            newColor[i] = faceColor;\n            fastIds.splice(location, 0, faceColor);\n            connectedComponents[fid] = componentId;\n        }\n\n        // Update updates.\n        /**\n         * UPDATES FORMAT\n         * [ {}, {}, {} ]\n         * {} -> removed (faceIds)\n         * {} -> added (faceId -> nature)\n         * {} -> changedComponents (faceId -> new nature)\n         */\n        let updates = chunk.updates;\n        let removedUpdt = updates[0];\n        let addedUpdt = updates[1];\n        let changedUpdt = updates[2];\n\n        var nbp = CollectionUtils.numberOfProperties;\n        const updatesEmpty = nbp(removedUpdt) === 0 && nbp(addedUpdt) === 0 && nbp(changedUpdt) === 0;\n\n        for (let i = 0, l = addedFaceIds.length; i < l; ++i) {\n            let fid = addedFaceIds[i];\n            if (fid === -1) continue;\n\n            if (!updatesEmpty && removedUpdt.hasOwnProperty(fid)) {\n                delete removedUpdt[fid]; // if it is marked as 'removed', then it exists in the original array\n                changedUpdt[fid] = newColor[i]; //connectedComponents[fid];\n            } else {\n                addedUpdt[fid] = newColor[i]; // connectedComponents[fid];\n            }\n        }\n\n        for (let i = 0, l = removedFaceIds.length; i < l; ++i) {\n            let fid = removedFaceIds[i];\n            if (fid === -1) continue;\n\n            if (!updatesEmpty && addedUpdt.hasOwnProperty(fid)) {\n                delete addedUpdt[fid]; // if it is marked as 'added', then it does not exist in the original array\n            } else {\n                removedUpdt[fid] = null;\n            }\n        }\n    }\n\n    static divideConnectedComponents(chunk, id, x, y, z, addedFaces) {\n        var nbp = CollectionUtils.numberOfProperties;\n        /**\n         * Idea: breadth-first search. (breadth for early detection of neighbour faces)\n         * 1 face -> 4 candidates (3 per edge). recurse clockwise.\n         * for each candidate (begin with the face aligned with its normal), validate first, push into 'mapped faces'\n         * if not already in it, recurse next.\n         * Mark each component with an index. If any of the new initial block faces is encountered during the search,\n         * no need to begin a new breadth search from it.\n         * Continue breadth searches until all initial faces are taken care of. The mapper may be reinit after each\n         * search (and in the meanwhile the corresponding connected components must be updated, and given to the update\n         * variable).\n         */\n        // TODO recurse on faces and separate effectively disconnected components.\n        // TODO if chunk was updated after the last IO call, stack modifications in the chunk update variable.\n        // Beware of component disappearance in client.\n    }\n\n    static detectTopologyChangeAfterDeletion(chunk, id, x, y, z) {\n        // Criterion: pre-existing faces belonged to separate connected components.\n        // N.B. We could have considered this a dual of topology change detection after addition.\n        // and call detectProbableTopologyChangeAfterDeletion(chunk, id, x, y, z, removedFaces)\n        // but it is computationally easier to check immediate neighborhoods for distinct CCs.\n\n        var connectedComponents = chunk.connectedComponents;\n        const capacity = chunk.capacity;\n        let dimensions = chunk.dimensions;\n        const facePlusId = chunk._toId(x, y, z);\n        let ccids = [];\n\n        if (x < dimensions[0]) ccids.push(connectedComponents[facePlusId]);\n        if (y < dimensions[1]) ccids.push(connectedComponents[capacity + facePlusId]);\n        if (z < dimensions[2]) ccids.push(connectedComponents[2 * capacity + facePlusId]);\n        if (x > 0) ccids.push(connectedComponents[chunk._toId(x-1, y, z)]);\n        if (y > 0) ccids.push(connectedComponents[capacity + chunk._toId(x, y-1, z)]);\n        if (z > 0) ccids.push(connectedComponents[2 * capacity + chunk._toId(x, y, z-1)]);\n\n        let first = ccids[0];\n        for (let i = 1; i<ccids.length; ++i) {\n            if (ccids[i] !== first) return true;\n        }\n        return false;\n    }\n\n    static addFaceToModel(chunk, faceId, kind) {\n        let connectedComponents = chunk.connectedComponents;\n        let fastComponents = chunk.fastComponents;\n        let fastComponentsIds = chunk.fastComponentsIds;\n\n        const cc = 1; // TODO Topology\n        connectedComponents[faceId] = cc;\n        if (fastComponents.hasOwnProperty(cc)) {\n            fastComponents[cc].push(faceId);\n            fastComponentsIds[cc].push(kind);\n        } else {\n            console.log('ERROR @addFaceToModel: fastComponents doesnt have a ' + cc + ' component. ' +\n                'face id: ' + faceId + ' kind: ' + kind);\n            fastComponents[cc] = [faceId];\n            fastComponentsIds[cc] = [kind];\n        }\n    }\n\n    static removeFaceFromModel(chunk, faceId) {\n        let connectedComponents = chunk.connectedComponents;\n        let fastComponents = chunk.fastComponents;\n        let fastComponentsIds = chunk.fastComponentsIds;\n\n        let cc = connectedComponents[faceId];\n        const id = CollectionUtils.removeFromArray(fastComponents[cc], faceId);\n        CollectionUtils.removeFromArrayWithId(fastComponentsIds[cc], id);\n        connectedComponents[faceId] = 0;\n    }\n\n    static updateFace(w, wOrigin, fid, chunk, isAddition) {\n        let updates = chunk.updates;\n        // TODO REMOVE FACES FROM MODEL.\n\n        // Adding a block.\n        if (isAddition) {\n            if (w !== 0) { // remove face\n                if (updates[1].hasOwnProperty(fid)) delete updates[1][fid];\n                else updates[0][fid] = null;\n                UpdaterFace.removeFaceFromModel(chunk, fid);\n\n            } else { // add face\n                if (updates[0].hasOwnProperty(fid)) {\n                    delete updates[0][fid];\n                    updates[2][fid] = wOrigin;\n                }\n                else updates[1][fid] = wOrigin;\n                UpdaterFace.addFaceToModel(chunk, fid, wOrigin);\n            }\n\n        // Removing a block.\n        } else {\n            if (w !== 0) { // add face\n                if (updates[0].hasOwnProperty(fid)) {\n                    delete updates[0][fid];\n                    updates[2][fid] = w;\n                }\n                else updates[1][fid] = w;\n                UpdaterFace.addFaceToModel(chunk, fid, w);\n\n            } else { // remove face\n                if (updates[1].hasOwnProperty(fid)) delete updates[1][fid];\n                else updates[0][fid] = null;\n                UpdaterFace.removeFaceFromModel(chunk, fid);\n            }\n        }\n    }\n\n    static updateFacesOnBoundary(chunk, x, y, z, isAddition) {\n        const capacity = chunk.capacity;\n        const dimensions = chunk.dimensions;\n\n        var updatedChunks = new Set();\n\n        if (x === dimensions[0] - 1) {\n            let wOrigin = chunk.what(x, y, z);\n            let w = chunk.neighbourWhat(x + 1, y, z);\n            if (!isAddition) {\n                w *= -1;\n                wOrigin *= -1;\n            }\n            let fid = chunk._toId(x, y, z);\n            UpdaterFace.updateFace(w, wOrigin, fid, chunk, isAddition);\n        }\n\n        if (y === dimensions[1] - 1) {\n            let wOrigin = chunk.what(x, y, z);\n            let w = chunk.neighbourWhat(x, y + 1, z);\n            if (!isAddition) {\n                w *= -1;\n                wOrigin *= -1;\n            }\n            let fid = capacity + chunk._toId(x, y, z);\n            UpdaterFace.updateFace(w, wOrigin, fid, chunk, isAddition);\n        }\n\n        if (z === dimensions[2] - 1) {\n            let wOrigin = chunk.what(x, y, z);\n            let w = chunk.neighbourContains(x, y, z + 1);\n            if (!isAddition) {\n                w *= -1;\n                wOrigin *= -1;\n            }\n            let fid = 2 * capacity + chunk._toId(x, y, z);\n            UpdaterFace.updateFace(w, wOrigin, fid, chunk, isAddition);\n        }\n\n        if (x === 0) {\n            let c = chunk.getNeighbourChunkFromRelativeCoordinates(x - 1, y, z);\n            let newX = chunk.dimensions[0] - 1;\n            let fid = c._toId(newX, y, z);\n            let wOrigin = chunk.what(x, y, z);\n            let w = c.what(newX, y, z);\n            if (isAddition) {\n                w *= -1;\n                wOrigin *= -1;\n            }\n            UpdaterFace.updateFace(w, wOrigin, fid, c, isAddition);\n            updatedChunks.add(c);\n        }\n\n        if (y === 0) {\n            let c = chunk.getNeighbourChunkFromRelativeCoordinates(x, y - 1, z);\n            let newY = chunk.dimensions[1] - 1;\n            let fid = capacity + c._toId(x, newY, z);\n            let wOrigin = chunk.what(x, y, z);\n            let w = c.what(x, newY, z);\n            if (isAddition) {\n                w *= -1;\n                wOrigin *= -1;\n            }\n            UpdaterFace.updateFace(w, wOrigin, fid, c, isAddition);\n            updatedChunks.add(c);\n        }\n\n        if (z === 0) {\n            let c = chunk.getNeighbourChunkFromRelativeCoordinates(x, y, z - 1);\n            let newZ = chunk.dimensions[2] - 1;\n            let fid = 2 * capacity + c._toId(x, y, newZ);\n            let wOrigin = chunk.what(x, y, z);\n            let w = c.what(x, y, newZ);\n            if (isAddition) {\n                w *= -1;\n                wOrigin *= -1;\n            }\n            UpdaterFace.updateFace(w, wOrigin, fid, c, isAddition);\n            updatedChunks.add(c);\n        }\n\n        return updatedChunks;\n    }\n\n    static updateSurfaceFacesAfterDeletion(chunk, id, x, y, z) {\n        let dimensions = chunk.dimensions;\n\n        // Compute concerned faces.\n        let addedFaces = [\n            false, // x-\n            false, // x+\n            false, // y-\n            false, // y+\n            false, // z-\n            false  // z+\n        ];\n\n        if (x > 0 && chunk.contains(x-1, y, z)) addedFaces[0] = true;\n        if (x < dimensions[0]-1 && chunk.contains(x+1, y, z)) addedFaces[1] = true;\n        if (y > 0 && chunk.contains(x, y-1, z)) addedFaces[2] = true;\n        if (y < dimensions[1]-1 && chunk.contains(x, y+1, z)) addedFaces[3] = true;\n        if (z > 0 && chunk.contains(x, y, z-1)) addedFaces[4] = true;\n        if (z < dimensions[2]-1 && chunk.contains(x, y, z+1)) addedFaces[5] = true;\n\n        let removedFaces = [\n            !addedFaces[0] && x > 0,             // x-\n            !addedFaces[1] && x < dimensions[0]-1, // x+\n            !addedFaces[2] && y > 0,             // y-\n            !addedFaces[3] && y < dimensions[1]-1, // y+\n            !addedFaces[4] && z > 0,             // z-\n            !addedFaces[5] && z < dimensions[2]-1  // z+\n        ];\n\n        UpdaterFace.rawUpdateAfterEdition(chunk, id, x, y, z, addedFaces, removedFaces, false);\n\n        if (UpdaterFace.detectTopologyChangeAfterDeletion(chunk, id, x, y, z))\n        // N.B. the provided criterion gives an immediate, exact answer to the topology request.\n            UpdaterFace.mergeComponents(chunk, id, x, y, z);\n\n        // Boundaries: topology-preserving updates\n        return UpdaterFace.updateFacesOnBoundary(chunk, x, y, z, false);\n    }\n\n    static mergeComponents(chunk, id, x, y, z) {\n        // TODO deletion version (much easier)\n        // Beware of !components in client.\n    }\n    \n}\n\nexport default UpdaterFace;\n"]}