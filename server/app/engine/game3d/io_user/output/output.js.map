{"version":3,"sources":["../../../../../../../server/app/engine/game3d/io_user/output/output.js"],"names":[],"mappings":"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","file":"output.js","sourcesContent":["/**\n *\n */\n\n'use strict';\n\nclass UserOutput {\n\n    static debug = false;\n\n    constructor(game) {\n        this._game = game;\n\n        this._physicsEngine     = game.physicsEngine;\n        this._topologyEngine    = game.topologyEngine;\n        this._consistencyEngine = game.consistencyEngine;\n    }\n\n    static pack(message) {\n        return JSON.stringify(message);\n    }\n\n    static bench = false;\n\n    // TODO [HIGH] -> don't recurse over every player, rather over updates...\n    update() {\n        let t1, t2;\n\n        t1 = process.hrtime();\n        //this.spawnPlayers();\n        t2 = (process.hrtime(t1)[1]/1000);\n        if (UserOutput.bench && t2 > 1000) console.log(t2 + \" µs to spawn players.\");\n\n        t1 = process.hrtime();\n        this.updateChunks();\n        t2 = (process.hrtime(t1)[1]/1000);\n        if (UserOutput.bench && t2 > 1000) console.log(t2 + \" µs to send chunk updates.\");\n\n        t1 = process.hrtime();\n        this.updateEntities();\n        t2 = (process.hrtime(t1)[1]/1000);\n        if (UserOutput.bench && t2 > 1000) console.log(t2 + \" µs to send entity updates.\");\n\n        t1 = process.hrtime();\n        this.updateX();\n        t2 = (process.hrtime(t1)[1]/1000);\n        if (UserOutput.bench && t2 > 1000) console.log(t2 + \" µs to send x updates.\");\n\n        t1 = process.hrtime();\n        this.updateMeta();\n        t2 = (process.hrtime(t1)[1]/1000);\n        if (UserOutput.bench && t2 > 1000) console.log(t2 + \" µs to send other stuff.\");\n\n        this._consistencyEngine.flushBuffers();\n    }\n\n    // Every player spawns in initial world '-1'.\n    spawnPlayers() {\n        let consistencyEngine = this._consistencyEngine;\n        let addedPlayers = consistencyEngine.getPlayerOutput();\n        let game = this._game;\n        let players = game.players;\n\n        addedPlayers.forEach(pid => {\n            let player = players.getPlayerFromId(pid);\n            if (player) {\n                let p = player, a = p.avatar;\n\n                // Load chunks.\n                // Format: {worldId: {chunkId: [fastComps, fastCompIds]}}\n                let chunks = consistencyEngine.initChunkOutputForPlayer(p);\n                p.send('chk', UserOutput.pack(chunks));\n\n                // Load entities.\n                // Format: {entityId: {p:pos, r:rot, k:kind}\n                let entities = consistencyEngine.initEntityOutputForPlayer(p);\n                p.send('ent', UserOutput.pack([a.position, a.rotation, entities]));\n\n                if (UserOutput.debug) console.log('Init a new player on game ' + game.gameId + '.');\n            }\n        });\n    }\n\n    updateChunks() {\n        let game              = this._game;\n        let topologyEngine    = this._topologyEngine;\n        let consistencyEngine = this._consistencyEngine;\n\n        let updatedChunks = topologyEngine.getOutput();\n        let consistencyOutput = consistencyEngine.getChunkOutput();\n\n        game.players.forEach(p => { if (p.avatar) {\n            let hasNew, hasUpdated;\n            let pid = p.avatar.id;\n\n            // TODO [LOW] check 'player has updated position'\n            // TODO [MEDIUM] dynamically remove chunks with GreyZone, serverside\n            // player id -> changes (world id -> chunk id -> changes)\n            let addedOrRemovedChunks = consistencyOutput.get(pid);\n            hasNew = (addedOrRemovedChunks && Object.keys(addedOrRemovedChunks).length > 0);\n\n            let updatedChunksForPlayer = topologyEngine.getOutputForPlayer(p, updatedChunks, addedOrRemovedChunks);\n            hasUpdated = (updatedChunksForPlayer && Object.keys(updatedChunksForPlayer).length > 0);\n\n            if (hasNew) {\n                // New chunk + update => bundle updates with new chunks in one call.\n                if (hasUpdated) {\n                    for (let wiA in addedOrRemovedChunks) {\n                        if (wiA in updatedChunksForPlayer) {\n                            Object.assign(addedOrRemovedChunks[wiA], updatedChunksForPlayer[wiA]);\n                            delete updatedChunksForPlayer[wiA];\n                        }\n                    }\n\n                    Object.assign(addedOrRemovedChunks, updatedChunksForPlayer);\n                }\n\n                // Format:\n                // {\n                //  'worlds': {worldId:[x,y,z]} ............... World metadata\n                //  worldId:\n                //      {chunkId: [fastCC, fastCCId]} ......... Added chunk\n                //      {chunkId: [removed, added, updated]} .. Updated chunk\n                //      {chunkId: null} ....................... Removed chunk\n                // }\n\n                let output = UserOutput.pack(addedOrRemovedChunks);\n                p.send('chk', output);\n                // TODO [CRIT] check appearance of []\n                // for (let wiA in addedOrRemovedChunks) console.log(Object.keys(addedOrRemovedChunks[wiA]));\n            }\n            else if (hasUpdated) {\n                // (Format: ditto)\n                // If only an update occurred on an existing, loaded chunk.\n                let output = UserOutput.pack(updatedChunksForPlayer);\n                p.send('chk', output);\n            }\n        }});\n\n        // Empty chunk updates buffer.\n        topologyEngine.flushOutput();\n    }\n\n    updateEntities() {\n        let game              = this._game;\n        let physicsEngine     = this._physicsEngine;\n        let consistencyEngine = this._consistencyEngine;\n\n        let updatedEntities = physicsEngine.getOutput();\n        let consistencyOutput = consistencyEngine.getEntityOutput();\n\n        if (updatedEntities.size < 1) return;\n\n        // Broadcast updates.\n        // TODO [HIGH] bundle update in one chunk.\n        game.players.forEach(p => {\n            let pid = p.avatar.id;\n\n            // If an entity in range of player p has just updated.\n            let addedOrRemovedEntities = consistencyOutput.get(pid);\n\n            // Consistency output SIMULATES UPDATED ENTITIES AS NEW ENTITIES.\n            // Rapidly checked client-side, it prevents from using YET ANOTHER CALL to physicsEngine\n            // and to compute distances between entities.\n            //let updatedEntities = physicsEngine.getOutputForPlayer(p, updatedEntities);\n\n            // TODO [LOW] detect change in position since the last time.\n            // if (!entities), do it nevertheless, for it gives the player its own position.\n            // Format:\n            // [myPosition, myRotation, {\n            //  entityId:\n            //      null .................. removed entity\n            //      {p: [], r:[], k:''} ... added or updated entity\n            // }]\n            p.send('ent', UserOutput.pack([p.avatar.position, p.avatar.rotation, addedOrRemovedEntities]));\n        });\n\n        // Empty entity updates buffer.\n        physicsEngine.flushOutput();\n    }\n\n    updateX() {\n        let game = this._game;\n        let consistencyEngine = this._consistencyEngine;\n        let xOutput = consistencyEngine.getXOutput();\n\n        game.players.forEach(p => {\n            let pid = p.avatar.id;\n            let addedOrRemovedX = xOutput.get(pid);\n\n            if (addedOrRemovedX && Object.keys(addedOrRemovedX).length > 0) {\n                let output = UserOutput.pack(addedOrRemovedX);\n\n                // Format:\n                // {portalId:\n                //  null ....................................... removed portal\n                //  [otherId, chunkId, worldId, ...state] ...... new or updated portal\n                // }\n                p.send('x', output);\n            }\n        });\n\n        // TODO [HIGH] when x updates are implemented.\n        // xEngine.flushOutput();\n    }\n\n    updateMeta() {\n        let game = this._game;\n        game.chat.updateOutput();\n    }\n\n}\n\nexport default UserOutput;\n"]}