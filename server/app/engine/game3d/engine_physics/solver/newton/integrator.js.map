{"version":3,"sources":["../../../../../../../../server/app/engine/game3d/engine_physics/solver/newton/integrator.js"],"names":[],"mappings":"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","file":"integrator.js","sourcesContent":["/**\n *\n */\n\n'use strict';\n\nimport TerrainCollider from '../collision/terrain';\n\nclass Integrator {\n\n    static isNull(vector3) {\n        return vector3 === null || vector3[0] === 0 && vector3[1] === 0 && vector3[2] === 0;\n    }\n\n    static areEqual(vector3a, vector3b) {\n        return vector3a[0] === vector3b[0] && vector3a[1] === vector3b[1] && vector3a[2] === vector3b[2];\n    }\n\n    static updatePosition(dt, impulseSpeed, force, entity, EM, world) {\n\n        //console.log(entity.adherence);\n        //console.log(entity.acceleration);\n        let hasUpdated;\n\n        if (Integrator.isNull(entity.acceleration)) {\n            //console.log('Euler');\n            hasUpdated = Integrator.integrateEuler(dt, impulseSpeed, force, entity, EM, world);\n        } else {\n            //console.log('Leapfrog');\n            hasUpdated = Integrator.integrateLeapfrog(dt, impulseSpeed, force, entity, EM, world);\n        }\n\n        return hasUpdated;\n    }\n\n    // First-order integrator\n    // @returns {boolean} whether entity has updated\n    static integrateEuler(dt, impulseSpeed, force, entity, EM, world) {\n        let mass = entity.mass;\n\n        let position = entity.position;\n        let speed = entity.speed;\n\n        // Update acceleration\n        let newAcceleration = [0, 0, 0];\n        if (mass > 0) {\n            for (let i = 0; i < 3; ++i) newAcceleration[i] = force[i] / mass;\n        }\n\n        // Update speed\n        let newSpeed = [speed[0], speed[1], speed[2]];\n        let previousImpulseSpeed = entity._impulseSpeed;\n        if (!Integrator.areEqual(previousImpulseSpeed, impulseSpeed)) {\n            for (let i = 0; i < 3; ++i) newSpeed[i] = newSpeed[i] + impulseSpeed[i] - previousImpulseSpeed[i];\n        }\n        for (let i = 0; i < 3; ++i) newSpeed[i] += dt * newAcceleration[i];\n\n        // Filter, adherence\n        let adherence = entity.adherence;\n        for (let i = 0; i<3; ++i) {\n            if (newSpeed[i] < 0 && adherence[i] || newSpeed[i] > 0 && adherence[3+i]) {\n                newSpeed[i] = 0;\n            }\n        }\n\n        // Update properties, phase 1\n        entity.speed = newSpeed;\n        entity._impulseSpeed = impulseSpeed;\n        entity.acceleration = newAcceleration;\n\n        // Detect movement\n        if (newSpeed[0] === 0 && newSpeed[1] === 0 && newSpeed[2] === 0)\n            return false;\n\n        // Guess new position without constraints.\n        let newPosition = [position[0], position[1], position[2]];\n        for (let i = 0; i < 3; ++i) newPosition[i] += 0.1 * speed[i] * dt;\n\n        // Update properties, phase 2.\n        TerrainCollider.linearCollide(entity, world, position, newPosition, dt);\n\n        // Notify an entity was updated.\n        return true;\n    }\n\n    // Second-order integrator (time-reversible, symplectic)\n    // @returns {boolean} whether entity has updated\n    static integrateLeapfrog(dt, impulseSpeed, force, entity, EM, world) {\n        let mass = entity.mass;\n\n        let position = entity.position;\n        let speed = entity.speed;\n        let acceleration = entity.acceleration;\n\n        //let previousImpulseSpeed = entity._impulseSpeed;\n        //if (!Integrator.areEqual(previousImpulseSpeed, impulseSpeed)) {\n        //    for (let i = 0; i < 3; ++i) speed[i] = speed[i] + impulseSpeed[i] - previousImpulseSpeed[i];\n        //}\n\n        // Guess new position without constraints.\n        let newPosition = [position[0], position[1], position[2]];\n        for (let i = 0; i < 3; ++i) newPosition[i] += 0.1 * dt * (speed[i]+acceleration[i]*dt*0.5);\n\n        // Detect change in position.\n        if (Integrator.areEqual(newPosition, position))\n            return false;\n\n        if (TerrainCollider.linearCollide(entity, world, position, newPosition, dt)) {\n            // entity.speed = determined by the collider\n            // entity.acceleration[2] = -0.11;\n            //let newAcceleration = [0, 0, 0];\n            //if (mass > 0) for (let i = 0; i < 3; ++i) newAcceleration[i] = force[i] / mass;\n            //entity.acceleration = newAcceleration;\n            entity.speed[0] = entity._impulseSpeed[0];\n            entity.speed[1] = entity._impulseSpeed[1];\n\n        } else {\n\n            // Update acceleration\n            let newAcceleration = [0, 0, 0];\n            if (mass > 0) {\n                for (let i = 0; i < 3; ++i) newAcceleration[i] = force[i] / mass;\n            }\n\n            // Update speed\n            let newSpeed = [speed[0], speed[1], speed[2]];\n            let previousImpulseSpeed = entity._impulseSpeed;\n            if (!Integrator.areEqual(previousImpulseSpeed, impulseSpeed)) {\n                for (let i = 0; i < 3; ++i) newSpeed[i] = newSpeed[i] + impulseSpeed[i] - previousImpulseSpeed[i];\n            }\n            for (let i = 0; i < 3; ++i) newSpeed[i] += dt * (newAcceleration[i]+acceleration[i])/2; // Leapfrog\n\n            // Update properties\n            entity.speed = newSpeed;\n            entity.acceleration = newAcceleration;\n        }\n\n        entity._impulseSpeed = impulseSpeed;\n\n        // Notify an entity was updated.\n        return true;\n    }\n\n    // TODO [MEDIUM] Verlet integrator\n\n}\n\nexport default Integrator;\n"]}