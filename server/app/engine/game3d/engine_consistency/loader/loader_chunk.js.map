{"version":3,"sources":["../../../../../../../server/app/engine/game3d/engine_consistency/loader/loader_chunk.js"],"names":[],"mappings":"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","file":"loader_chunk.js","sourcesContent":["/**\n * Extract chunk surfaces and build hierarchy.\n */\n\n'use strict';\n\nimport GeometryUtils        from '../../../math/geometry';\n\nimport WorldModel           from '../../model_world/model';\nimport WorldGenerator       from '../generator/worldgenerator';\nimport ChunkIterator        from '../builder/iterator_chunks';\nimport ChunkBuilder         from '../builder/builder_chunks';\n\nclass ChunkLoader {\n\n    static debug = false;\n    static load = true;\n    static bench = false;\n\n    constructor(consistencyEngine) {\n        // Models.\n        this._worldModel        = consistencyEngine.worldModel;\n        this._consistencyModel  = consistencyEngine.consistencyModel;\n        this._xModel            = consistencyEngine.xModel;\n    }\n\n    computeChunksForNewPlayer(player) {\n        let avatar = player.avatar;\n        let worldId = avatar.worldId;\n        let world = this._worldModel.getWorld(worldId);\n\n        // Object to be (JSON.stringify)-ed.\n        var chunksForNewPlayer = {};\n        let chunksInModel = world.allChunks;\n\n        // From player position, find concerned chunks.\n        const playerPosition = avatar.position;\n        let coords = world.getChunkCoordinates(playerPosition[0], playerPosition[1], playerPosition[2]);\n\n        const i = coords[0], j = coords[1], k = coords[2];\n        const dx = world.xSize, dy = world.ySize, dz = world.zSize;\n        let minChunkDistance = Number.POSITIVE_INFINITY;\n\n        let chunkIds = [];\n        chunkIds.push((i+','+j+','+k));\n\n        for (let m = 0, length = chunkIds.length; m < length; ++m) {\n            let currentChunkId = chunkIds[m];\n\n            // Generate chunk.\n            if (!chunksInModel.has(currentChunkId)) { // TODO [LOW] worldify or delegate to consistency updater (better).\n                if (ChunkLoader.debug) console.log(\"We should generate \" + currentChunkId + \" for the user.\");\n                let chunk = WorldGenerator.generateFlatChunk(dx, dy, dz, currentChunkId, world);\n                chunksInModel.set(currentChunkId, chunk);\n            }\n\n            // Extract surfaces.\n            let currentChunk = chunksInModel.get(currentChunkId);\n            if (!currentChunk.ready) {\n                if (ChunkLoader.debug) console.log(\"We should extract faces from \" + currentChunkId + \".\");\n                ChunkBuilder.computeChunkFaces(currentChunk);\n            }\n\n            // Test for distance.\n            const ids = currentChunkId.split(',');\n            const chunkPosition = [parseInt(ids[0])*dx/2, parseInt(ids[1])*dy/2, parseInt(ids[2])*dz/2];\n            const distance = GeometryUtils.chunkSquaredEuclideanDistance(chunkPosition, playerPosition);\n            if (distance < minChunkDistance) {\n                minChunkDistance = distance;\n                avatar.nearestChunkId = currentChunk;\n            }\n\n            let cfnpw = chunksForNewPlayer[worldId];\n            if (cfnpw) {\n                cfnpw[currentChunkId] = [currentChunk.fastComponents, currentChunk.fastComponentsIds];\n            } else {\n                chunksForNewPlayer[worldId] = {};\n                chunksForNewPlayer[worldId][currentChunkId] = [currentChunk.fastComponents, currentChunk.fastComponentsIds];\n            }\n        }\n\n        return chunksForNewPlayer;\n    }\n\n    // THOUGHT [OPTIM] n nearest, 1 chunk per X.\n    // no more than X chunk per player per iteration?\n    computeNewChunksInRange(player) {\n        if (!ChunkLoader.load) return;\n        const avatar = player.avatar;\n\n        let worldId = avatar.worldId;\n        let world = this._worldModel.getWorld(worldId);\n        let consistencyModel = this._consistencyModel;\n\n        const pos = avatar.position;\n\n        // Has nearest chunk changed?\n        let coords = world.getChunkCoordinates(pos[0], pos[1], pos[2]);\n        let nearestChunkId = coords[0]+','+coords[1]+','+coords[2];\n        let formerNearestChunkId = avatar.nearestChunkId;\n\n        // Get current chunk.\n        let starterChunk = world.getChunkById(nearestChunkId);\n        if (!starterChunk) {\n            console.log('Could not load chunk on which current entity is.');\n            return;\n        }\n\n        // Return variables.\n        var newChunksForPlayer = {};\n        var unloadedChunksForPlayer = {};\n\n        // Case 1: need to load chunks up to R_i (inner circle)\n        // and to unload from R_o (outer circle).\n        if (!consistencyModel.doneChunkLoadingPhase(player, starterChunk)) {\n            newChunksForPlayer = this.loadInnerSphere(player, starterChunk);\n            // For (i,j,k) s.t. D = d({i,j,k}, P) < P.thresh, ordered by increasing D\n                // if !P.has(i,j,k)\n                    // Load (i,j,k) and break\n\n            // unloadedChunksForPlayer = this.unloadInnerToOuterSphere(player, starterChunk);\n            unloadedChunksForPlayer = this.unloadOuterSphere(player, starterChunk);\n            // For (i,j,k) s.t. P.has(i,j,k)\n                // if d({i,j,k}, P) > P.thresh\n                    // Unload (i,j,k)\n            avatar.nearestChunkId = nearestChunkId;\n        }\n\n        // THOUGHT [OPTIM] don't test when doneChunkLoadingPhase has been reached once, until (nearest !== formerNearest)\n        // Case 2: if chunks were loaded up to R_i, but player walked\n        // into another chunk. Need to ensure all chunks are loaded up to R_i\n        // and every loaded chunk that happens to be outside R_o is unloaded.\n        /*\n        else if (nearestChunkId !== formerNearestChunkId) {\n\n            // For (i,j,k) s.t. d({i,j,k}, P) < P.thresh\n                // if !P.has(i,j,k)\n                    // Load (i,j,k) and break\n            newChunksForPlayer = this.loadInnerSphere(player, starterChunk);\n\n            // For (i,j,k) s.t. P.has(i,j,k)\n                // if d({i,j,k}, P) > P.outerThresh\n                    // Unload (i,j,k)\n            unloadedChunksForPlayer = this.unloadOuterSphere(player, starterChunk);\n            avatar.nearestChunkId = nearestChunkId;\n        }\n        */\n\n        // No avatar position change, nothing to update.\n        else {\n            unloadedChunksForPlayer = this.unloadOuterSphere(player, starterChunk);\n            return;\n        }\n\n        // Nothing to update.\n        if (Object.keys(newChunksForPlayer).length < 1 &&\n            Object.keys(unloadedChunksForPlayer).length < 1) return;\n\n        return [newChunksForPlayer, unloadedChunksForPlayer];\n    }\n\n    loadInnerSphere(player, starterChunk) {\n        let worldId = player.avatar.worldId;\n        let worldModel = this._worldModel;\n        let xModel = this._xModel;\n        let consistencyModel = this._consistencyModel;\n        // TODO [HIGH] worldify think of another location for that\n        let world = worldModel.getWorld(worldId);\n        let sRadius = WorldModel.serverLoadingRadius;\n\n        var newChunksForPlayer = {};\n\n        // Loading circle for server (a bit farther)\n        let t = process.hrtime();\n\n        const wid = starterChunk.world.worldId;\n        const cid = starterChunk.chunkId;\n        ChunkBuilder.loadNextChunk(player, wid, cid, worldModel, xModel, consistencyModel, sRadius, false);\n\n        let dt1 = (process.hrtime(t)[1]/1000);\n        if (ChunkLoader.bench && dt1 > 1000) console.log('\\t\\t' + dt1 + ' preLoad ForServer.');\n\n        // Loading circle for client (nearer)\n        // Only load one at a time!\n        // TODO [HIGH] check on Z+/-.\n        // TODO [LONG-TERM] enhance to transmit chunks when users are not so much active and so on.\n        t = process.hrtime();\n\n        var newChunk = ChunkBuilder.loadNextChunk(player, wid, cid, worldModel, xModel, consistencyModel, sRadius, true);\n\n        dt1 = (process.hrtime(t)[1]/1000);\n        if (ChunkLoader.bench && dt1 > 1000) console.log('\\t\\t' + dt1 + ' preLoad ForPlayer.');\n\n        if (newChunk) {\n            if (ChunkLoader.debug) console.log(\"New chunk : \" + newChunk.chunkId);\n            // TODO [HIGH] not only one at a time\n            newChunksForPlayer[newChunk.world.worldId] = {[newChunk.chunkId]: [newChunk.fastComponents, newChunk.fastComponentsIds]};\n        }\n\n        return newChunksForPlayer;\n    }\n\n    unloadInnerToOuterSphere(player, starterChunk) {\n        let consistencyModel = this._consistencyModel;\n        let worldModel = this._worldModel;\n        let xModel = this._xModel;\n\n        let minThreshold = player.avatar.chunkRenderDistance;\n        let maxThreshold = WorldModel.serverLoadingRadius;\n        minThreshold = Math.min(minThreshold, maxThreshold);\n\n        return ChunkBuilder.getOOBPlayerChunks(player, starterChunk, worldModel, xModel, consistencyModel, minThreshold);\n    }\n\n    unloadOuterSphere(player, starterChunk) {\n        let consistencyModel = this._consistencyModel;\n        let worldModel = this._worldModel;\n        let xModel = this._xModel;\n\n        let maxThreshold = player.avatar.chunkUnloadDistance;\n\n        return ChunkBuilder.getOOBPlayerChunks(player, starterChunk, worldModel, xModel, consistencyModel, maxThreshold);\n    }\n\n}\n\nexport default ChunkLoader;\n"]}