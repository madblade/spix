{"version":3,"sources":["../../../../../../server/app/engine/game3d/model_x/model.js"],"names":[],"mappings":"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","file":"model.js","sourcesContent":["/**\n *\n */\n\n'use strict';\n\nimport Knot             from './knot';\nimport Portal           from './portal';\n\nimport CollectionUtils  from '../../math/collections';\nimport GeometryUtils    from '../../math/geometry';\n\nimport WorldGenerator   from '../engine_consistency/generator/worldgenerator';\n\nclass XModel {\n\n    constructor(game) {\n        this._game = game;\n        this._worldModel = game.worldModel;\n\n        // Database\n        this._knots = new Map();\n        this._portals = new Map();\n\n        // world id => [map: chunk id => array of portals]\n        // TODO [LONG-TERM] optimize by sorting.\n        this._worldToChunksToPortals = new Map();\n\n        // Portal id => knots\n        this._portalsToKnots = new Map();\n\n        // Cached requests\n        this._cachedConnectivity = [new Map(), new Map()]; // WorldId+ChunkId -> portals ids.\n        // To update whenever avatar moves from one chunk to another.\n    }\n\n    static debug = false;\n\n    /** Create / link **/\n\n    // One knows it must link parts of this knots before it opens...\n    // OtherPortalId: if null, spawns an empty portal; otherwise, links an existing portal and forge it into a knot.\n    addPortal(worldId, x1, y1, z1, x2, y2, z2, position, orientation, otherPortalId) {\n        let world = this._worldModel.getWorld(worldId);\n        let portals = this._portals;\n        let worldToChunksToPortals = this._worldToChunksToPortals;\n\n        // Check parameters.\n        // Orientation should be correct.\n        if (orientation !== '+' && orientation !== '-' && orientation !== 'both') return;\n        // Portal must be orthogonal an axis: exactly one block coordinate in common.\n        let bx = x1 === x2, by = y1 === y2, bz = z1 === z2;\n        let sum = bx + by + bz;\n        if (sum !== 1 && sum !== 2) {\n            console.log('Portal not axis-aligned: ' + sum);\n            return;\n        }\n        // Portal minimal size.\n\n        // Check chunks.\n        let coords1 = world.getChunkCoordinates(x1, y1, z1);\n        let coords2 = world.getChunkCoordinates(x2, y2, z2);\n        // Must be on one same chunk. TODO [LONG-TERM] spawn them across chunks.\n        let chunk1 = world.getChunk(...coords1);\n        let chunk2 = world.getChunk(...coords2);\n        if (chunk1 && chunk1 !== chunk2) return;\n\n        let portalId = CollectionUtils.generateId(portals);\n        var portal = new Portal(worldId, portalId, [x1, y1, z1], [x2, y2, z2], position, orientation, chunk1);\n\n        let chunkId = chunk1.chunkId;\n        portals.set(portalId, portal);\n        let wtpc = worldToChunksToPortals.get(worldId), ctpc;\n        if (wtpc) {\n            ctpc = wtpc.get(chunkId);\n            if (ctpc) {\n                ctpc.add(portalId);\n            }\n            else {\n                ctpc = new Set();\n                ctpc.add(portalId);\n                wtpc.set(chunkId, ctpc);\n            }\n        } else {\n            wtpc = new Map();\n            ctpc = new Set();\n            ctpc.add(portalId);\n            wtpc.set(chunkId, ctpc);\n            worldToChunksToPortals.set(worldId, wtpc);\n        }\n\n        if (otherPortalId) {\n            this.addKnot(portalId, otherPortalId);\n        } else {\n            let newWorld = this._worldModel.addWorld();\n            if (!newWorld) {\n                console.log('Failed to create a new world.');\n                return;\n            }\n\n            // Force generation (1 chunk) and add portal.\n            let xS = newWorld.xSize, yS = newWorld.ySize, zS = newWorld.zSize;\n            // TODO [HIGH] Maybe it's not right to generate chunks here.\n            let ijk = chunkId.split(',');\n            let newChunk = WorldGenerator.generateFlatChunk(xS, yS, zS, ...ijk, newWorld);\n            newWorld.addChunk(newChunk.chunkId, newChunk);\n            this.addPortal(newWorld.worldId, x1, y1, z1, x2, y2, z2, position, orientation, portalId);\n        }\n\n        this._cachedConnectivity = [new Map(), new Map()];\n    }\n\n    // (x1, y1, z1): first block\n    // (x2, y2, z2): second block\n    // position: percentage of block towards +\n    // orientation: '+', '-' or both.\n    // One does not know where this one will lead.\n    addKnot(portalId1, portalId2) {\n        let knots = this._knots;\n        let portals = this._portals;\n        let portalsToKnots = this._portalsToKnots;\n\n        // Check portals.\n        let portal1 = portals.get(portalId1);\n        let portal2 = portals.get(portalId2);\n        if (!portal1) return;\n\n        // Check already linked.\n        if (portalsToKnots.has(portalId1)) return;\n        if (portal2 && portalsToKnots.has(portalId2)) return;\n\n        // Create knot & link portals.\n        let id = CollectionUtils.generateId(knots);\n        var knot = new Knot(id, portal1, portal2);\n\n        // Create in model.\n        knots.set(id, knot);\n        portalsToKnots.set(knot.portal1.id, knot);\n        portalsToKnots.set(knot.portal2.id, knot);\n\n        return knot;\n    }\n\n    /** Remove **/\n\n    removePortalFromPosition(worldId, x, y, z) {\n        // TODO [CRIT] worldify\n    }\n\n    removePortal(portalId) {\n        // Unlink and remove portal.\n        let portalToKnots = this._portalsToKnots;\n        let portals = this._portals;\n        let portal = portals.get(portalId);\n        if (!portal) return;\n\n        let knot = portalToKnots.get(portalId);\n\n        if (knot) {\n            let otherEnd = knot.otherEnd(portal);\n\n            if (otherEnd)\n                knot.removePortal(portal);\n            else\n                this._knots.delete(otherEnd.id);\n\n            portalToKnots.delete(portalId);\n        }\n\n        portals.delete(portalId);\n        // TODO [OPTIM] compute connected components in 4D manifold\n        this._cachedConnectivity = [new Map(), new Map()];\n    }\n\n    removeKnot(knotId) {\n        // Unlink portals.\n        let knots = this._knots;\n        let portalToKnots = this._portalsToKnots;\n        let knot = knots.get(knotId);\n\n        if (knot) {\n            let end1 = knot.portal1;\n            let end2 = knot.portal2;\n\n            if (end1) { portalToKnots.remove(end1.id); }\n            if (end2) { portalToKnots.remove(end2.id); }\n\n            knots.remove(knotId);\n        }\n\n        // Invalidate cache.\n        // THOUGHT [OPTIM] think of a wiser invalidation method.\n        this._cachedConnectivity = [new Map(), new Map()];\n    }\n\n    /** Get **/\n\n    getPortal(portalId) {\n        portalId = parseInt(portalId);\n        return this._portals.get(portalId);\n    }\n\n    chunkContainsPortal(worldId, chunkId, portalId) {\n        worldId = parseInt(worldId);\n        let ctp = this._worldToChunksToPortals.get(worldId);\n        if (!ctp) return false;\n        let p = ctp.get(chunkId);\n        if (!p) return false;\n        return p.has(portalId);\n    }\n\n    getPortalsFromChunk(worldId, chunkId) {\n        worldId = parseInt(worldId);\n        let ctp = this._worldToChunksToPortals.get(worldId);\n        if (!ctp) return null;\n        return ctp.get(chunkId);\n    }\n\n    getOtherSide(portalId) {\n        portalId = parseInt(portalId);\n        let p = this._portals.get(portalId);\n        if (!p) return;\n        let k = this._portalsToKnots.get(portalId);\n        if (!k) return;\n        return k.otherEnd(p);\n    }\n\n    // Returns a Map portalId -> [otherEndId, otherWorldId]\n    // THOUGHT 1 [OPTIM] cache deepest request, then filter cached requests from then on\n\n    // THOUGHT 2 [OPTIM] optimize time with memory.\n    // Every time a portal is created, you add in an associative map\n    // coordinates of both linked chunks (order is important).\n    // Then you can compute offsets for two chunks in different worlds (just take\n    // min distance by considering all possible combinations of ways going through superposed chunks).\n    // A way to do it efficiently is to keep a Voronoi-like structure that emulate a geographical sorting of gates,\n    // along with a sorted list of distance further between any pair of 4D subworlds.\n    // Affectation can be solved by Munkres' algorithm.\n    getConnectivity(startWid, startCid, wModel, thresh, force) {\n\n        if (!force && this._portals.size < 1) return; // Quite often.\n\n        // Request cache.\n        let aggregate = startWid + ';' + startCid + ';' + thresh;\n        let cached1 = this._cachedConnectivity[0].get(aggregate);\n        let cached2 = this._cachedConnectivity[1].get(aggregate);\n        if (cached1 && cached2) return [cached1, cached2];\n\n        var recursedPortals = new Map();\n        var recursedChunks = [];\n\n        // BFS.\n        let marks = new Set();\n        let depth = 0;\n        let count = 0;\n        let stack = [[startWid, startCid, depth]];\n        while (stack.length > 0 && depth < thresh) {\n            let element = stack.shift();\n            let currentWorld = element[0];\n            let currentChunk = element[1];\n            let currentDepth = element[2];\n\n            let marksId = currentWorld +','+ currentChunk;\n            if (marks.has(marksId)) continue;\n            marks.add(marksId);\n            recursedChunks.push([currentWorld, currentChunk, currentDepth]);\n            count++;\n\n            depth = currentDepth;\n            let world = wModel.getWorld(currentWorld);\n            let ijk = currentChunk.split(',');\n            let i = parseInt(ijk[0]), j = parseInt(ijk[1]), k = parseInt(ijk[2]);\n            let chks = [\n                ((i+1)+','+j+','+k),  ((i-1)+','+j+','+k),\n                (i+','+(j+1)+','+k),  (i+','+(j-1)+','+k),\n                (i+','+j+','+(k+1)),  (i+','+j+','+(k-1))\n            ];\n\n            // TODO [HIGH] discriminate depth k+ and k-\n            chks.forEach(c => {\n                if (!marks.has(currentWorld + ',' + c)) stack.push([currentWorld, c, currentDepth + 1]);\n            });\n\n            let gates = this.getPortalsFromChunk(currentWorld, currentChunk);\n            if (gates) {\n                gates.forEach(g => {\n                    let currentPortal = this.getPortal(g);\n                    let otherSide = this.getOtherSide(g);\n                    if (!otherSide) {\n                        recursedPortals.set(g, [null, currentPortal.chunkId, currentPortal.worldId, ...currentPortal.state]);\n                    } else {\n                        let otherChunk = otherSide.chunk;\n                        if (XModel.debug) console.log(\"origin: world \" + currentPortal.worldId + \", portal \" + currentPortal.id);\n                        if (XModel.debug) console.log(\"destin: world \" + otherSide.worldId + \", portal \" + otherSide.id);\n                        recursedPortals.set(g, [otherSide.id, currentPortal.chunkId, currentPortal.worldId, ...currentPortal.state]);\n                        if (otherChunk) {\n                            let otherWorld = otherChunk.world.worldId;\n                            let otherChunkId = otherChunk.chunkId;\n                            if (!(marks.has(otherWorld+','+otherChunkId)))\n                                stack.push([otherWorld, otherChunkId, currentDepth+1]);\n                        }\n                    }\n                });\n            }\n\n            // Usually (always, I think) already sorted.\n            // But it's important to keep it sorted. Make sure.\n            stack.sort((a, b) => a[2] - b[2]);\n        }\n\n        if (XModel.debug) console.log(count + ' iterations on ' + startWid+'/'+startCid+'/'+thresh);\n\n        this._cachedConnectivity[0].set(aggregate, recursedPortals);\n        this._cachedConnectivity[1].set(aggregate, recursedChunks);\n        return [recursedPortals, recursedChunks];\n    }\n\n}\n\nexport default XModel;\n"]}