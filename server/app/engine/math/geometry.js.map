{"version":3,"sources":["../../../../../server/app/engine/math/geometry.js"],"names":[],"mappings":";;;;AAIA;;;;;;;;;;;;;;;;IAEM;;;;;;;;;;;6CAI0B,MAAM,MAAM;AACpC,gBAAI,IAAI,CAAJ,CADgC;AAEpC,iBAAK,IAAI,IAAI,CAAJ,EAAO,IAAI,CAAJ,EAAO,EAAE,CAAF;AACnB,oBAAI,KAAK,GAAL,CAAS,CAAT,EAAY,KAAK,GAAL,CAAS,SAAS,KAAK,CAAL,CAAT,IAAoB,SAAS,KAAK,CAAL,CAAT,CAApB,CAArB,CAAJ;aADJ,OAEO,CAAP,CAJoC;;;;sDAOH,MAAM,MAAM;AAC7C,gBAAI,SAAS,CAAT;gBAAY,UAAhB,CAD6C;AAE7C,iBAAK,IAAI,IAAI,CAAJ,EAAO,IAAE,CAAF,EAAK,EAAE,CAAF,EAAK;AAAE,oBAAI,KAAK,CAAL,IAAQ,KAAK,CAAL,CAAR,CAAN,MAAuB,IAAU,IAAE,CAAF,CAAjC;aAA1B;AACA,mBAAO,MAAP,CAH6C;;;;uDAMX,SAAS,SAAS;;AAEpD,gBAAI,QAAQ,OAAR,KAAoB,QAAQ,OAAR,EAAiB,OAAO,OAAO,iBAAP,CAAhD;;;AAFoD,gBAKhD,SAAS,CAAT,CALgD,IAKhC,UAAJ,CALoC;AAMpD,gBAAI,KAAK,QAAQ,QAAR;gBAAkB,KAAK,QAAQ,QAAR,CANoB;AAOpD,iBAAK,IAAI,IAAI,CAAJ,EAAO,IAAE,CAAF,EAAK,EAAE,CAAF,EAAK;AAAE,oBAAI,GAAG,CAAH,IAAM,GAAG,CAAH,CAAN,CAAN,MAAmB,IAAU,IAAE,CAAF,CAA7B;aAA1B;AACA,mBAAO,MAAP,CARoD;;;;2CAW9B,IAAI,IAAI;AAC9B,gBAAI,IAAI,GAAG,CAAH,IAAM,GAAG,CAAH,CAAN,CADsB,CACT,IAAG,CAAH,CADS;AAE9B,gBAAI,IAAI,GAAG,CAAH,IAAM,GAAG,CAAH,CAAN,CAFsB,CAET,IAAG,CAAH,CAFS;AAG9B,gBAAI,IAAI,GAAG,CAAH,IAAM,GAAG,CAAH,CAAN,CAHsB,CAGT,IAAG,CAAH,CAHS;AAI9B,mBAAO,KAAK,IAAL,CAAU,IAAE,CAAF,GAAI,CAAJ,CAAjB,CAJ8B;;;WA5BhC;;;kBAqCS","file":"geometry.js","sourcesContent":["/**\n *\n */\n\n'use strict';\n\nclass GeometryUtils {\n\n    /** Common topology distances **/\n\n    static infiniteNormDistance(pos1, pos2) {\n        var d = 0;\n        for (let i = 0; i < 3; ++i)\n            d = Math.max(d, Math.abs(parseInt(pos1[i]) - parseInt(pos2[i])));\n        return d;\n    };\n\n    static chunkSquaredEuclideanDistance(pos1, pos2) {\n        let result = 0, d;\n        for (let i = 0; i<3; ++i) { d = pos1[i]-pos2[i]; result += d*d; }\n        return result;\n    };\n\n    static entitySquaredEuclideanDistance(entityX, entityY) {\n        // Two entities on different worlds are considered infinitely far.\n        if (entityX.worldId !== entityY.worldId) return Number.POSITIVE_INFINITY;\n\n        // Else return regular Euclidean distance.\n        let result = 0; let d;\n        let pX = entityX.position, pY = entityY.position;\n        for (let i = 0; i<3; ++i) { d = pX[i]-pY[i]; result += d*d; }\n        return result;\n    };\n\n    static euclideanDistance3(v1, v2) {\n        let x = v1[0]-v2[0]; x*=x;\n        let y = v1[1]-v2[1]; y*=y;\n        let z = v1[2]-v2[2]; z*=z;\n        return Math.sqrt(x+y+z);\n    }\n\n}\n\nexport default GeometryUtils;\n"]}