(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{4:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(process, global) {\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar TimeUtils = /*#__PURE__*/function () {\n  function TimeUtils() {\n    _classCallCheck(this, TimeUtils);\n  }\n\n  _createClass(TimeUtils, null, [{\n    key: "getTimeSecMillis",\n    value: function getTimeSecMillis() {\n      if (process && process.hrtime) {\n        return process.hrtime()[1] / 1e6;\n      } else {\n        var performance = global.performance || {};\n\n        var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {\n          return new Date().getTime();\n        };\n\n        var clocktime = performanceNow.call(performance) * 1e-3;\n        var nanoseconds = Math.floor(clocktime % 1 * 1e9);\n        return nanoseconds / 1e6;\n      }\n    }\n  }, {\n    key: "getTimeSecNano",\n    value: function getTimeSecNano(arg) {\n      if (process && process.hrtime) {\n        return process.hrtime(arg);\n      } else {\n        var performance = global.performance || {};\n\n        var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {\n          return new Date().getTime();\n        };\n\n        var hrt = function hrt(previousTimestamp) {\n          var clocktime = performanceNow.call(performance) * 1e-3;\n          var seconds = Math.floor(clocktime);\n          var nanoseconds = Math.floor(clocktime % 1 * 1e9);\n\n          if (previousTimestamp) {\n            seconds = seconds - previousTimestamp[0];\n            nanoseconds = nanoseconds - previousTimestamp[1];\n\n            if (nanoseconds < 0) {\n              seconds--;\n              nanoseconds += 1e9;\n            }\n          }\n\n          return [seconds, nanoseconds];\n        };\n\n        return hrt(arg);\n      }\n    }\n  }]);\n\n  return TimeUtils;\n}();\n\n/* harmony default export */ __webpack_exports__["a"] = (TimeUtils);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12), __webpack_require__(13)))\n\n//# sourceURL=webpack:///./server/app/engine/math/time.js?')},42:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./client/style/app.css?")},68:function(module,exports){eval("/* (ignored) */\n\n//# sourceURL=webpack:///ws_(ignored)?")},74:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./client/style/app.css\nvar style_app = __webpack_require__(42);\n\n// CONCATENATED MODULE: ./client/app/extend.js\n // Utility function to extend a prototype.\n// Can be used to concatenate objects of functions.\n\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\n/* harmony default export */ var extend = (function (prototype, functions) {\n  if (_typeof(prototype) !== \'object\' || _typeof(functions) !== \'object\') throw Error("Could not extend ".concat(prototype, " with ").concat(functions, "."));\n\n  for (var property in functions) {\n    if (prototype.hasOwnProperty(property)) throw Error("Tried to override existing property ".concat(property));\n\n    if (functions.hasOwnProperty(property)) {\n      var f = functions[property];\n      if (typeof f !== \'function\') throw Error("Could not extend prototype with ".concat(f));else prototype[property] = functions[property];\n    }\n  }\n});\n// EXTERNAL MODULE: ./node_modules/jquery/dist/jquery.js\nvar jquery = __webpack_require__(1);\nvar jquery_default = /*#__PURE__*/__webpack_require__.n(jquery);\n\n// CONCATENATED MODULE: ./client/app/modules/polyfills/dom.js\n/**\n *\n */\n\n\n\n\njquery_default.a.fn.center = function () {\n  this.css(\'position\', \'absolute\');\n  var topPx = Math.max(0, (jquery_default()(window).height() - jquery_default()(this).outerHeight()) / 2 + jquery_default()(window).scrollTop());\n  var leftPx = Math.max(0, (jquery_default()(window).width() - jquery_default()(this).outerWidth()) / 2 + jquery_default()(window).scrollLeft());\n  this.css(\'left\', "".concat(leftPx, "px"));\n  this.css(\'top\', "".concat(topPx, "px"));\n  return this;\n};\n\njquery_default()(window).resize(function () {\n  jquery_default()(\'.settings\').center();\n  jquery_default()(\'.reticle\').center();\n});\n\n// CONCATENATED MODULE: ./client/app/state/states/ingame.js\n/**\n *\n */\n\n\n\n\n\nvar IngameState = function IngameState(stateManager) {\n  this.stateManager = stateManager;\n  this.stateName = \'ingame\';\n};\n\nextend(IngameState.prototype, {\n  start: function start() {\n    jquery_default()(\'#announce\').removeClass().empty().addClass(\'reticle-wrapper\').append(\'<div class="reticle"></div>\').center().show();\n  },\n  end: function end() {\n    this.stateManager.app.engine.controls.stopListeners();\n    return new Promise(function (resolve) {\n      jquery_default()(\'#announce\').empty().removeClass(\'reticle-wrapper\');\n      resolve();\n    });\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/state/states/loading.js\n/**\n *\n */\n\n\n\n\n\nvar LoadingState = function LoadingState(stateManager) {\n  this.stateManager = stateManager;\n  this.stateName = \'loading\';\n  this.html = "\\n        <div style=\\"\\" class=\\"title noselect\\">\\n        <p>spix<br/>engineering version</p>\\n        </div>\\n        <div id=\\"cube\\" class=\\"sk-folding-cube\\">\\n        <div class=\\"sk-cube1 sk-cube\\"></div>\\n        <div class=\\"sk-cube2 sk-cube\\"></div>\\n        <div class=\\"sk-cube4 sk-cube\\"></div>\\n        <div class=\\"sk-cube3 sk-cube\\"></div>\\n        </div>";\n};\n\nextend(LoadingState.prototype, {\n  start: function start() {\n    jquery_default()(\'#announce\').empty().removeClass().append(this.html).center();\n  },\n  end: function end() {\n    return new Promise(function (resolve) {\n      var loader = jquery_default()(\'#announce\');\n      loader.fadeOut(200, function () {\n        loader.empty().removeClass(\'sk-folding-cube\');\n        resolve();\n      });\n    });\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/state/states/settings.js\n/**\n *\n */\n\n\n\n\nvar SettingsState = function SettingsState(stateManager) {\n  this.stateManager = stateManager;\n  this.stateName = \'settings\';\n};\n\nextend(SettingsState.prototype, {\n  start: function start() {\n    this.stateManager.app.engine.settings.run();\n  },\n  end: function end() {\n    return this.stateManager.app.engine.settings.stop();\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/state/states/hub.js\n/**\n * List, join, request game creation in a given server.\n */\n\n\n\n\n\nvar HubState = function HubState(stateManager) {\n  this.stateManager = stateManager;\n  this.stateName = \'hub\';\n  this.htmlHead = "\\n    <div class=\\"container\\">\\n        <div class=\\"container small-title\\">\\n            <h2>spix RC-0.1</h2>\\n        </div>\\n    ";\n  this.htmlControls = "\\n    <div class=\\"container\\">\\n\\n        <hr />\\n\\n        \x3c!-- Cube world --\x3e\\n        <div class=\\"input-group\\">\\n            <div class=\\"input-group-prepend mb-1\\">\\n                <span class=\\"input-group-text\\">Cube World</span>\\n            </div>\\n            <select id=\\"cube-game-hills\\" class=\\"form-control\\">\\n                <option value=\\"1\\" selected>Moderate Hills</option>\\n                <option value=\\"0\\">No Hills</option>\\n            </select>\\n\\n            <div class=\\"input-group-append mb-1\\">\\n                <span class=\\"input-group-text\\">Cube size</span>\\n            </div>\\n            <input class=\\"form-control\\" type=\\"number\\"\\n                value=\\"2\\" min=\\"1\\" max=\\"256\\" id=\\"cube-game-side-size\\">\\n\\n            <div class=\\"input-group-append mb-1\\">\\n                <button class=\\"btn btn-outline-light\\" id=\\"button-create-cube-game\\">\\n                    \x3c!-- style=\\"float:none\\"> --\x3e\\n                    Create\\n                </button>\\n            </div>\\n        </div>\\n\\n        \x3c!-- Flat world --\x3e\\n        <div class=\\"input-group\\">\\n            <div class=\\"input-group-prepend mb-1 flex-fill\\">\\n                <span class=\\"input-group-text flex-fill\\">Flat World</span>\\n            </div>\\n\\n            <select id=\\"flat-game-trees-type\\" class=\\"form-control\\">\\n                <option value=\\"0\\" selected>No trees</option>\\n                <option value=\\"1\\">Some trees</option>\\n            </select>\\n\\n            <select id=\\"flat-game-hills-size\\" class=\\"form-control\\">\\n                <option value=\\"1\\" selected>Regular Hills</option>\\n                <option value=\\"0\\">No Hills</option>\\n                <option value=\\"2\\">Giant Hills</option>\\n                \x3c!-- <option value=\\"3\\">Eroded formations and Arches</option>--\x3e\\n                \x3c!-- <option value=\\"4\\">Spikes</option>--\x3e\\n            </select>\\n\\n            <div class=\\"input-group-append mb-1\\">\\n                <button class=\\"btn btn-outline-light\\" id=\\"button-create-flat-game\\" style=\\"float:none\\">\\n                    Create\\n                </button>\\n            </div>\\n        </div>\\n        \\n        <div class=\\"input-group\\">\\n            <div class=\\"input-group-prepend mb-1 flex-fill\\">\\n                <span class=\\"input-group-text flex-fill\\">Fantasy World</span>\\n            </div>\\n\\n            <div class=\\"input-group-append mb-1\\">\\n                <button class=\\"btn btn-outline-light\\" id=\\"button-create-fantasy-game\\" style=\\"float:none\\">\\n                    Create\\n                </button>\\n            </div>\\n        </div>\\n\\n        \x3c!-- Unstructured world --\x3e\\n        \x3c!-- Here goes a triangulation model, graphics, update and netcode --\x3e\\n        \x3c!-- <div class=\\"input-group\\">--\x3e\\n        \x3c!--     <div class=\\"input-group-prepend mb-1 flex-fill\\">--\x3e\\n        \x3c!--         <span class=\\"input-group-text flex-fill\\">Unstructured / Simplex World</span>--\x3e\\n        \x3c!--     </div>--\x3e\\n        \x3c!--     <div class=\\"input-group-append mb-1\\">--\x3e\\n        \x3c!--         <button class=\\"btn btn-outline-light\\"--\x3e\\n        \x3c!--             id=\\"button-create-unstructured-game\\" style=\\"float:none\\">--\x3e\\n        \x3c!--             Create--\x3e\\n        \x3c!--         </button>--\x3e\\n        \x3c!--     </div>--\x3e\\n        \x3c!-- </div>--\x3e\\n\\n        \x3c!-- Demo / Tutorial --\x3e\\n        <div class=\\"input-group\\">\\n            <div class=\\"input-group-prepend mb-1 flex-fill\\">\\n                <span class=\\"input-group-text flex-fill\\">Demo / Tutorial</span>\\n            </div>\\n            <div class=\\"input-group-append mb-1\\">\\n                <button class=\\"btn btn-outline-light\\"\\n                    id=\\"button-create-demo-game\\" style=\\"float:none\\">\\n                    Create\\n                </button>\\n            </div>\\n        </div>\\n\\n        \x3c!-- Load world --\x3e\\n        \x3c!-- Here goes save and import functions server-wise --\x3e\\n        <div class=\\"input-group\\">\\n            <div class=\\"input-group-prepend mb-1 flex-fill\\">\\n                <span class=\\"input-group-text flex-fill\\">Import World (coming soon)</span>\\n            </div>\\n\\n            <input type=\\"text\\" class=\\"form-control\\" id=\\"load-game-path\\"\\n                value=\\"\\" placeholder=\\"File Path\\" disabled>\\n\\n            <div class=\\"input-group-append mb-1\\">\\n                <button class=\\"btn btn-outline-light\\"\\n                    id=\\"button-load-game\\" style=\\"float:none\\" disabled>\\n                    Import\\n                </button>\\n            </div>\\n        </div>\\n\\n        <hr />\\n\\n        <div class=\\"input-group\\">\\n            <button class=\\"btn btn-outline-light btn-block\\" id=\\"button-return-main\\">\\n                Back\\n            </button>\\n        </div>\\n    </div>\\n      ";\n};\n\nextend(HubState.prototype, {\n  getCommandsHTML: function getCommandsHTML() {\n    return this.htmlControls;\n  },\n  getInstancesHTMLContainer: function getInstancesHTMLContainer(map) {\n    return "\\n            <div class=\\"container\\" id=\\"game-instances-table\\">\\n                ".concat(this.getInstancesHTMLTable(map), "\\n            </div>\\n        ");\n  },\n  getInstancesHTMLTable: function getInstancesHTMLTable(map) {\n    var content = "\\n            <table class=\\"table table-bordered noselect\\"\\n            style=\\"width:100%\\">";\n    map.forEach(function (value, key) {\n      for (var id = 0; id < value.length; ++id) {\n        content += "<tr>\\n                        <td>".concat(key, "</td>\\n                        <td>").concat(value[id], "</td>\\n                    </tr>");\n      }\n    });\n    content += \'</table>\';\n    return content;\n  },\n  // Consider using this for faster hub state update.\n  updateInstances: function updateInstances(newMap) {\n    this.stopTableListeners();\n    var container = jquery_default()(\'#game-instances-table\');\n    container.html(this.getInstancesHTMLTable(newMap));\n    this.startTableListeners();\n  },\n  start: function start(map) {\n    // Add content then fade in.\n    var hub = jquery_default()(\'#announce\');\n    hub.empty().removeClass().addClass(\'hub\').append(this.htmlHead + this.getInstancesHTMLContainer(map) + this.getCommandsHTML()).css(\'position\', \'\').fadeIn(); // Add listeners.\n\n    this.startListeners();\n  },\n  startTableListeners: function startTableListeners() {\n    var app = this.stateManager.app;\n    jquery_default()(\'tr\').click(function () {\n      var gameType = jquery_default()(this).find(\'td:first\').text();\n      var gid = jquery_default()(this).find(\'td:last\').text(); // Send a connection request.\n\n      if (gameType === \'\' || gid === \'\') {\n        console.log(\'Invalid data.\');\n        return;\n      }\n\n      app.join(gameType, gid);\n    });\n  },\n  startListeners: function startListeners() {\n    var app = this.stateManager.app;\n    this.startTableListeners();\n    jquery_default()(\'#button-create-cube-game\').click(function () {\n      var size = jquery_default()(\'#cube-game-side-size\').val();\n      var hills = jquery_default()(\'#cube-game-hills\').children(\'option:selected\').val();\n      app.requestGameCreation(\'cube\', {\n        size: size,\n        hills: hills\n      });\n    });\n    jquery_default()(\'#button-create-fantasy-game\').click(function () {\n      app.requestGameCreation(\'fantasy\', {});\n    });\n    jquery_default()(\'#button-create-flat-game\').click(function () {\n      var hills = jquery_default()(\'#flat-game-hills-size\').children(\'option:selected\').val();\n      var trees = jquery_default()(\'#flat-game-trees-type\').children(\'option:selected\').val();\n      app.requestGameCreation(\'flat\', {\n        trees: trees,\n        hills: hills\n      });\n    });\n    jquery_default()(\'#button-create-demo-game\').click(function () {\n      app.requestGameCreation(\'demo\');\n    });\n    jquery_default()(\'#button-return-main\').click(function () {\n      // Necessary to disconnect from WebRTC socket\n      // (among, possibly, other things).\n      app.engine.connection.disconnect();\n      app.setState(\'main\');\n    }); // XXX To implement: saving / loading\n    // $(\'#button-load-game\').click(function() {\n    // load-game-path\n    // });\n    // XXX To implement: unstructured game\n    // $(\'#button-create-unstructured-game\').click(function() {});\n  },\n  stopTableListeners: function stopTableListeners() {\n    jquery_default()(\'tr\').off(\'click\');\n  },\n  stopListeners: function stopListeners() {\n    this.stopTableListeners();\n    jquery_default()(\'#button-create-cube-game\').off(\'click\');\n    jquery_default()(\'#button-create-fantasy-game\').off(\'click\');\n    jquery_default()(\'#button-create-flat-game\').off(\'click\');\n    jquery_default()(\'#button-create-demo-game\').off(\'click\');\n    jquery_default()(\'#button-return-main\').off(\'click\');\n  },\n  end: function end() {\n    // Remove jQuery listeners.\n    this.stopListeners(); // Fade out hub announce.\n\n    return new Promise(function (resolve) {\n      var hub = jquery_default()(\'#announce\');\n      hub.fadeOut(200, function () {\n        hub.empty().removeClass(\'hub\');\n        resolve();\n      });\n    });\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/state/states/mainmenu.js\n/**\n * Connect to a distant / local server or launch a local server.\n */\n\n\n\n\n\nvar MainMenuState = function MainMenuState(stateManager) {\n  this.stateManager = stateManager;\n  this.stateName = \'main\';\n  this.htmlHead = "\\n        <div class=\\"container\\">\\n            <div class=\\"container small-title\\">\\n                <h2>spix RC-0.1</h2>\\n            </div>\\n        ";\n  this.htmlDistantServer = "\\n        <div class=\\"row col-12\\"><div class=\\"col-12\\">\\n        <hr />\\n\\n        <label for=\\"connect-socket-server\\">Connect to a distant server (Socket)</label>\\n        <div class=\\"input-group\\" id=\\"connect-socket-server\\">\\n            <div class=\\"input-group-prepend\\">\\n                <span class=\\"input-group-text\\">@</span>\\n            </div>\\n\\n            <input type=\\"text\\" id=\\"remote-server-address\\"\\n                class=\\"form-control\\" placeholder=\\"IP address or host name\\">\\n\\n            <div class=\\"input-group-prepend\\" style=\\"margin-left: -1px;\\">\\n                <span class=\\"input-group-text\\">:</span>\\n            </div>\\n\\n            <input type=\\"text\\" id=\\"remote-server-port\\"\\n                class=\\"form-control\\" placeholder=\\"Port\\">\\n\\n            <div class=\\"input-group-append\\">\\n                <button id=\\"button-connect-socket-server\\"\\n                    class=\\"btn btn-outline-light\\" type=\\"button\\">Connect</button>\\n            </div>\\n        </div>\\n\\n        </div></div>\\n        ";\n  this.htmlRemoteSandbox = "\\n        <div class=\\"row col-12 d-none d-sm-block\\"><div class=\\"col-12\\">\\n        <hr />\\n\\n        <label for=\\"connect-webrtc-server\\">Connect to a remote sandbox (WebRTC, might be <em>uBlock</em>ed!)</label>\\n        <div class=\\"input-group mb-1\\" id=\\"connect-webrtc-server\\">\\n            <div class=\\"input-group-prepend\\">\\n                <span class=\\"input-group-text\\">Offer</span>\\n            </div>\\n\\n            <input type=\\"text\\" id=\\"remote-client-offer\\"\\n                class=\\"form-control\\" placeholder=\\"Offer text\\" value=\\"\\">\\n\\n            <div class=\\"input-group-prepend\\" style=\\"margin-left: -1px;\\">\\n                <span class=\\"input-group-text\\">Answer</span>\\n            </div>\\n\\n            <input type=\\"text\\" id=\\"remote-client-answer\\"\\n                class=\\"form-control\\" placeholder=\\"Answer text\\" value=\\"\\">\\n\\n            <div class=\\"input-group-append\\">\\n                <button id=\\"button-connect-webrtc-server\\"\\n                    class=\\"btn btn-outline-light\\" type=\\"button\\">Generate Answer</button>\\n            </div>\\n        </div>\\n        <div class=\\"list-group\\" id=\\"error-remote-sandbox\\"></div>\\n\\n        </div></div>\\n        ";\n  this.htmlLocalSandbox = "\\n        <div class=\\"row col-12 d-none d-sm-block\\"><div class=\\"col-12\\">\\n        <hr />\\n        <label for=\\"connect-throttle-server\\">Connect to my local sandbox (this very browser)</label>\\n        <div class=\\"input-group mb-3\\" id=\\"connect-throttle-server\\">\\n            <div class=\\"input-group-prepend flex-fill\\">\\n                <span class=\\"input-group-text flex-fill\\">@localhost/browser</span>\\n            </div>\\n            <div class=\\"input-group-append\\">\\n                <button id=\\"button-connect-throttle-server\\"\\n                    class=\\"btn btn-outline-light\\" type=\\"button\\">Connect</button>\\n            </div>\\n        </div>\\n        </div></div>\\n\\n        <div class=\\"row col-12 d-none d-sm-block\\"><div class=\\"col-12\\">\\n        <label for=\\"start-sandbox\\">Invite people into my local sandbox (WebRTC, might be <em>uBlock</em>ed!)</label>\\n        <div class=\\"input-group mb-1\\" id=\\"add-sandbox\\">\\n            <div class=\\"input-group-prepend\\">\\n                <span class=\\"input-group-text\\">@friend</span>\\n            </div>\\n            <input type=\\"text\\" id=\\"new-user-id\\" pattern=\\"^[a-zA-Z]+$\\"\\n                class=\\"form-control\\" placeholder=\\"Player ID (no space, no accents, only letters)\\">\\n            <div class=\\"input-group-append\\">\\n                <button id=\\"button-add-sandbox\\"\\n                    class=\\"btn btn-outline-light\\" type=\\"button\\">Add player slot</button>\\n            </div>\\n        </div>\\n        </div></div>\\n        ";\n  this.htmlQuick = "\\n        <div class=\\"row col-12\\"><div class=\\"col-12\\">\\n\\n        <label for=\\"play-quick\\">Solo mode</label>\\n        <div class=\\"input-group mb-1 center-block\\" id=\\"play-quick\\">\\n\\n            <div class=\\"d-none d-sm-block input-group-prepend flex-fill\\">\\n                <span class=\\"input-group-text flex-fill\\">No time to set up a server?</span>\\n            </div>\\n            <div class=\\"input-group-append\\">\\n                <button id=\\"button-play-quick\\"\\n                    class=\\"btn btn-outline-light\\" type=\\"button\\">I want to play at once; make it so!</button>\\n            </div>\\n\\n        </div>\\n\\n        </div></div>\\n        ";\n  this.htmlTail = \'</div>\';\n};\n\nextend(MainMenuState.prototype, {\n  startListeners: function startListeners() {\n    var _this = this;\n\n    jquery_default()(\'#button-connect-socket-server\').click(function () {\n      var host = jquery_default()(\'#remote-server-address\').val();\n      var port = jquery_default()(\'#remote-server-port\').val();\n      if (!host) host = \'\';\n      if (!port || isNaN(port)) port = 8000; // XXX [PROD] wire production port\n\n      _this.stateManager.app.startFromRemoteServer(host, port);\n    });\n    jquery_default()(\'#button-connect-webrtc-server\').click(function () {\n      _this.generateClientAnswer();\n    });\n    jquery_default()(\'#button-connect-throttle-server\').click(function () {\n      _this.stateManager.app.startFromLocalServer();\n    });\n    jquery_default()(\'#button-add-sandbox\').click(function () {\n      _this.addUserSlot();\n    });\n    jquery_default()(\'#button-play-quick\').click(function () {\n      _this.stateManager.app.startDemo();\n    });\n    this.listenRTCUsers();\n  },\n  start: function start() {\n    jquery_default()(\'#announce\').empty().removeClass().addClass(\'main-menu\').append(this.htmlHead + this.htmlQuick + this.htmlDistantServer + this.htmlRemoteSandbox + this.htmlLocalSandbox + this.getRTCUsers() + this.htmlTail).css(\'position\', \'\').show();\n    this.startListeners();\n  },\n  stopListeners: function stopListeners() {\n    jquery_default()(\'#button-connect-socket-server\').off(\'click\');\n    jquery_default()(\'#button-connect-webrtc-server\').off(\'click\');\n    jquery_default()(\'#button-connect-throttle-server\').off(\'click\');\n    jquery_default()(\'#button-add-sandbox\').off(\'click\');\n    jquery_default()(\'#button-play-quick\').off(\'click\');\n  },\n  end: function end() {\n    this.stopListeners();\n    return new Promise(function (resolve) {\n      jquery_default()(\'#announce\').empty();\n      resolve();\n    });\n  },\n  // ######### RTC CLIENT METHODS #########\n  generateClientAnswer: function generateClientAnswer() {\n    var rtcService = this.stateManager.app.engine.connection.rtc;\n    rtcService.createClientConnection(this);\n    jquery_default()(\'.error-message\').remove();\n    var offer = jquery_default()(\'#remote-client-offer\').val();\n\n    if (!offer) {\n      console.error(\'[MainMenu/RTC] Expected offer.\');\n      return;\n    }\n\n    var localServerModel = this.stateManager.app.model.localServer;\n    localServerModel.setLocalClientOffer(offer);\n    rtcService.createClientAnswer(offer);\n  },\n  answerSent: function answerSent(answer) {\n    var localServerModel = this.stateManager.app.model.localServer;\n    localServerModel.setLocalClientAnswer(answer);\n    jquery_default()(\'#remote-client-answer\').val(answer);\n  },\n  notifyServerFailed: function notifyServerFailed() {\n    var button = jquery_default()(\'#button-connect-webrtc-server\');\n    button.removeClass(\'status-checking\');\n    button.removeClass(\'status-connected\');\n    button.addClass(\'status-error\');\n  },\n  notifyServerChecking: function notifyServerChecking() {\n    // Front notif on button.\n    var button = jquery_default()(\'#button-connect-webrtc-server\');\n    button.removeClass(\'status-error\');\n    button.removeClass(\'status-connected\');\n    button.addClass(\'status-checking\');\n  },\n  notifyServerConnected: function notifyServerConnected(rtcSocket) {\n    var button = jquery_default()(\'#button-connect-webrtc-server\');\n    button.removeClass(\'status-checking\');\n    button.removeClass(\'status-error\');\n    button.addClass(\'status-connected\');\n    this.stateManager.app.startFromRemoteSandbox(rtcSocket);\n  },\n  // ######### RTC SERVER METHODS #########\n  getRTCUserHTML: function getRTCUserHTML(userID, offer, answer, isConnected) {\n    if (!offer) offer = \'\';else offer = offer.replace(/\\x22/g, \'&quot;\');\n    if (!answer) answer = \'\';else answer = answer.replace(/\\x22/g, \'&quot;\');\n    var status = "status-".concat(isConnected ? \'connected\' : \'error\');\n    return "\\n            <div class=\\"row col-12\\"><div class=\\"col-12\\">\\n\\n            <div class=\\"input-group mb-1\\" id=\\"".concat(userID, "\\">\\n                <div class=\\"input-group-prepend\\">\\n                    <span class=\\"input-group-text ").concat(status, "\\" id=\\"status-").concat(userID, "\\">@").concat(userID, "</span>\\n                </div>\\n                <div class=\\"input-group-append\\" style=\\"margin-right: -1px;\\">\\n                    <span class=\\"input-group-text\\">Offer</span>\\n                </div>\\n\\n                <input type=\\"text\\" id=\\"offer-user-").concat(userID, "\\"\\n                    class=\\"form-control\\" placeholder=\\"Offer\\" value=\\"").concat(offer, "\\">\\n\\n                <div class=\\"input-group-append\\" style=\\"margin-right: -1px;\\">\\n                    <span class=\\"input-group-text\\">Answer</span>\\n                </div>\\n\\n                <input type=\\"text\\" id=\\"answer-user-").concat(userID, "\\"\\n                    class=\\"form-control\\" placeholder=\\"Answer\\" value=\\"").concat(answer, "\\">\\n\\n                <div class=\\"input-group-append\\">\\n                    <button id=\\"button-connect-user-").concat(userID, "\\"\\n                        class=\\"btn btn-outline-light\\" type=\\"button\\">Connect User</button>\\n                </div>\\n                <div class=\\"input-group-append\\">\\n                    <button id=\\"button-disconnect-user-").concat(userID, "\\"\\n                        class=\\"btn btn-outline-light\\" type=\\"button\\">Disconnect User</button>\\n                </div>\\n            </div>\\n\\n            </div>\\n            ");\n  },\n  getRTCUsers: function getRTCUsers() {\n    var _this2 = this;\n\n    var localServerModel = this.stateManager.app.model.localServer;\n    var users = localServerModel.users;\n    var usersHTML = \'<div class="list-group" id="user-slots">\';\n    users.forEach(function (user, userID) {\n      usersHTML += _this2.getRTCUserHTML(userID, user.offer, user.answer, user.connected);\n    });\n    usersHTML += \'</div>\';\n    return usersHTML;\n  },\n  notifyRTCError: function notifyRTCError(errorType) {\n    jquery_default()(\'.error-message\').remove();\n    var userSlotsHTML = errorType === \'ice-failed-client\' ? jquery_default()(\'#error-remote-sandbox\') : jquery_default()(\'#user-slots\');\n    var errorMsgConsole = \'\';\n    var errorMsgHTML = \'\';\n\n    switch (errorType) {\n      case \'user-id-empty\':\n        errorMsgConsole = \'[States/MainMenu] User ID must not be empty.\';\n        errorMsgHTML = "<div class=\\"alert alert-danger error-message\\">\\n                    Please specify a Player ID (name)</div>";\n        break;\n\n      case \'user-id-taken\':\n        errorMsgConsole = \'[States/MainMenu] User ID already used.\';\n        errorMsgHTML = "<div class=\\"alert alert-danger error-message\\">\\n                    Player ID invalid or already taken</div>";\n        break;\n\n      case \'ice-failed-server\':\n      case \'ice-failed-client\':\n        errorMsgConsole = \'[States/MainMenu] ICE exchange failed.\';\n        errorMsgHTML = "<div class=\\"alert alert-danger error-message\\">\\n                    Cannot connect. Possible causes: <br />AdBlock (uncheck WebRTC protection);<br />\\n                    Firefox client timeout (10-15s);<br />\\n                    Network / firewall settings.</div>";\n        break;\n\n      default:\n        break;\n    }\n\n    console.log(errorMsgConsole);\n    userSlotsHTML.append(errorMsgHTML);\n  },\n  notifyUserChecking: function notifyUserChecking(userID) {\n    var element = jquery_default()("#status-".concat(userID));\n    element.removeClass(\'status-error\');\n    element.removeClass(\'status-connected\');\n    element.addClass(\'status-checking\');\n  },\n  notifyUserConnected: function notifyUserConnected(userID, newChannel, newConnection, rtcSocket) {\n    var element = jquery_default()("#status-".concat(userID));\n    element.removeClass(\'status-checking\');\n    element.removeClass(\'status-error\');\n    element.addClass(\'status-connected\');\n    var localServer = this.stateManager.app.model.localServer;\n    localServer.setUserConnectionStatus(userID, true);\n    localServer.setUserChannel(userID, newChannel);\n    this.stateManager.app.clientConnectedToLocalSandbox(userID, rtcSocket);\n  },\n  notifyUserDisconnected: function notifyUserDisconnected(userID) {\n    var element = jquery_default()("#status-".concat(userID));\n    element.removeClass(\'status-checking\');\n    element.removeClass(\'status-connected\');\n    element.addClass(\'status-error\');\n    this.stateManager.app.model.localServer.setUserConnectionStatus(userID, false);\n    jquery_default()("#answer-user-".concat(userID)).val();\n    jquery_default()("#offer-user-".concat(userID)).val();\n  },\n  addUserSlot: function addUserSlot() {\n    var newUserID = jquery_default()(\'#new-user-id\').val();\n    var userSlotsHTML = jquery_default()(\'#user-slots\');\n    jquery_default()(\'.error-message\').remove();\n\n    if (newUserID.length < 1) {\n      this.notifyRTCError(\'user-id-empty\');\n      return;\n    }\n\n    var localServerModel = this.stateManager.app.model.localServer;\n    var rtcService = this.stateManager.app.engine.connection.rtc; // Reconnection\n\n    if (localServerModel.isUserConnectionAvailable(newUserID)) {\n      jquery_default()("#answer-user-".concat(newUserID)).val(\'\');\n      rtcService.addServerSlot(newUserID, this, true);\n      return;\n    }\n\n    if (jquery_default()("#".concat(newUserID)).length !== 0 || localServerModel.hasUser(newUserID)) {\n      this.notifyRTCError(\'user-id-taken\');\n      return;\n    }\n\n    userSlotsHTML.append(this.getRTCUserHTML(newUserID)); // $(\'#announce\').center();\n\n    localServerModel.addUser(newUserID);\n    rtcService.addServerSlot(newUserID, this);\n  },\n  removeUserSlot: function removeUserSlot(userID) {\n    var localServerModel = this.stateManager.app.model.localServer;\n    localServerModel.removeUser(userID); // Remove listeners\n\n    jquery_default()("#button-connect-user-".concat(userID)).off(\'click\');\n    jquery_default()("#button-disconnect-user-".concat(userID)).off(\'click\'); // Remove elements\n\n    var offerElement = jquery_default()("#".concat(userID));\n    offerElement.remove();\n    jquery_default()(\'#announce\').center();\n  },\n  serverSlotCreated: function serverSlotCreated(userID, offer, connection) {\n    var offerElement = jquery_default()("#offer-user-".concat(userID));\n\n    if (!offerElement) {\n      console.error("[States/MainMenu] User \\"".concat(userID, "\\" HTML element not found."));\n      return;\n    }\n\n    offerElement.val(offer);\n    var localServerModel = this.stateManager.app.model.localServer;\n    localServerModel.setUserOffer(userID, offer);\n    localServerModel.setUserConnection(userID, connection);\n    this.listenButtonConnectUser(userID);\n    this.listenButtonDisconnectUser(userID);\n  },\n  listenRTCUsers: function listenRTCUsers() {\n    var _this3 = this;\n\n    var localServerModel = this.stateManager.app.model.localServer;\n    var users = localServerModel.users;\n    users.forEach(function (user, userID) {\n      _this3.listenButtonConnectUser(userID);\n\n      _this3.listenButtonDisconnectUser(userID);\n    });\n  },\n  listenButtonConnectUser: function listenButtonConnectUser(userID) {\n    var rtcService = this.stateManager.app.engine.connection.rtc;\n    var localServerModel = this.stateManager.app.model.localServer;\n    jquery_default()("#button-connect-user-".concat(userID)).click(function () {\n      var user = localServerModel.getUser(userID);\n\n      if (!user) {\n        console.error("User \\"".concat(userID, "\\" not found."));\n        return;\n      }\n\n      var answer = jquery_default()("#answer-user-".concat(userID)).val();\n\n      if (!answer || answer.length < 1) {\n        console.error("Invalid answer: ".concat(answer));\n        return;\n      }\n\n      rtcService.acceptInboundConnection(user.inboundConnection, answer);\n    });\n  },\n  listenButtonDisconnectUser: function listenButtonDisconnectUser(userID) {\n    var _this4 = this;\n\n    var rtcService = this.stateManager.app.engine.connection.rtc;\n    var localServerModel = this.stateManager.app.model.localServer;\n    jquery_default()("#button-disconnect-user-".concat(userID)).click(function () {\n      var user = localServerModel.getUser(userID);\n\n      if (!user) {\n        console.error("User \\"".concat(userID, "\\" not found."));\n        return;\n      }\n\n      rtcService.disconnectUser(userID); // Remove user slot HTML and user model.\n\n      _this4.removeUserSlot(userID);\n    });\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/state/states/pre.ingame.js\n/**\n *\n */\n\n\n\n\n\nvar PreIngameState = function PreIngameState(stateManager) {\n  this.stateManager = stateManager;\n  this.stateName = \'preingame\';\n  this.html = "\\n        <table class=\\"table table-bordered noselect\\" style=\\"width:100%\\">\\n            <tr id=\\"request-pl\\"><td>Click to play</td></tr>\\n        </table>\\n    ";\n};\n\nextend(PreIngameState.prototype, {\n  start: function start() {\n    var _this = this;\n\n    jquery_default()(\'#announce\').empty().removeClass().addClass(\'settings\').append(this.html).center().fadeIn();\n    jquery_default()(\'#request-pl\').click(function () {\n      _this.stateManager.setState(\'ingame\');\n\n      _this.stateManager.app.engine.controls.requestLock();\n\n      _this.stateManager.app.setFocused(true);\n    });\n  },\n  end: function end() {\n    jquery_default()(\'#request-pl\').off(\'click\');\n    return new Promise(function (resolve) {\n      var requestTab = jquery_default()(\'#announce\');\n      requestTab.fadeOut(200, function () {\n        requestTab.empty().removeClass(\'settings\');\n        resolve();\n      });\n    });\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/state/states.js\n/**\n * A class managing states.\n */\n\n\n\n\n\n\n\n\n\n\n\nvar states_StateManager = function StateManager(app) {\n  this.app = app; // States\n\n  this.states = {};\n  this.previousState = \'\';\n  this.state = \'\';\n  this.focus = false; // Register actions\n\n  this.registerState(new IngameState(this));\n  this.registerState(new LoadingState(this));\n  this.registerState(new SettingsState(this));\n  this.registerState(new HubState(this));\n  this.registerState(new MainMenuState(this));\n  this.registerState(new PreIngameState(this));\n};\n\nstates_StateManager.prototype.register = [];\nextend(states_StateManager.prototype, {\n  registerState: function registerState(state) {\n    var stateId = state.stateName;\n\n    if (!this.states.hasOwnProperty(stateId)) {\n      this.states[stateId] = state;\n    }\n  },\n  // Low-level setState must handle every kind of state modification\n  setState: function setState(state, opt) {\n    this.previousState = this.state;\n    this.state = state;\n\n    if (!this.states.hasOwnProperty(this.state)) {\n      console.error("[StateManager] State \\"".concat(state, "\\" does not exist."));\n      return;\n    }\n\n    if (!this.states.hasOwnProperty(this.previousState)) {\n      // Not defined at startup (for loading, that is)\n      this.states[this.state].start(opt);\n    } else {\n      this.states[this.previousState].end().then(function () {\n        var s = this.states[this.state];\n        var start = s.start.bind(s);\n        start(opt);\n      }.bind(this));\n    }\n  },\n  cleanupDOM: function cleanupDOM() {\n    jquery_default()(\'#announce\').empty();\n    jquery_default()(\'#container\').empty(); // HUD\n\n    jquery_default()(\'#position\').empty();\n    jquery_default()(\'#chat\').empty();\n    jquery_default()(\'#network-graph\').empty();\n    jquery_default()(\'#mini-map\').empty();\n    jquery_default()(\'#items\').empty();\n    jquery_default()(\'#hud\').empty();\n  }\n});\n\n// EXTERNAL MODULE: ./node_modules/socket.io-client/lib/index.js\nvar lib = __webpack_require__(38);\nvar lib_default = /*#__PURE__*/__webpack_require__.n(lib);\n\n// CONCATENATED MODULE: ./client/app/engine/connection/rtcsocket.js\n/**\n * WebRTC Socket wrapper for RTC connections.\n */\n\n\nvar RTCSocket = function RTCSocket(dataChannel, connection, clientID) {\n  if (!clientID) clientID = \'localhost\';\n  this.dataChannel = dataChannel;\n  this.dataConnection = connection;\n  this.name = clientID;\n  this.isWebRTC = true;\n  this.actions = {};\n  this.request = {\n    connection: {\n      remoteAddress: "host-".concat(clientID, ":sandbox"),\n      remotePort: \'noport\'\n    }\n  };\n  this.nsp = {\n    name: \'nonsp\'\n  };\n  this.address = "host-".concat(clientID, ":sandbox");\n\n  this.off = function () {\n    console.log(\'[Socket] Default off function.\');\n  };\n\n  this.dataChannel.onmessage = this.receivedMessage.bind(this);\n  this.debugListeners = false;\n};\n\nextend(RTCSocket.prototype, {\n  connectionEstablished: function connectionEstablished() {\n    console.log("RTC Socket \\"".concat(this.name, "\\" connected."));\n  },\n  receivedMessage: function receivedMessage(e) {\n    if (e.data.charCodeAt(0) === 2) return;\n    var d = JSON.parse(e.data);\n    var message = d.m;\n\n    if (!message) {\n      console.error(\'[RTCSocket] Non compliant RTC message.\');\n      return;\n    }\n\n    var content = d.c;\n    var action = this.actions[message];\n\n    if (!action) {\n      console.error("[RTCSocket] No behavior for \\"".concat(message, "\\" request."));\n      return;\n    }\n\n    action(content);\n  },\n  on: function on(message, action) {\n    this.actions[message] = action;\n  },\n  removeListener: function removeListener(message) {\n    var has = this.actions.hasOwnProperty(message);\n\n    if (has) {\n      delete this.actions[message];\n      if (this.debugListeners) console.log("[Socket] Removed \'".concat(message, "\' listener"));\n    }\n  },\n  removeAllListeners: function removeAllListeners(message) {\n    var has = this.actions.hasOwnProperty(message);\n\n    if (has) {\n      delete this.actions[message];\n      if (this.debugListeners) console.log("[Socket] Removed \'".concat(message, "\' listener"));\n    }\n  },\n  disconnect: function disconnect() {\n    var m = {\n      m: \'disconnect\',\n      c: \'\'\n    };\n    this.dataChannel.send(JSON.stringify(m));\n  },\n  emit: function emit(message, data) {\n    var compact = JSON.stringify({\n      m: message,\n      c: data\n    });\n\n    if (this.dataChannel.readyState === \'open\') {\n      this.dataChannel.send(compact);\n    }\n  },\n  setDataChannel: function setDataChannel(newDataChannel) {\n    this.dataChannel = newDataChannel;\n    this.dataChannel.onmessage = this.receivedMessage.bind(this);\n  },\n  setDataConnection: function setDataConnection(newConnection) {\n    this.dataConnection = newConnection;\n  },\n  closeConnection: function closeConnection() {\n    this.dataChannel.close();\n    this.dataConnection.close();\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/engine/connection/rtc.js\n/**\n * Serverless WebRTC wrapper offering a SocketIO API.\n * Manual handshake. No IP leak.\n */\n\n\n\n\nvar RTCPeerConnection = window.RTCPeerConnection; // || window.mozRTCPeerConnection ||\n//     window.webkitRTCPeerConnection;\n\nvar RTCSessionDescription = window.RTCSessionDescription; // || window.mozRTCSessionDescription;\n\nvar RTCService = function RTCService(app) {\n  this.app = app;\n  this.outboundConnection = null;\n  this.outboundChannel = null;\n  this.inboundConnections = new Map();\n  this.inboundChannels = new Map();\n  this.sockets = new Map(); // internals\n\n  this.offer = \'\'; // for server\n\n  this.answer = \'\'; // for client\n\n  this.sdpConstraints = {\n    optional: [{\n      RtpDataChannels: true\n    }]\n  };\n  this.cfg = {\n    iceServers: [{\n      urls: \'stun:stun.l.google.com:19302\'\n    } // { urls: \'stun:stun1.l.google.com:19302\' },\n    // { urls: \'stun:stun2.l.google.com:19302\' },\n    // { urls: \'stun:stun.l.google.com:19302?transport=udp\' },\n    ] // iceCandidatePoolSize: 10,\n\n  };\n  this.con = {\n    optional: [// {DtlsSrtpKeyAgreement: true},\n      // {RtpDataChannels: true}\n    ]\n  };\n};\n\nextend(RTCService.prototype, {\n  // Create client connection from server offer\n  createClientConnection: function createClientConnection(mainMenuState) {\n    this.outboundConnection = new RTCPeerConnection(this.cfg);\n    var connection = this.outboundConnection;\n    var rtc = this;\n\n    connection.ondatachannel = function (e) {\n      var dataChannel = e.channel;\n      var rtcSocket = new RTCSocket(dataChannel, connection);\n\n      dataChannel.onopen = function () {\n        // (m) {\n        // Update HTML / Join game\n        mainMenuState.notifyServerConnected(rtcSocket);\n      }; // dataChannel.onmessage = function(m) {\n      //     let data = JSON.parse(m.data);\n      //     console.log(data.message);\n      // };\n\n\n      var probremCallback = function probremCallback() {\n        console.log(\'[RTC] Error or disconnected.\'); // XXX [HUD] notify disconnection on ingame state.\n\n        mainMenuState.notifyServerFailed();\n      };\n\n      dataChannel.onclose = probremCallback;\n      dataChannel.onclosing = probremCallback;\n      dataChannel.onerror = probremCallback;\n    };\n\n    connection.onicecandidate = function (e) {\n      if (e.candidate) return;\n      rtc.answer = JSON.stringify(connection.localDescription);\n      mainMenuState.answerSent(rtc.answer);\n    };\n\n    connection.oniceconnectionstatechange = function () {\n      console.log("[RTC] ICE connection state: ".concat(connection.iceConnectionState));\n      var status = connection.iceConnectionState;\n\n      if (status === \'failed\') {\n        mainMenuState.notifyRTCError(\'ice-failed-client\');\n        mainMenuState.notifyServerFailed();\n      } else if (status === \'checking\' || status === \'connected\') {\n        mainMenuState.notifyServerChecking();\n      } else if (status === \'disconnected\') {\n        // XXX [HUD] notify disconnection on ingame state.\n        mainMenuState.notifyServerFailed();\n      }\n    }; // connection.onsignalingstatechange = function(e) {\n    // console.log(e);\n    // };\n\n  },\n  createClientAnswer: function createClientAnswer(offer) {\n    var connection = this.outboundConnection;\n    var offerDesc = new RTCSessionDescription(JSON.parse(offer));\n    connection.setRemoteDescription(offerDesc);\n    connection.createAnswer(function (answerDesc) {\n      connection.setLocalDescription(answerDesc);\n    }, function () {\n      console.error(\'Could not create answer.\');\n    }, this.sdpConstraints);\n  },\n  // Create server slot and offer\n  addServerSlot: function addServerSlot(userID, mainMenuState, restart) {\n    var _this = this;\n\n    var newConnection = new RTCPeerConnection(this.cfg);\n\n    newConnection.onicecandidate = function (e) {\n      if (e.candidate) return;\n      _this.offer = JSON.stringify(newConnection.localDescription);\n      mainMenuState.serverSlotCreated(userID, _this.offer, newConnection);\n    }; // newConnection.onsignalingstatechange = function(e) {\n    // console.log(e);\n    // };\n\n\n    var rtcService = this;\n\n    newConnection.oniceconnectionstatechange = function () {\n      console.log("[RTC] ICE connection state: ".concat(newConnection.iceConnectionState));\n      var status = newConnection.iceConnectionState;\n\n      if (status === \'failed\') {\n        mainMenuState.notifyRTCError(\'ice-failed-server\');\n        newChannel.close();\n        newConnection.close();\n        mainMenuState.removeUserSlot(userID);\n      } else if (status === \'checking\' || status === \'connected\') {\n        mainMenuState.notifyUserChecking(userID);\n      } else if (status === \'disconnected\') {\n        mainMenuState.notifyUserDisconnected(userID);\n        rtcService.disconnectUser(userID);\n      }\n    };\n\n    var newChannel = newConnection.createDataChannel(\'chat\' // , {reliable: true}\n    );\n    if (restart) newConnection.createOffer().then(function (desc) {\n      newConnection.setLocalDescription(desc);\n    });else newConnection.createOffer().then(function (desc) {\n      newConnection.setLocalDescription(desc);\n    }); // Cache socket for reconnection\n\n    var rtcSocket = this.sockets.get(userID);\n\n    if (!rtcSocket) {\n      rtcSocket = new RTCSocket(newChannel, newConnection, userID);\n      this.sockets.set(userID, rtcSocket);\n    } else {\n      rtcSocket.setDataChannel(newChannel);\n      rtcSocket.setDataConnection(newConnection);\n    }\n\n    newChannel.onopen = function () {\n      mainMenuState.notifyUserConnected(userID, newChannel, newConnection, rtcSocket);\n      console.log(\'[RTCService/Server] RTC connection established.\');\n\n      _this.inboundChannels.set(userID, newChannel);\n\n      _this.inboundConnections.set(userID, newConnection);\n    }; // newChannel.onmessage = e => {\n    //     if (e.data.charCodeAt(0) === 2) return; // ?\n    //     let data = JSON.parse(e.data);\n    //     console.log(data.message);\n    // };\n\n\n    var probremCallback = function probremCallback() {\n      console.log(\'[RTC] Error or disconnected.\');\n      mainMenuState.notifyUserDisconnected(userID, rtcSocket);\n    };\n\n    newChannel.onclose = probremCallback;\n    newChannel.onclosing = probremCallback;\n    newChannel.onerror = probremCallback;\n  },\n  acceptInboundConnection: function acceptInboundConnection(inboundConnection, answer) {\n    var answerDesc = new RTCSessionDescription(JSON.parse(answer));\n    inboundConnection.setRemoteDescription(answerDesc);\n  },\n  disconnectUser: function disconnectUser(userID) {\n    var channel = this.inboundChannels.get(userID);\n    var connection = this.inboundConnections.get(userID);\n\n    if (channel) {\n      channel.close();\n      connection.close();\n    }\n\n    this.inboundChannels["delete"](userID);\n    this.inboundConnections["delete"](userID);\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/engine/connection/connection.js\n/**\n * Communication with the server.\n */\n\n\n\n\n\n\nvar connection_Connection = function Connection(app) {\n  this.app = app;\n  this.socket = {};\n  this.rtc = new RTCService(app);\n};\n\nextend(connection_Connection.prototype, {\n  connectSocket: function connectSocket(socketAddress, port, autoconfig) {\n    var remoteAddress = \'\';\n\n    if (!autoconfig && socketAddress === \'\' && location.hostname !== \'localhost\') {\n      remoteAddress = "ws://".concat(location.hostname, ":").concat(port);\n    } else if (!autoconfig) {\n      remoteAddress = "ws://".concat(socketAddress, ":").concat(port);\n    }\n\n    this.socket = lib_default()(remoteAddress, {\n      // Send auth token on connection, you will need to DI the Auth service above\n      // \'query\': \'token=\' + Auth.getToken()\n      path: \'/socket.io-client\'\n    });\n  },\n  setupLocalSocket: function setupLocalSocket(s) {\n    this.socket = s;\n  },\n  listen: function listen() {\n    var app = this.app;\n    var hub = app.model.hub; // Custom listeners.\n\n    this.socket.on(\'hub\', function (data) {\n      hub.update(data);\n    });\n    this.socket.on(\'joined\', function () {\n      app.joinedServer();\n    });\n    this.socket.on(\'cantjoin\', function () {\n      console.error(\'Server refused!\');\n    });\n    this.socket.on(\'connected\', function () {\n      app.connectionEstablished();\n    }); // Default listeners\n\n    this.socket.on(\'connect\', function () {\n      console.log(\'Connecting...\');\n    });\n    this.socket.on(\'disconnect\', function () {\n      console.log(\'Disconnected!\');\n    });\n    this.socket.on(\'reconnect\', function () {\n      console.log(\'Reconnecting...\');\n    });\n    this.socket.on(\'reconnect_failed\', function () {\n      console.log(\'Could not reconnect after MANY attempts.\');\n    });\n    this.socket.on(\'reconnect_error\', function () {\n      console.log(\'Reconnection failed! :(\');\n    });\n  },\n  listenQuick: function listenQuick() {\n    var app = this.app;\n    this.socket.on(\'hub\', function (data) {\n      data = JSON.parse(data);\n      var d = \'demo\';\n\n      if (!data.hasOwnProperty(d)) {\n        console.log(data);\n        console.error(\'could not join demo\');\n        return;\n      }\n\n      var array = data[d];\n\n      if (array.length !== 1) {\n        console.log(array);\n        console.log(\'WARN: Demo already present in the local sandbox.\');\n      }\n\n      if (array.length < 1) {\n        console.error(\'Failed to create demo.\');\n        return;\n      }\n\n      app._forceJoin(d, array[0]);\n    });\n    this.socket.on(\'joined\', function () {\n      app.joinedServer();\n    });\n  },\n  disconnect: function disconnect() {\n    this.socket.disconnect();\n    this.unregisterSocketForGame3D();\n    [\'hub\', \'joined\', \'cantjoin\', \'connected\', \'connect\', \'disconnect\', \'reconnect\', \'reconnect_failed\', \'reconnect_error\'].forEach(function (e) {\n      this.removeCustomListener(e);\n    }.bind(this));\n  },\n  addCustomListener: function addCustomListener(message, func) {\n    this.socket.on(message, func);\n  },\n  removeCustomListener: function removeCustomListener(message) {\n    this.socket.removeAllListeners(message);\n  },\n  send: function send(kind, message) {\n    this.socket.emit(kind, message);\n  },\n  join: function join(gameType, gid) {\n    this.send(\'util\', {\n      request: \'joinGame\',\n      gameType: gameType,\n      gameId: gid\n    });\n  },\n  requestHubState: function requestHubState() {\n    this.send(\'util\', {\n      request: \'hub\'\n    });\n  },\n  requestGameCreation: function requestGameCreation(gameType, options) {\n    this.send(\'util\', {\n      request: \'createGame\',\n      gameType: gameType,\n      options: options\n    });\n  },\n  configureGame: function configureGame(gameType, gid) {\n    switch (gameType) {\n      case \'cube\':\n      case \'flat\':\n      case \'demo\':\n      case \'fantasy\':\n        this.registerSocketForGame3D();\n        break;\n\n      case \'unstructured\':\n        console.error(\'[Client/Connection] Unstructured not yet supported.\');\n        break;\n\n      default:\n        console.error(\'Could not configure \' + \'socket listeners for an unknown game type\' + "on game ".concat(gid, "."));\n    }\n  }\n});\nextend(connection_Connection.prototype, {\n  registerSocketForGame3D: function registerSocketForGame3D() {\n    var serverModel = this.app.model.server;\n    var register = this.app.register;\n    this.addCustomListener(\'chk\', serverModel.updateChunks.bind(serverModel));\n    this.addCustomListener(\'ent\', serverModel.updateEntities.bind(serverModel));\n    this.addCustomListener(\'me\', serverModel.updateMe.bind(serverModel));\n    this.addCustomListener(\'x\', serverModel.updateX.bind(serverModel));\n    this.addCustomListener(\'chat\', register.updateChat.bind(register));\n  },\n  unregisterSocketForGame3D: function unregisterSocketForGame3D() {\n    this.removeCustomListener(\'chk\');\n    this.removeCustomListener(\'ent\');\n    this.removeCustomListener(\'me\');\n    this.removeCustomListener(\'x\');\n    this.removeCustomListener(\'chat\');\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/core.js\n/**\n * Core methods.\n */\n // import Stats from \'stats.js\';\n\nvar CoreModule = {\n  preload: function preload() {\n    var _this = this;\n\n    // Textures\n    this.loadTextures(); // Meshes\n\n    this.loadReferenceMeshes(); // Animations\n\n    this.initializeAnimations();\n    return new Promise(function (resolve) {\n      setTimeout(function () {\n        return _this.resolveIfLoaded(resolve);\n      }, 500);\n    });\n  },\n  resolveIfLoaded: function resolveIfLoaded(resolve) {\n    var _this2 = this;\n\n    if (this._nbTexturesLoaded === this._nbTexturesToLoad && this._nbMeshesToLoad === this._nbMeshesLoadedOrError) {\n      console.log(\'[Graphics/Core] Everything loaded.\');\n      resolve();\n    } else setTimeout(function () {\n      return _this2.resolveIfLoaded(resolve);\n    }, 500);\n  },\n  run: function run() {\n    // Initialize DOM element\n    this.initializeDOM(); // this.fps = this.fps || new Stats();\n    // Controls are tightly linked to camera.\n\n    this.initializeCameras(); // Init animation.\n\n    this.resize();\n    this.animate(); // Init stats.\n    // Benches.\n    // let fpsElement = this.fps.dom;\n    // fpsElement.setAttribute(\'id\', \'stats\');\n    // fpsElement.style.left = \'300px\';\n    // if (!document.getElementById(\'stats\'))\n    //     document.body.appendChild(fpsElement);\n  },\n  initializeDOM: function initializeDOM() {\n    this.container = document.getElementById(\'container\');\n    this.container.appendChild(this.rendererManager.renderer.domElement);\n  },\n\n  /** Main loop. **/\n  animate: function animate() {\n    var clientModel = this.app.model.client;\n    var serverModel = this.app.model.server;\n    var controlsEngine = this.app.engine.controls; // Request animation frame.\n\n    this.requestId = requestAnimationFrame(this.animate.bind(this)); // Emulate lower framerate\n    // this.now = Date.now();\n    // this.elapsed = this.now - (this.then || 0);\n    // const fpsInterval = 32;\n    // if (this.elapsed > fpsInterval)\n    // {\n    //     this.then = this.now - (this.elapsed % fpsInterval);\n    // }\n    // Force standalone update at animanionframe\n\n    if (this._bindStandalone) this.pingStandalone(); // Bench.\n    // this.fps.update();\n    // Update controls for Touch/Gamepad devices.\n\n    controlsEngine.updateControlsDevice(); // Render.\n\n    serverModel.refresh();\n    this.render();\n    clientModel.refresh();\n  },\n  render: function render() {\n    var sceneManager = this.sceneManager;\n    var cameraManager = this.cameraManager;\n    var rendererManager = this.rendererManager;\n    var portals = this.app.model.server.xModel.portals; // Refresh portals.\n\n    this.processPortalUpdates(); // Refresh camera mouse movements.\n\n    cameraManager.refresh(); // Perform rendering.\n\n    rendererManager.render(sceneManager, cameraManager, portals);\n  },\n  pingStandalone: function pingStandalone() {\n    var standalone = this.app.localServer.standalone;\n    var server = standalone.server;\n    if (!server) return;\n    if (!standalone.isRunning()) return;\n    this.now = Date.now();\n    this.elapsed = this.now - (this.then || 0);\n    var fpsInterval = 16; // 16ms -> 60fps physics (20fps network entity update)\n\n    if (this.elapsed > fpsInterval) {\n      this.then = this.now - this.elapsed % fpsInterval;\n\n      server._updateGameLoops();\n    }\n  },\n  stop: function stop() {\n    if (this.requestId) {\n      cancelAnimationFrame(this.requestId);\n    }\n  },\n  cleanupFullGraphics: function cleanupFullGraphics() {\n    this.sceneManager.cleanup();\n    this.cameraManager.cleanup();\n    this.rendererManager.cleanup();\n  },\n  resize: function resize() {\n    var width = window.innerWidth;\n    var height = window.innerHeight; // Update aspects.\n\n    this.cameraManager.resize(width, height); // Update main renderer.\n\n    this.rendererManager.resize(width, height); // Resize render targets.\n\n    this.sceneManager.resize(width, height);\n  },\n  initializeCameras: function initializeCameras() {\n    var selfModel = this.app.model.server.selfModel;\n    var worldId = selfModel.worldId;\n    this.addToScene(this.cameraManager.mainCamera.get3DObject(), worldId);\n    this.addToScene(this.cameraManager.mainRaycasterCamera.get3DObject(), worldId); // this.addToScene(this.cameraManager.waterCameraHelper, worldId);\n  },\n\n  /**\n   * @deprecated\n   */\n  getCameraInteraction: function getCameraInteraction() {\n    return this.app.model.client.getCameraInteraction();\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/controls.js\n/**\n *\n */\n\n\nvar ControlsModule = {\n  changeHeldItem: function changeHeldItem(itemID) {\n    // Warn! this short-circuits client-server validation.\n    // Consider pushing item held event to server in normal loop.\n    var selfModel = this.app.model.server.selfModel;\n    selfModel.updateHandItem();\n    if (this._debug) console.log("[Graphics/Controls] Changing for item ".concat(itemID, "."));\n  },\n  changeAvatarVisibility: function changeAvatarVisibility(display, avatar, worldId) {\n    if (display) this.addToScene(avatar, worldId);else this.removeFromScene(avatar, worldId);\n  }\n};\n\n// EXTERNAL MODULE: ./node_modules/three/build/three.module.js\nvar three_module = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/light.js\n/**\n *\n */\n\n\n\nvar LightDefaultIntensities = {\n  DIRECTIONAL: 0.5,\n  HEMISPHERE: 0.125,\n  // DIRECTIONAL: 0.3,\n  // HEMISPHERE: 0.325,\n  AMBIENT: 1.0\n};\nvar LightDefaultColors = Object.freeze({\n  DIRECTIONAL: 0xffffff,\n  AMBIENT: 0x0011ee,\n  HEMISPHERE_SKY: 0xeeeeff,\n  HEMISPHERE_GROUND: 0x777788\n});\nvar LightModule = {\n  createLight: function createLight(whatLight, worldId, lightType) {\n    var light;\n\n    switch (whatLight) {\n      case \'sun\':\n        light = new three_module["s" /* DirectionalLight */](LightDefaultColors.DIRECTIONAL, LightDefaultIntensities.DIRECTIONAL);\n\n        if (this.hasShadowMap()) {\n          if (!worldId || parseInt(worldId, 10) !== -1 || lightType !== \'flat\') break;\n          light.castShadow = true;\n          light.shadow.bias = -0.004;\n          var highRes = this.hasHighResShadows();\n          light.shadow.mapSize.width = highRes ? 4096 : 2048;\n          light.shadow.mapSize.height = highRes ? 4096 : 2048;\n          light.shadow.camera.near = 1;\n          light.shadow.camera.far = 200;\n          light.shadow.camera.top = 32;\n          light.shadow.camera.bottom = -32;\n          light.shadow.camera.left = 32;\n          light.shadow.camera.right = -32; // (!) this helper is not accurate\n          // let helper = new CameraHelper(light.shadow.camera);\n          // light.add(helper);\n        }\n\n        break;\n\n      case \'hemisphere\':\n        light = new three_module["C" /* HemisphereLight */](LightDefaultColors.HEMISPHERE_SKY, LightDefaultColors.HEMISPHERE_GROUND, LightDefaultIntensities.HEMISPHERE);\n        break;\n\n      default:\n        light = new three_module["c" /* AmbientLight */](LightDefaultColors.AMBIENT, LightDefaultIntensities.AMBIENT);\n    }\n\n    return light;\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/materials.js\n/**\n *\n */\n\n\n\nvar MaterialsModule = {\n  createMaterial: function createMaterial(whatMaterial, meta, worldId) {\n    var material;\n\n    switch (whatMaterial) {\n      case \'flat-phong\':\n        material = new three_module["bb" /* MeshPhongMaterial */]({\n          specular: 0xffffff,\n          flatShading: true,\n          vertexColors: three_module["Vb" /* VertexColors */],\n          color: meta && meta.color ? meta.color : null // transparent: true,\n          // opacity: 1\n\n        });\n        break;\n\n      case \'textured-phong\':\n        if (worldId === undefined) worldId = \'-1\';\n        var im = this.instancedMaterials.get(worldId);\n\n        if (!im) {\n          var params = {\n            side: three_module["z" /* FrontSide */],\n            map: this.textureAtlas,\n            transparent: false\n          }; // if (this.rendererManager.shadowVolumes)\n          //     params.transparent = true;\n\n          material = new three_module["Z" /* MeshLambertMaterial */](params);\n          var materials = [material]; // 0 -> material for main cam\n          // if (worldId === -1) materials.push(material.clone()); // 1 -> material for secondary cam\n\n          this.instancedMaterials.set(worldId, materials);\n        } else {\n          material = im[0];\n\n          if (!material) {\n            console.error("[Materials] Could not get instanced material for ".concat(worldId, "."));\n          }\n        }\n\n        break;\n\n      case \'textured-phong-water\':\n        if (worldId === undefined) worldId = \'-1\';\n        var wm = this.waterMaterials.get(worldId);\n\n        if (!wm) {\n          var _params = {\n            side: three_module["z" /* FrontSide */],\n            map: this.textureAtlas,\n            transparent: true\n          };\n          material = new three_module["Z" /* MeshLambertMaterial */](_params);\n          this.waterMaterials.set(worldId, material);\n        } else {\n          material = wm;\n\n          if (!material) {\n            console.error("[Materials] Could not get instanced material for ".concat(worldId, "."));\n          }\n        }\n\n        break;\n\n      case \'basic-black\':\n        material = new three_module["X" /* MeshBasicMaterial */]({\n          wireframe: true,\n          color: 0x000000\n        });\n        break;\n\n      default:\n        // Block material\n        material = new three_module["X" /* MeshBasicMaterial */]({\n          color: 0xff0000\n        });\n        console.log(meta);\n    }\n\n    return material;\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/model/server/self/items.js\n/**\n * Utility statics for items.\n */\nvar ItemType = Object.freeze({\n  NONE: 0,\n  // Blocks\n  BLOCK_GRASS: 1,\n  BLOCK_STONE: 2,\n  BLOCK_DIRT: 3,\n  BLOCK_WOOD: 4,\n  BLOCK_PLANKS: 5,\n  BLOCK_STONEBRICKS: 6,\n  BLOCK_BRICKS: 7,\n  BLOCK_LEAVES: 8,\n  BLOCK_WATER: 16,\n  BLOCK_SAND: 17,\n  BLOCK_IRON: 18,\n  BLOCK_OBSIDIAN: 19,\n  ORE_GOLD: 20,\n  ORE_COAL: 21,\n  ORE_DIAMOND: 22,\n  ORE_REDSTONE: 23,\n  // ...\n  // server-side: (model_world / model)\n  BLOCK_WOOL_WHITE: 32,\n  BLOCK_WOOL_GREY: 33,\n  BLOCK_WOOL_CYAN: 34,\n  BLOCK_WOOL_ORANGE: 35,\n  BLOCK_WOOL_DARK_PURPLE: 36,\n  BLOCK_WOOL_LIGHT_PURPLE: 37,\n  BLOCK_WOOL_DARK_BLUE: 38,\n  BLOCK_WOOL_LIGHT_BLUE: 39,\n  BLOCK_WOOL_BROWN: 40,\n  BLOCK_WOOL_YELLOW: 41,\n  BLOCK_WOOL_DARK_GREEN: 42,\n  BLOCK_WOOL_LIGHT_GREEN: 43,\n  BLOCK_WOOL_RED: 44,\n  BLOCK_WOOL_ROSE: 45,\n  BLOCK_WOOL_BLACK: 46,\n  BLOCK_WOOL_DARK_GREY: 47,\n  BLOCK_LAPIS: 48,\n  BLOCK_SPONGE: 49,\n  BLOCK_BEDROCK: 50,\n  BLOCK_MOSSY_STONE: 51,\n  BLOCK_CRACKED_STONE: 52,\n  BLOCK_ENDER: 53,\n  BLOCK_NETHER: 54,\n  BLOCK_DIAMOND: 55,\n  BLOCK_GOLD: 56,\n  // Weapons\n  KATANA: 257,\n  NAGAMAKI: 258,\n  // long handle longsword\n  NODACHI: 259,\n  // sephiroth longsword\n  YARI: 260,\n  // straight spear\n  NAGINATA: 261,\n  // curved spear\n  YA: 300,\n  // arrow\n  YUMI: 301,\n  // longbow\n  TEPPO: 302,\n  // arquebus\n  // ...\n  // Special items\n  PORTAL_GUN_SINGLE: 513,\n  PORTAL_GUN_DOUBLE: 514 // ...\n\n});\nvar ItemsModelModule = {\n  isItemNaught: function isItemNaught(item) {\n    return item === ItemType.NONE;\n  },\n  isItemBlock: function isItemBlock(item) {\n    return item > ItemType.NONE && item < 256;\n  },\n  isItemX: function isItemX(item) {\n    return item === ItemType.PORTAL_GUN_SINGLE || item === ItemType.PORTAL_GUN_DOUBLE;\n  },\n  isItemX2: function isItemX2(item) {\n    return item === ItemType.PORTAL_GUN_SINGLE;\n  },\n  isItemPlaceable: function isItemPlaceable(item) {\n    return ItemsModelModule.isItemBlock(item) || ItemsModelModule.isItemX(item);\n  },\n  isItemMelee: function isItemMelee(item) {\n    return item >= ItemType.KATANA && item < ItemType.YA;\n  },\n  isItemRanged: function isItemRanged(item) {\n    return item >= ItemType.YUMI && item < 512;\n  },\n  isItemUseable: function isItemUseable(item) {\n    return ItemsModelModule.isItemMelee(item) || ItemsModelModule.isItemRanged(item);\n  },\n  isItemIDSupported: function isItemIDSupported(item) {\n    if (typeof item !== \'number\') return false;\n\n    for (var i in ItemType) {\n      if (!ItemType.hasOwnProperty(i)) continue;\n      if (ItemType[i] === item) return true;\n    }\n\n    return false;\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/meshes.js\n/**\n *\n */\n\n\n\n\nvar MeshesModule = {\n  getItemMesh: function getItemMesh(itemID, renderOnTop, cloneGeometry) {\n    var itemName = this.getMeshIDFromItemID(itemID);\n\n    if (itemName) {\n      // Its a handheld item with a specific mesh\n      if (itemID === ItemType.PORTAL_GUN_DOUBLE) {// XXX [GAMEPLAY] make it purple\n      } else if (itemID === ItemType.PORTAL_GUN_SINGLE) {// XXX [GAMEPLAY] make it blue and orange\n      }\n\n      return this.loadReferenceMeshFromMemory(itemName, renderOnTop, cloneGeometry);\n    } else {\n      // Its probably a block.\n      var g = this.createGeometry(\'box\');\n      var m = this.createMaterial(\'flat-phong\');\n      var ms = this.createMesh(g, m);\n      ms.scale.set(0.4, 0.4, 0.4);\n      ms.position.set(0.4, -.25, -0.25);\n      this.renderOnTop(ms);\n      var wrapper = new three_module["kb" /* Object3D */]();\n      wrapper.rotation.reorder(\'ZYX\');\n      wrapper.add(ms);\n      return wrapper;\n    }\n  },\n  getMeshIDFromItemID: function getMeshIDFromItemID(itemID) {\n    switch (itemID) {\n      case ItemType.PORTAL_GUN_SINGLE:\n        return \'portal-gun\';\n\n      case ItemType.PORTAL_GUN_DOUBLE:\n        return \'portal-gun\';\n\n      case ItemType.YA:\n        return \'ya\';\n\n      case ItemType.YARI:\n        return \'yari\';\n\n      case ItemType.YUMI:\n        return \'yumi-morph\';\n\n      case ItemType.KATANA:\n        return \'katana\';\n\n      case ItemType.NAGINATA:\n        return \'naginata\';\n\n      case ItemType.NAGAMAKI:\n        return \'nagamaki\';\n\n      case ItemType.NODACHI:\n        return \'nodachi\';\n\n      default:\n        return;\n    }\n  },\n  loadReferenceMeshes: function loadReferenceMeshes() {\n    var _this = this;\n\n    this.referenceMeshes = new Map();\n    var meshesToLoad = [\'portal-gun\', \'yumi-morph\', \'ya\', \'yari\', \'nagamaki\', \'naginata\', \'nodachi\', \'katana\'];\n    this._nbMeshesToLoad = meshesToLoad.length + 1;\n    meshesToLoad.forEach(function (id) {\n      _this.loadItemMesh(id, function (gltfObject) {\n        _this.referenceMeshes.set(id, gltfObject);\n\n        _this._nbMeshesLoadedOrError++;\n      }, function () {\n        _this._nbMeshesLoadedOrError++;\n      });\n    });\n    this.loadMeshFromJSON(\'steve\', function (geometry) {\n      _this.referenceMeshes.set(\'steve\', geometry);\n\n      _this._nbMeshesLoadedOrError++;\n    }, function () {\n      _this._nbMeshesLoadedOrError++;\n    });\n  },\n  renderOnTop: function renderOnTop(object) {\n    if (object.children && object.children.length === 4) {\n      var c0 = object.children[0];\n      var c1 = object.children[1];\n      var c2 = object.children[2];\n      var c3 = object.children[3];\n      c0.renderOrder = 996;\n      c0.material.transparent = true;\n      c1.renderOrder = 997;\n      c1.material.transparent = true;\n      c2.renderOrder = 998;\n      c2.material.transparent = true;\n      c3.renderOrder = 996;\n      c3.material.transparent = true;\n      if (!this.hasShadowVolumes()) c0.onBeforeRender = function (renderer) {\n        return renderer.clearDepth();\n      };\n    }\n\n    if (object.material) {\n      object.material.transparent = true;\n      object.material.morphTargets = true;\n      object.renderOrder = 999;\n      if (!this.hasShadowVolumes()) object.onBeforeRender = function (renderer) {\n        return renderer.clearDepth();\n      };\n    }\n  },\n  loadReferenceMeshFromMemory: function loadReferenceMeshFromMemory(id, renderOnTop, cloneGeometry) {\n    if (!this.referenceMeshes.has(id)) {\n      console.error("[Graphics/Meshes] Could not charge a new \\"".concat(id, "\\" mesh."));\n      return;\n    }\n\n    var mesh = this.referenceMeshes.get(id);\n    if (!(mesh instanceof three_module["kb" /* Object3D */])) console.warn("[Graphics/Meshes] \\"".concat(id, "\\" should be an instance of Object3D."));\n    var clone = cloneGeometry ? mesh.clone() : mesh; // clone allows to reuse objects (but then the morph targets are reset)\n    // so use only for arrows in this setup.\n\n    clone.rotation.reorder(\'ZYX\'); // clone.material.morphTargets = true;\n\n    var inner = clone.children[0]; // console.log(inner);\n\n    if (inner && renderOnTop) this.renderOnTop(inner); // if (inner.children && inner.children.length === 4) this.renderOnTop(inner);\n    // for (let i = 0; i < inner.children.length; ++i)\n    //     inner.children[i].renderOrder = 9999;\n\n    return clone;\n  },\n  createGeometry: function createGeometry(whatGeometry) {\n    var geometry;\n\n    switch (whatGeometry) {\n      case \'plane\':\n        geometry = new three_module["qb" /* PlaneGeometry */](32, 32, 32, 32);\n        break;\n\n      case \'box\':\n        geometry = new three_module["i" /* BoxGeometry */](0.45, 0.45, 0.45);\n        break;\n\n      default:\n        geometry = new three_module["i" /* BoxGeometry */](0.5, 0.5, 1);\n    }\n\n    return geometry;\n  },\n  createMesh: function createMesh(geometry, material) {\n    return new three_module["W" /* Mesh */](geometry, material);\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/textures.js\n/**\n *\n */\n\n\n\nvar TexturesModule = {\n  loadTextures: function loadTextures() {\n    this._nbTexturesToLoad = 2;\n    this.textureAtlas = this.loadTextureAtlas(\'3.jpg\');\n    this.textureCoordinates = this.getTextureCoordinates(\'minecraft>1.5\');\n    this.textureWaterNormals = this.loadTextureNormals(\'water-normals.jpg\');\n  },\n  loadTextureNormals: function loadTextureNormals(whatTexture) {\n    var _this = this;\n\n    var loader = new three_module["Lb" /* TextureLoader */]();\n    loader.load("app/assets/textures/".concat(whatTexture), function (t) {\n      console.log(\'[Graphics/Textures] Water normals loaded.\');\n      t.wrapS = t.wrapT = three_module["Bb" /* RepeatWrapping */];\n      _this.textureWaterNormals = t;\n      _this._nbTexturesLoaded++;\n    }, undefined, function () {\n      console.error(\'[Graphics/Textures] Failed to load water normals.\');\n    });\n  },\n  loadTextureAtlas: function loadTextureAtlas(whatTexture) {\n    var _this2 = this;\n\n    var loader = new three_module["Lb" /* TextureLoader */](); // let maxAnisotropy = this.rendererManager.renderer.capabilities.getMaxAnisotropy();\n    // (this produces texture bleeding!)\n    // let texture =\n\n    loader.load("app/assets/textures/".concat(whatTexture), function (t) {\n      console.log(\'[Graphics/Textures] Texture Atlas loaded.\'); // t.anisotropy = maxAnisotropy;\n\n      t.magFilter = three_module["fb" /* NearestFilter */];\n      t.minFilter = three_module["fb" /* NearestFilter */];\n      _this2.textureAtlas = t;\n      _this2._nbTexturesLoaded++;\n    }, undefined, function () {\n      console.error(\'[Graphics/Textures] Failed to load texture atlas.\');\n    }); // texture.anisotropy = maxAnisotropy;\n    // texture.generateMipmaps = false;\n    // texture.magFilter = NearestFilter;\n    // texture.minFilter = NearestFilter;\n    // texture.minFilter = LinearMipMapLinearFilter;\n    // console.log(`Max anisotropy = ${maxAnisotropy}`);\n    // Mipmapping...\n    // let p = 512;\n    // for (let i = 0; i<10; ++i) {\n    //     console.log(p + " " + i);\n    //     let current = \'atlas_\' + p + \'.png\';\n    //     const j = i;\n    //     loader.load("app/assets/textures/" + current, function(tex) {texture.mipmaps[j] = tex.image;} );\n    //     p/=2;\n    // }\n    // Idea #1: use THREE.SceneUtils.createMultiMaterialObject( geometry, materials );\n    // then, let mesh = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );\n    // Where materials is an [] of materials and the faces use a materialIndex parameter to get appointed the right mat.\n    // Idea #2: shader\n    // return texture;\n  },\n\n  /**\n   * Gives\n   * i+, j+, k+, i-, j-, k-\n   */\n  getTextureCoordinates: function getTextureCoordinates(modelType) {\n    var coordinates;\n\n    if (modelType === \'minecraft>1.5\') {\n      coordinates = {\n        // 1. only green grass\n        // 1: [[4, 15], [4, 15], [4, 15], [4, 15], [4, 15], [4, 15]], // Planks\n        1: [[0, 15], [0, 15], [0, 15], [0, 15], [0, 15], [0, 15]],\n        // Grass\n        // 1: [[3, 15], [3, 15], [0, 15], [3, 15], [3, 15], [2, 15]], // Grass\n        2: [[1, 15], [1, 15], [1, 15], [1, 15], [1, 15], [1, 15]],\n        // Stone\n        3: [[2, 15], [2, 15], [2, 15], [2, 15], [2, 15], [2, 15]],\n        // Dirt\n        4: [[4, 14], [4, 14], [5, 14], [4, 14], [4, 14], [5, 14]],\n        // Wood\n        5: [[4, 15], [4, 15], [4, 15], [4, 15], [4, 15], [4, 15]],\n        // Planks\n        6: [[6, 12], [6, 12], [6, 12], [6, 12], [6, 12], [6, 12]],\n        // Stone bricks\n        7: [[7, 15], [7, 15], [7, 15], [7, 15], [7, 15], [7, 15]],\n        // Bricks\n        8: [[5, 12], [5, 12], [5, 12], [5, 12], [5, 12], [5, 12]],\n        // Leaves (special)\n        16: [[14, 3], [14, 3], [14, 3], [14, 3], [14, 3], [14, 3]],\n        // Water\n        17: [[2, 14], [2, 14], [2, 14], [2, 14], [2, 14], [2, 14]],\n        // Sand\n        18: [[1, 13], [1, 13], [1, 13], [1, 13], [1, 13], [1, 13]],\n        // Iron\n        19: [[7, 4], [7, 4], [7, 4], [7, 4], [7, 4], [7, 4]],\n        // Obsidian\n        // Format: [x from 0 from left, y from 0 from bottom]\n        20: [[0, 13], [0, 13], [0, 13], [0, 13], [0, 13], [0, 13]],\n        // ORE GOLD,\n        21: [[2, 13], [2, 13], [2, 13], [2, 13], [2, 13], [2, 13]],\n        // ORE COAL,\n        22: [[2, 12], [2, 12], [2, 12], [2, 12], [2, 12], [2, 12]],\n        // ORE DIAMOND,\n        23: [[3, 12], [3, 12], [3, 12], [3, 12], [3, 12], [3, 12]],\n        // ORE REDSTONE,\n        32: [[0, 11], [0, 11], [0, 11], [0, 11], [0, 11], [0, 11]],\n        // WOOL_WHITE,\n        33: [[1, 1], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1]],\n        // WOOL_GREY,\n        34: [[1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]],\n        // WOOL_CYAN,\n        35: [[2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]],\n        // WOOL_ORANGE,\n        36: [[1, 3], [1, 3], [1, 3], [1, 3], [1, 3], [1, 3]],\n        // WOOL_DARK_PURPLE,\n        37: [[2, 3], [2, 3], [2, 3], [2, 3], [2, 3], [2, 3]],\n        // WOOL_LIGHT_PURPLE,\n        38: [[1, 4], [1, 4], [1, 4], [1, 4], [1, 4], [1, 4]],\n        // WOOL_DARK_BLUE,\n        39: [[2, 4], [2, 4], [2, 4], [2, 4], [2, 4], [2, 4]],\n        // WOOL_LIGHT_BLUE,\n        40: [[1, 5], [1, 5], [1, 5], [1, 5], [1, 5], [1, 5]],\n        // WOOL_BROWN,\n        41: [[2, 5], [2, 5], [2, 5], [2, 5], [2, 5], [2, 5]],\n        // WOOL_YELLOW,\n        42: [[1, 6], [1, 6], [1, 6], [1, 6], [1, 6], [1, 6]],\n        // WOOL_DARK_GREEN,\n        43: [[2, 6], [2, 6], [2, 6], [2, 6], [2, 6], [2, 6]],\n        // WOOL_LIGHT_GREEN,\n        44: [[1, 7], [1, 7], [1, 7], [1, 7], [1, 7], [1, 7]],\n        // WOOL_RED,\n        45: [[2, 7], [2, 7], [2, 7], [2, 7], [2, 7], [2, 7]],\n        // WOOL_ROSE,\n        46: [[1, 8], [1, 8], [1, 8], [1, 8], [1, 8], [1, 8]],\n        // WOOL_BLACK,\n        47: [[2, 8], [2, 8], [2, 8], [2, 8], [2, 8], [2, 8]],\n        // WOOL_DARK_GREY,\n        48: [[0, 6], [0, 6], [0, 6], [0, 6], [0, 6], [0, 6]],\n        // LAPIS,\n        49: [[0, 12], [0, 12], [0, 12], [0, 12], [0, 12], [0, 12]],\n        // SPONGE,\n        50: [[1, 14], [1, 14], [1, 14], [1, 14], [1, 14], [1, 14]],\n        // BEDROCK,\n        51: [[4, 13], [4, 13], [4, 13], [4, 13], [4, 13], [4, 13]],\n        // MOSSY_STONE,\n        52: [[5, 9], [5, 9], [5, 9], [5, 9], [5, 9], [5, 9]],\n        // CRACKED_STONE,\n        53: [[15, 5], [15, 5], [15, 5], [15, 5], [15, 5], [15, 5]],\n        // ENDER,\n        54: [[7, 9], [7, 9], [7, 9], [7, 9], [7, 9], [7, 9]],\n        // NETHER,\n        55: [[8, 14], [8, 14], [8, 14], [8, 14], [8, 14], [8, 14]],\n        // DIAMOND,\n        56: [[7, 14], [7, 14], [7, 14], [7, 14], [7, 14], [7, 14]] // GOLD,\n\n      };\n    } else {\n      console.warn(\'[Textures] Unsupported MC texture version.\');\n      coordinates = {\n        1: [[0, 1], [0, 1], [0, 2], [0, 1], [0, 1], [0, 0]],\n        // Grass\n        2: [[5, 0], [5, 0], [5, 0], [5, 0], [5, 0], [5, 0]],\n        // Stone\n        3: [[6, 0], [6, 0], [6, 0], [6, 0], [6, 0], [6, 0]],\n        // Dirt\n        4: [[4, 1], [4, 1], [4, 2], [4, 1], [4, 1], [4, 0]],\n        // Wood\n        5: [[7, 0], [7, 0], [7, 0], [7, 0], [7, 0], [7, 0]],\n        // Planks\n        6: [[10, 0], [10, 0], [10, 0], [10, 0], [10, 0], [10, 0]],\n        // Stone bricks\n        7: [[3, 0], [3, 0], [3, 0], [3, 0], [3, 0], [3, 0]],\n        // Bricks\n        8: [[14, 0], [14, 0], [14, 0], [14, 0], [14, 0], [14, 0]],\n        // Leaves (special)\n        17: [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0]],\n        // Sand\n        18: [[1, 10], [1, 10], [1, 10], [1, 10], [1, 10], [1, 10]] // Iron\n\n      };\n    }\n\n    return coordinates;\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/entities/LegacyJSONLoader.js\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\n\nfunction LegacyJSONLoader(manager) {\n  if (typeof manager === \'boolean\') {\n    console.warn(\'THREE.JSONLoader: showStatus parameter has been removed from constructor.\');\n    manager = undefined;\n  }\n\n  this.manager = manager !== undefined ? manager : three_module["q" /* DefaultLoadingManager */];\n  this.withCredentials = false;\n}\n\nObject.assign(LegacyJSONLoader.prototype, {\n  crossOrigin: \'anonymous\',\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = this.path === undefined ? three_module["R" /* LoaderUtils */].extractUrlBase(url) : this.path;\n    var loader = new three_module["y" /* FileLoader */](this.manager);\n    loader.setPath(this.path);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      var json = JSON.parse(text);\n      var metadata = json.metadata;\n\n      if (metadata !== undefined) {\n        var type = metadata.type;\n\n        if (type !== undefined) {\n          if (type.toLowerCase() === \'object\') {\n            console.error("THREE.JSONLoader: ".concat(url, " should be loaded with THREE.ObjectLoader instead."));\n            return;\n          }\n        }\n      }\n\n      var object = scope.parse(json, path);\n      onLoad(object.geometry, object.materials);\n    }, onProgress, onError);\n  },\n  setPath: function setPath(value) {\n    this.path = value;\n    return this;\n  },\n  setResourcePath: function setResourcePath(value) {\n    this.resourcePath = value;\n    return this;\n  },\n  setCrossOrigin: function setCrossOrigin(value) {\n    this.crossOrigin = value;\n    return this;\n  },\n  parse: function () {\n    function parseModel(json, geometry) {\n      function isBitSet(value, position) {\n        return value & 1 << position;\n      }\n\n      var i;\n      var j;\n      var fi;\n      var offset;\n      var zLength;\n      var colorIndex;\n      var normalIndex;\n      var uvIndex;\n      var materialIndex;\n      var type;\n      var isQuad;\n      var hasMaterial;\n      var hasFaceVertexUv;\n      var hasFaceNormal;\n      var hasFaceVertexNormal;\n      var hasFaceColor;\n      var hasFaceVertexColor;\n      var vertex;\n      var face;\n      var faceA;\n      var faceB;\n      var hex;\n      var normal;\n      var uvLayer;\n      var uv;\n      var u;\n      var v;\n      var faces = json.faces;\n      var vertices = json.vertices;\n      var normals = json.normals;\n      var colors = json.colors;\n      var scale = json.scale;\n      var nUvLayers = 0;\n\n      if (json.uvs !== undefined) {\n        // disregard empty arrays\n        for (i = 0; i < json.uvs.length; i++) {\n          if (json.uvs[i].length) nUvLayers++;\n        }\n\n        for (i = 0; i < nUvLayers; i++) {\n          geometry.faceVertexUvs[i] = [];\n        }\n      }\n\n      offset = 0;\n      zLength = vertices.length;\n\n      while (offset < zLength) {\n        vertex = new three_module["Sb" /* Vector3 */]();\n        vertex.x = vertices[offset++] * scale;\n        vertex.y = vertices[offset++] * scale;\n        vertex.z = vertices[offset++] * scale;\n        geometry.vertices.push(vertex);\n      }\n\n      offset = 0;\n      zLength = faces.length;\n\n      while (offset < zLength) {\n        type = faces[offset++];\n        isQuad = isBitSet(type, 0);\n        hasMaterial = isBitSet(type, 1);\n        hasFaceVertexUv = isBitSet(type, 3);\n        hasFaceNormal = isBitSet(type, 4);\n        hasFaceVertexNormal = isBitSet(type, 5);\n        hasFaceColor = isBitSet(type, 6);\n        hasFaceVertexColor = isBitSet(type, 7); // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n        if (isQuad) {\n          faceA = new three_module["w" /* Face3 */]();\n          faceA.a = faces[offset];\n          faceA.b = faces[offset + 1];\n          faceA.c = faces[offset + 3];\n          faceB = new three_module["w" /* Face3 */]();\n          faceB.a = faces[offset + 1];\n          faceB.b = faces[offset + 2];\n          faceB.c = faces[offset + 3];\n          offset += 4;\n\n          if (hasMaterial) {\n            materialIndex = faces[offset++];\n            faceA.materialIndex = materialIndex;\n            faceB.materialIndex = materialIndex;\n          } // to get face <=> uv index correspondence\n\n\n          fi = geometry.faces.length;\n\n          if (hasFaceVertexUv) {\n            for (i = 0; i < nUvLayers; i++) {\n              uvLayer = json.uvs[i];\n              geometry.faceVertexUvs[i][fi] = [];\n              geometry.faceVertexUvs[i][fi + 1] = [];\n\n              for (j = 0; j < 4; j++) {\n                uvIndex = faces[offset++];\n                u = uvLayer[uvIndex * 2];\n                v = uvLayer[uvIndex * 2 + 1];\n                uv = new three_module["Rb" /* Vector2 */](u, v);\n                if (j !== 2) geometry.faceVertexUvs[i][fi].push(uv);\n                if (j !== 0) geometry.faceVertexUvs[i][fi + 1].push(uv);\n              }\n            }\n          }\n\n          if (hasFaceNormal) {\n            normalIndex = faces[offset++] * 3;\n            faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);\n            faceB.normal.copy(faceA.normal);\n          }\n\n          if (hasFaceVertexNormal) {\n            for (i = 0; i < 4; i++) {\n              normalIndex = faces[offset++] * 3;\n              normal = new three_module["Sb" /* Vector3 */](normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);\n              if (i !== 2) faceA.vertexNormals.push(normal);\n              if (i !== 0) faceB.vertexNormals.push(normal);\n            }\n          }\n\n          if (hasFaceColor) {\n            colorIndex = faces[offset++];\n            hex = colors[colorIndex];\n            faceA.color.setHex(hex);\n            faceB.color.setHex(hex);\n          }\n\n          if (hasFaceVertexColor) {\n            for (i = 0; i < 4; i++) {\n              colorIndex = faces[offset++];\n              hex = colors[colorIndex];\n              if (i !== 2) faceA.vertexColors.push(new three_module["n" /* Color */](hex));\n              if (i !== 0) faceB.vertexColors.push(new three_module["n" /* Color */](hex));\n            }\n          }\n\n          geometry.faces.push(faceA);\n          geometry.faces.push(faceB);\n        } else {\n          face = new three_module["w" /* Face3 */]();\n          face.a = faces[offset++];\n          face.b = faces[offset++];\n          face.c = faces[offset++];\n\n          if (hasMaterial) {\n            materialIndex = faces[offset++];\n            face.materialIndex = materialIndex;\n          } // to get face <=> uv index correspondence\n\n\n          fi = geometry.faces.length;\n\n          if (hasFaceVertexUv) {\n            for (i = 0; i < nUvLayers; i++) {\n              uvLayer = json.uvs[i];\n              geometry.faceVertexUvs[i][fi] = [];\n\n              for (j = 0; j < 3; j++) {\n                uvIndex = faces[offset++];\n                u = uvLayer[uvIndex * 2];\n                v = uvLayer[uvIndex * 2 + 1];\n                uv = new three_module["Rb" /* Vector2 */](u, v);\n                geometry.faceVertexUvs[i][fi].push(uv);\n              }\n            }\n          }\n\n          if (hasFaceNormal) {\n            normalIndex = faces[offset++] * 3;\n            face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);\n          }\n\n          if (hasFaceVertexNormal) {\n            for (i = 0; i < 3; i++) {\n              normalIndex = faces[offset++] * 3;\n              normal = new three_module["Sb" /* Vector3 */](normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);\n              face.vertexNormals.push(normal);\n            }\n          }\n\n          if (hasFaceColor) {\n            colorIndex = faces[offset++];\n            face.color.setHex(colors[colorIndex]);\n          }\n\n          if (hasFaceVertexColor) {\n            for (i = 0; i < 3; i++) {\n              colorIndex = faces[offset++];\n              face.vertexColors.push(new three_module["n" /* Color */](colors[colorIndex]));\n            }\n          }\n\n          geometry.faces.push(face);\n        }\n      }\n    }\n\n    function parseSkin(json, geometry) {\n      var influencesPerVertex = json.influencesPerVertex !== undefined ? json.influencesPerVertex : 2;\n\n      if (json.skinWeights) {\n        for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {\n          var x = json.skinWeights[i];\n          var y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0;\n          var z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0;\n          var w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;\n          geometry.skinWeights.push(new three_module["Tb" /* Vector4 */](x, y, z, w));\n        }\n      }\n\n      if (json.skinIndices) {\n        for (var ii = 0, ll = json.skinIndices.length; i < ll; ii += influencesPerVertex) {\n          var a = json.skinIndices[i];\n          var b = influencesPerVertex > 1 ? json.skinIndices[ii + 1] : 0;\n          var c = influencesPerVertex > 2 ? json.skinIndices[ii + 2] : 0;\n          var d = influencesPerVertex > 3 ? json.skinIndices[ii + 3] : 0;\n          geometry.skinIndices.push(new three_module["Tb" /* Vector4 */](a, b, c, d));\n        }\n      }\n\n      geometry.bones = json.bones;\n\n      if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {\n        console.warn("When skinning, number of vertices (".concat(geometry.vertices.length, "), skinIndices (").concat(geometry.skinIndices.length, "), and skinWeights (").concat(geometry.skinWeights.length, ") should match."));\n      }\n    }\n\n    function parseMorphing(json, geometry) {\n      var scale = json.scale;\n\n      if (json.morphTargets !== undefined) {\n        for (var i = 0, l = json.morphTargets.length; i < l; i++) {\n          geometry.morphTargets[i] = {};\n          geometry.morphTargets[i].name = json.morphTargets[i].name;\n          geometry.morphTargets[i].vertices = [];\n          var dstVertices = geometry.morphTargets[i].vertices;\n          var srcVertices = json.morphTargets[i].vertices;\n\n          for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {\n            var vertex = new three_module["Sb" /* Vector3 */]();\n            vertex.x = srcVertices[v] * scale;\n            vertex.y = srcVertices[v + 1] * scale;\n            vertex.z = srcVertices[v + 2] * scale;\n            dstVertices.push(vertex);\n          }\n        }\n      }\n\n      if (json.morphColors !== undefined && json.morphColors.length > 0) {\n        console.warn(\'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.\');\n        var faces = geometry.faces;\n        var morphColors = json.morphColors[0].colors;\n\n        for (var ii = 0, ll = faces.length; ii < ll; ii++) {\n          faces[ii].color.fromArray(morphColors, ii * 3);\n        }\n      }\n    }\n\n    function parseAnimations(json, geometry) {\n      var outputAnimations = []; // parse old style Bone/Hierarchy animations\n\n      var animations = [];\n\n      if (json.animation !== undefined) {\n        animations.push(json.animation);\n      }\n\n      if (json.animations !== undefined) {\n        if (json.animations.length) {\n          animations = animations.concat(json.animations);\n        } else {\n          animations.push(json.animations);\n        }\n      }\n\n      for (var i = 0; i < animations.length; i++) {\n        var clip = three_module["d" /* AnimationClip */].parseAnimation(animations[i], geometry.bones);\n        if (clip) outputAnimations.push(clip);\n      } // parse implicit morph animations\n\n\n      if (geometry.morphTargets) {\n        // XXX [ANIMATION] Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n        var morphAnimationClips = three_module["d" /* AnimationClip */].CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);\n        outputAnimations = outputAnimations.concat(morphAnimationClips);\n      }\n\n      if (outputAnimations.length > 0) geometry.animations = outputAnimations;\n    }\n\n    return function parse(json, path) {\n      if (json.data !== undefined) {\n        // Geometry 4.0 spec\n        json = json.data;\n      }\n\n      if (json.scale !== undefined) {\n        json.scale = 1.0 / json.scale;\n      } else {\n        json.scale = 1.0;\n      }\n\n      var geometry = new three_module["A" /* Geometry */]();\n      parseModel(json, geometry);\n      parseSkin(json, geometry);\n      parseMorphing(json, geometry);\n      parseAnimations(json, geometry);\n      geometry.computeFaceNormals();\n      geometry.computeBoundingSphere();\n\n      if (json.materials === undefined || json.materials.length === 0) {\n        return {\n          geometry: geometry\n        };\n      } else {\n        var materials = three_module["Q" /* Loader */].prototype.initMaterials(json.materials, this.resourcePath || path, this.crossOrigin);\n        return {\n          geometry: geometry,\n          materials: materials\n        };\n      }\n    };\n  }()\n});\n/* harmony default export */ var entities_LegacyJSONLoader = (LegacyJSONLoader);\n// CONCATENATED MODULE: ./client/app/engine/graphics/entities/entities.js\n/**\n *\n */\n\n\n\n\nvar EntitiesModule = {\n  loadMeshFromJSON: function loadMeshFromJSON(model, callback, errorCallback) {\n    var loader = new entities_LegacyJSONLoader();\n    loader.load("app/assets/models/".concat(model, ".json"), function (geometry) {\n      callback(geometry);\n    }, undefined, function (error) {\n      console.log(error);\n      errorCallback();\n    });\n  },\n  loadReferenceGeometryFromMemory: function loadReferenceGeometryFromMemory(id) {\n    if (!this.referenceMeshes.has(id)) {\n      console.error("[Graphics/Meshes] Could not charge a new \\"".concat(id, "\\" mesh."));\n      return;\n    } // Beware! tis a geometry.\n\n\n    var geometry = this.referenceMeshes.get(id);\n    if (!(geometry instanceof three_module["A" /* Geometry */])) console.warn(\'[Graphics/Entities] Should be an instance of Geometry.\');\n    return geometry;\n  },\n  initializeEntity: function initializeEntity(entityId, model, color) {\n    var mixers = this.mixers;\n    var times = this.times; // XXX [ANIMATION] export model to format glTF\n\n    var geometry = this.loadReferenceGeometryFromMemory(model); // Should be \'steve\'.\n\n    var bufferGeometry = new three_module["k" /* BufferGeometry */]().fromGeometry(geometry);\n    var mesh = new three_module["W" /* Mesh */](bufferGeometry, new three_module["Z" /* MeshLambertMaterial */]({\n      color: color,\n      vertexColors: three_module["x" /* FaceColors */],\n      morphTargets: true\n    }));\n    mesh.scale.set(1.0, 1.0, 1.0); // mesh.castShadow = true;\n\n    var mixer = new three_module["e" /* AnimationMixer */](mesh);\n    var clip = three_module["d" /* AnimationClip */].CreateFromMorphTargetSequence(\'run\', geometry.morphTargets, 30, false);\n    mixer.clipAction(clip).setDuration(1).play();\n    mixers.set(entityId, mixer);\n    times.set(entityId, Date.now());\n    return mesh;\n  },\n  // For composite entities, wrap heavy model parts in higher level structure.\n  finalizeEntity: function finalizeEntity(id, createdEntity, color) {\n    // First only manage avatars.\n    var up = new three_module["kb" /* Object3D */]();\n    var wrapper = new three_module["kb" /* Object3D */]();\n    var head = this.createMesh(this.createGeometry(\'box\'), this.createMaterial(\'flat-phong\', {\n      color: color\n    })); // head.castShadow = true;\n\n    up.rotation.reorder(\'ZYX\');\n    up.add(wrapper);\n    wrapper.add(createdEntity); // Body.\n\n    wrapper.add(head);\n    head.position.y = 1.6;\n    wrapper.rotation.x = Math.PI / 2;\n    wrapper.rotation.y = Math.PI;\n    wrapper.position.z = -0.7999;\n    up._id = id; //delete createdEntity._id;\n\n    up.getWrapper = function () {\n      return wrapper;\n    };\n\n    up.getHead = function () {\n      return head;\n    }; //return wrapper;\n\n\n    return up;\n  }\n};\n\n// EXTERNAL MODULE: ./node_modules/three/examples/jsm/loaders/GLTFLoader.js\nvar GLTFLoader = __webpack_require__(39);\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/entities/items.js\n\n\n\n\nvar ItemsGraphicsModule = {\n  loadItems: function loadItems(callback) {\n    this.loadItemMesh(\'portal-gun\', callback);\n  },\n  loadItemMesh: function loadItemMesh(modelPath, callback, errorCallback) {\n    var _this = this;\n\n    if (modelPath !== \'portal-gun\' && modelPath !== \'yumi-morph\' && modelPath !== \'yari\' && modelPath !== \'ya\' && modelPath !== \'nagamaki\' && modelPath !== \'naginata\' && modelPath !== \'nodachi\' && modelPath !== \'katana\') {\n      console.error(\'[Graphics/Items] Unsupported mesh.\');\n      return;\n    }\n\n    var loader = new GLTFLoader["a" /* GLTFLoader */]();\n    loader.load("app/assets/models/".concat(modelPath, ".glb"), function (gltf) {\n      if (modelPath === \'portal-gun\') _this.finalizePortalMesh(gltf, callback);else if (modelPath === \'katana\') _this.finalizeKatanaPackMesh(gltf, callback);else if (modelPath === \'ya\') _this.finalizeYaPackMesh(gltf, callback);else if (modelPath === \'yumi-morph\') _this.finalizeYumiMorphPackMesh(gltf, callback);else if (modelPath === \'yari\') _this.finalizeYariPackMesh(gltf, callback);else if (modelPath === \'nagamaki\') _this.finalizeNagamakiPackMesh(gltf, callback);else if (modelPath === \'naginata\') _this.finalizeNaginataPackMesh(gltf, callback);else if (modelPath === \'nodachi\') _this.finalizeNodachiPackMesh(gltf, callback);\n    }, undefined, function (error) {\n      if (errorCallback) errorCallback();\n      console.error(error);\n    });\n  },\n  finalizeYumiMorphPackMesh: function finalizeYumiMorphPackMesh(gltf, callback) {\n    var object = gltf.scene.children[0];\n\n    this._resetMaterial(object, true); // Read animation\n\n\n    object.material.morphTargets = true;\n    var mixer = new three_module["e" /* AnimationMixer */](object);\n    var clip = new three_module["d" /* AnimationClip */](\'bow-stretch\', 1, gltf.animations[0].tracks); // console.log(clip);\n\n    var action = mixer.clipAction(clip);\n    action.clampWhenFinished = true;\n    action.setDuration(1).setLoop(three_module["S" /* LoopRepeat */], 1).play();\n    this.mixers.set(\'yumi\', mixer);\n    this.times.set(\'yumi\', Date.now());\n    this.clips.set(\'yumi\', action); // Color mesh\n\n    var g = object.geometry;\n    var p = g.attributes.position;\n    var count = p.count;\n    g.setAttribute(\'color\', new three_module["j" /* BufferAttribute */](new Float32Array(count * 3), 3));\n    var colors = g.attributes.color;\n\n    for (var i = 0; i < count; ++i) {\n      var x = void 0;\n      var y = void 0;\n      var z = void 0;\n      var yCoord = p.getY(i);\n\n      if (Math.abs(yCoord - 5.85) < .3 || Math.abs(yCoord - 2.46) < .1 || Math.abs(yCoord - 8) < .1) {\n        x = y = z = 2.0;\n      } else {\n        x = 2 * 61 / 256;\n        y = 2 * 31 / 256;\n        z = 0;\n      }\n\n      colors.setXYZ(i, x, y, z);\n    }\n\n    object.rotation.reorder(\'ZXY\');\n    var sc = object.scale;\n    var f = 0.2;\n    sc.set(f * sc.x, f * sc.y, f * sc.z);\n    object.rotation.set(-Math.PI / 2, Math.PI / 2, Math.PI / 2);\n    object.position.set(0.3, -.15, -0.25);\n    this.renderOnTop(object);\n    var wrapper = new three_module["kb" /* Object3D */]();\n    wrapper.rotation.reorder(\'ZYX\');\n    wrapper.add(object);\n    callback(wrapper);\n  },\n  finalizeYaPackMesh: function finalizeYaPackMesh(gltf, callback) {\n    var object = gltf.scene.children[0];\n\n    this._resetMaterial(object);\n\n    var g = object.geometry;\n    var p = g.attributes.position;\n    var count = p.count;\n    g.setAttribute(\'color\', new three_module["j" /* BufferAttribute */](new Float32Array(count * 3), 3));\n    var colors = g.attributes.color;\n\n    for (var i = 0; i < count; ++i) {\n      var x = void 0;\n      var y = void 0;\n      var z = void 0;\n      var xCoord = p.getX(i);\n      var yCoord = p.getY(i);\n\n      if (xCoord < -15.4) {\n        x = y = z = 1.0;\n      } else if (xCoord > -3 && Math.abs(yCoord) > 0.02) {\n        x = y = z = 2.0;\n      } else {\n        x = 61 / 256;\n        y = 31 / 256;\n        z = 0;\n      }\n\n      colors.setXYZ(i, x, y, z);\n    }\n\n    var sc = object.scale;\n\n    var wrapper = this._packObject(object);\n\n    var f = 6;\n    sc.set(f * sc.x, f * sc.y, f * sc.z);\n    object.position.set(0, -1.5, 0);\n    callback(wrapper);\n  },\n  _resetMaterial: function _resetMaterial(object, opaque) {\n    object.material = new three_module["bb" /* MeshPhongMaterial */]({\n      color: 0x707070,\n      shininess: opaque ? 0 : 1000,\n      specular: opaque ? 0x000000 : 0xffffff,\n      vertexColors: true\n    });\n    var g = object.geometry;\n    var count = g.attributes.position.count;\n    g.setAttribute(\'color\', new three_module["j" /* BufferAttribute */](new Float32Array(count * 3), 3));\n  },\n  _packObject: function _packObject(object) {\n    // Think about setting roughness\n    object.rotation.reorder(\'ZYX\');\n    var sc = object.scale;\n    var f = 0.4;\n    sc.set(f * sc.x, f * sc.y, f * sc.z);\n    object.rotation.set(Math.PI + 5.0 * Math.PI / 8, 0, -Math.PI / 2);\n    object.position.set(0.4, -.25, -0.25);\n    var wrapper = new three_module["kb" /* Object3D */]();\n    wrapper.rotation.reorder(\'ZYX\');\n    wrapper.add(object);\n    return wrapper;\n  },\n  finalizeKatanaTypePackMesh: function finalizeKatanaTypePackMesh(gltf, handleTop, handleR, handleG, handleB, ringTop, ringLeft, ringRight, ringR, ringG, ringB, callback) {\n    var object = gltf.scene.children[0];\n\n    this._resetMaterial(object);\n\n    var g = object.geometry;\n    var p = g.attributes.position;\n    var count = p.count;\n    var colors = g.attributes.color;\n\n    for (var i = 0; i < count; ++i) {\n      var x = void 0;\n      var y = void 0;\n      var z = void 0;\n      var xCoord = p.getX(i);\n      var yCoord = p.getY(i);\n      var zCoord = p.getZ(i);\n\n      if (xCoord < ringTop) {\n        x = 0.5 + 0.5 * Math.random();\n        y = 0.5 + 0.5 * Math.random();\n        z = 0.5 + 0.5 * Math.random();\n      } else if (xCoord > handleTop && Math.abs(zCoord) < ringLeft && Math.abs(yCoord) < ringRight) {\n        x = handleR / 256;\n        y = handleG / 256;\n        z = handleB;\n      } else {\n        x = ringR / 256;\n        y = ringG / 256;\n        z = ringB;\n      }\n\n      colors.setXYZ(i, x, y, z);\n    }\n\n    var wrapper = this._packObject(object);\n\n    callback(wrapper);\n  },\n  finalizeYariPackMesh: function finalizeYariPackMesh(gltf, callback) {\n    this.finalizeKatanaTypePackMesh(gltf, -9.7, 61, 31, 0, -15.7, 0.7, 0.05, 255, 215, 0, callback);\n  },\n  finalizeNodachiPackMesh: function finalizeNodachiPackMesh(gltf, callback) {\n    this.finalizeKatanaTypePackMesh(gltf, -1.3, 61, 31, 0, -1.975, 0.7, 0.05, 255, 215, 0, callback);\n  },\n  finalizeNaginataPackMesh: function finalizeNaginataPackMesh(gltf, callback) {\n    this.finalizeKatanaTypePackMesh(gltf, -7.8, 61, 31, 0, -8.47, 0.7, 0.07, 255, 215, 0, callback);\n  },\n  finalizeNagamakiPackMesh: function finalizeNagamakiPackMesh(gltf, callback) {\n    this.finalizeKatanaTypePackMesh(gltf, -2.4, 61, 31, 0, -3.052, 0.7, 0.09, 255, 215, 0, callback);\n  },\n  finalizeKatanaPackMesh: function finalizeKatanaPackMesh(gltf, callback) {\n    this.finalizeKatanaTypePackMesh(gltf, -1.3, 0, 0, 0, -1.975, 0.7, 0.09, 255, 215, 0, callback);\n  },\n\n  /**\n   * @deprecated\n   */\n  finalizeKatanaMesh: function finalizeKatanaMesh(gltf, callback) {\n    var object = gltf.scene.children[0];\n    console.log(object); // let m = object.material.map;\n    // let newMat = new MeshBasicMaterial({\n    //     color: new Color(4, 4, 4), map: m});\n    // object.material = newMat;\n\n    object.children[0].material.roughness = 1.0; //; 0.3;\n\n    object.children[0].material.metalness = 0.5; // 0.5;\n\n    object.children[0].material.color = new three_module["n" /* Color */](0xffffff); // object.children[0].material.side = BackSide;\n\n    var width = 128;\n    var height = 128;\n    var size = width * height;\n    var data = new Uint8Array(3 * size);\n\n    for (var i = 0; i < size; ++i) {\n      var stride = i * 3; // let r = i < size / 2 ? 255 : Math.random() * 255;\n\n      var r = Math.random() > 0.5 ? 255 : 0;\n      data[stride] = r;\n      data[stride + 1] = r;\n      data[stride + 2] = r;\n    }\n\n    var tex = new three_module["p" /* DataTexture */](data, width, height, three_module["zb" /* RGBFormat */]);\n    tex.wrapT = three_module["Bb" /* RepeatWrapping */];\n    tex.wrapS = three_module["Bb" /* RepeatWrapping */];\n    tex.repeat.set(9, 1);\n    object.children[0].material.roughnessMap = tex; // object.children[0].material.metalnessMap = tex;\n    // object.children[0].material.map = tex;\n\n    object.children[0].material.needsUpdate = true;\n    var g = object.children[0].geometry; // g.faceVertexUvs = [[]];\n\n    var uvs = new Float32Array(72 * 2);\n\n    for (var _i = 0; _i < 72; ++_i) {\n      // 8 faces\n      uvs.set([Math.random(), Math.random()], _i);\n    }\n\n    g.setAttribute(\'uv\', new three_module["j" /* BufferAttribute */](uvs, 2));\n    g.attributes.uv.needsUpdate = true;\n    g.uvsNeedUpdate = true;\n    g.needsUpdate = true; // Think about setting roughness\n\n    object.scale.set(0.08, 0.08, 0.08); // object.rotation.set(0, Math.PI / 4, 0);\n\n    object.position.set(0.4, -.25, -0.25);\n    var wrapper = new three_module["kb" /* Object3D */]();\n    wrapper.rotation.reorder(\'ZYX\');\n    wrapper.add(object);\n    callback(wrapper);\n  },\n  // [OPT] make it a single mesh\n  finalizePortalMesh: function finalizePortalMesh(gltf, callback) {\n    var object = gltf.scene.children[0]; // portal gun\n\n    object.scale.set(0.08, 0.08, 0.08);\n    object.rotation.set(0, Math.PI, 0); // object.rotation.reorder(\'ZYX\');\n\n    object.position.set(0.3, -.1, -0.5);\n    var c1 = object.children[0];\n    c1.material = new three_module["bb" /* MeshPhongMaterial */]({\n      color: 0x000000\n    });\n    var c2 = object.children[1];\n    c2.material = new three_module["bb" /* MeshPhongMaterial */]({\n      color: 0x2222aa\n    });\n    var c3 = object.children[2];\n    c3.material = new three_module["bb" /* MeshPhongMaterial */]({\n      color: 0xffffff\n    });\n    var c4 = object.children[3];\n    c4.material = new three_module["bb" /* MeshPhongMaterial */]({\n      color: 0x999999\n    });\n    var wrapper = new three_module["kb" /* Object3D */]();\n    wrapper.rotation.reorder(\'ZYX\');\n    wrapper.add(object);\n    callback(wrapper);\n  },\n  // For composite entities, wrap heavy model parts in higher level structure.\n  finalizeModelMesh: function finalizeModelMesh() {// First ey;\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/entities/animations.js\n/**\n *\n */\n\n\nvar AnimationsModule = {\n  initializeAnimations: function initializeAnimations() {\n    this.mixers = new Map();\n    this.times = new Map();\n    this.clips = new Map();\n  },\n  updateAnimation: function updateAnimation(entityId) {\n    var mixer = this.mixers.get(entityId);\n    var prevTime = this.times.get(entityId);\n\n    if (mixer) {\n      var time = Date.now();\n      mixer.update((time - prevTime) * 0.001);\n      this.times.set(entityId, time);\n    } else {// console.log(\'[Animations] Undefined mixer.\');\n    }\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/portals/screen.js\n/**\n * Screen object (graphical component of a portal).\n */\n\n\n\n\nvar Screen = function Screen(screenId, mesh, renderTarget, worldId) {\n  this.screenId = screenId;\n  this.mesh = mesh;\n  this.renderTarget = renderTarget;\n  this.worldId = worldId;\n  this.otherWorldId = null; // A screen may be rendered with several cameras depending of\n  // the \'multiverse topology\' and position of the player.\n\n  this.cameras = new Set();\n};\n\nextend(Screen.prototype, {\n  getId: function getId() {\n    return this.screenId;\n  },\n  getMesh: function getMesh() {\n    return this.mesh;\n  },\n  getRenderTarget: function getRenderTarget() {\n    return this.renderTarget;\n  },\n  getWorldId: function getWorldId() {\n    return this.worldId;\n  },\n  getOtherWorldId: function getOtherWorldId() {\n    return this.otherWorldId;\n  },\n  setOtherWorldId: function setOtherWorldId(otherWorldId) {\n    this.otherWorldId = otherWorldId;\n  },\n  isLinked: function isLinked() {\n    return this.otherWorldId !== null || this.otherWorldId !== undefined;\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/portals/portals.js\n/**\n * Portal management functions.\n */\n\n\nfunction portals_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { portals_typeof = function _typeof(obj) { return typeof obj; }; } else { portals_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return portals_typeof(obj); }\n\n\n\nvar PortalsModule = {\n  addStubPortalObject: function addStubPortalObject(portal) {\n    var worldId = portal.worldId; // World this portal stands in.\n\n    var portalId = portal.portalId; //console.log(\'Adding stub: p(\' + portalId + \'), w(\' + worldId + \')\');\n    // Get scene.\n\n    var scene = this.getScene(worldId, true); // Force scene manager to create a scene.\n\n    if (!scene) {\n      // Still possible.\n      console.log("Could not load scene from ".concat(worldId, " (").concat(portals_typeof(worldId), ")."));\n      return;\n    } // Create screen.\n\n\n    var screen = this.getScreen(portalId);\n\n    if (!screen) {\n      // console.log(`NEW SCREEN ${portalId}`);\n      // console.log(\'New Screen created.\');\n      var pos = portal.tempPosition;\n      var top = portal.tempOtherPosition; // let tempOffset = portal.tempOffset;\n\n      var tempOrientation = portal.tempOrientation;\n      var portalWidth = portal.tempWidth;\n      var portalHeight = portal.tempHeight;\n      var width = window.innerWidth; // (portalWidth * window.innerWidth) / 2;\n\n      var height = window.innerHeight; // (portalHeight * window.innerHeight) / 2;\n\n      var rtTexture = new three_module["Wb" /* WebGLRenderTarget */](width, height, {\n        minFilter: three_module["N" /* LinearFilter */],\n        magFilter: three_module["fb" /* NearestFilter */],\n        format: three_module["zb" /* RGBFormat */]\n      }); // [REFACTOR] manage geometry creation elsewhere.\n\n      var geometry = new three_module["pb" /* PlaneBufferGeometry */](portalWidth, portalHeight);\n      var portalVShader = this.getPortalVertexShader();\n      var portalFShader = this.getPortalFragmentShader();\n      var material = new three_module["Eb" /* ShaderMaterial */]({\n        side: three_module["t" /* DoubleSide */],\n        uniforms: {\n          texture1: {\n            type: \'t\',\n            value: rtTexture.texture\n          }\n        },\n        vertexShader: portalVShader,\n        fragmentShader: portalFShader\n      });\n      var mesh = new three_module["W" /* Mesh */](geometry, material);\n      var x0 = Math.floor(pos[0]);\n      var y0 = Math.floor(pos[1]);\n      var z0 = Math.floor(pos[2]);\n      var x1 = Math.floor(top[0]);\n      var y1 = Math.floor(top[1]);\n      var z1 = Math.floor(top[2]);\n      var PI2 = Math.PI / 2;\n\n      if (z0 !== z1) {\n        mesh.rotation.x = PI2;\n        mesh.rotation.y = PI2 + parseFloat(tempOrientation);\n        mesh.position.x = pos[0] + 0.5;\n        mesh.position.y = pos[1] + 0.5;\n        mesh.position.z = pos[2] + 1;\n      } else if (y0 !== y1) {\n        mesh.rotation.y = PI2 - parseFloat(tempOrientation);\n        mesh.position.x = pos[0] + 0.5;\n        mesh.position.y = pos[1] + 1;\n        mesh.position.z = pos[2] + 0.5;\n      } else if (x0 !== x1) {\n        mesh.rotation.z = PI2;\n        mesh.position.x = pos[0] + 1;\n        mesh.position.y = pos[1] + 0.5;\n        mesh.position.z = pos[2] + 0.5;\n        mesh.rotation.x = PI2 + parseFloat(tempOrientation);\n      } // mesh.updateMatrixWorld();\n\n\n      screen = new Screen(portalId, mesh, rtTexture, worldId);\n      this.addScreen(portalId, screen);\n    }\n\n    if (screen) {\n      this.addToScene(screen.getMesh(), worldId);\n    }\n  },\n  // portal linked forward to otherPortal\n  completeStubPortalObject: function completeStubPortalObject(portal, otherPortal, cameraPath, cameraTransform) {\n    var worldId = portal.worldId;\n    var portalId = portal.portalId; // let otherEndId = worldId;\n    // if (otherPortal) {\n    //     otherEndId = otherPortal.worldId;\n    // }\n    // Affect linked portal.\n\n    portal.portalLinkedForward = otherPortal.portalId; //console.log(\'Completing stub: p(\' + portalId + \'),\n    // w(\' + worldId + \'), f(\' + otherPortal.portalId + \')\');\n    // Create and configure renderer, camera.\n\n    var screen = this.getScreen(portalId);\n\n    if (!screen) {\n      console.log("Could not get screen to complete: ".concat(portalId, "."));\n      return;\n    } // TODO [PORTAL] implement generic portal functionality\n    // Implementation hints:\n    // - add several times with different paths.\n    // - compute all paths.\n    // - DON\'T ACCOUNT for portals that are too far away!\n    // - that\'s how many camera paths I\'ll have to add until the leaves.\n\n\n    this.cameraManager.addCamera(portal, otherPortal, cameraPath, cameraTransform, screen);\n    this.cameraManager.addCameraToScene(cameraPath, worldId, screen);\n  },\n  processPortalUpdates: function processPortalUpdates() {\n    var portalUpdates = this.portalUpdates;\n    if (portalUpdates.length < 1) return;\n    var u;\n    var hasAddedSomething = false; // check [ALG] Add portal I just crossed first (closest to destinationWid)?\n\n    var addedFirst = [];\n\n    for (var i = 0; i < portalUpdates.length; ++i) {\n      u = portalUpdates[i]; // console.log(`${u.destinationWid}, ${u.portal.worldId}, ${this.previousFrameWorld}`);\n\n      var dwid = parseInt(u.destinationWid, 10);\n      var owid = parseInt(u.portal.worldId, 10);\n      var pwid = parseInt(this.previousFrameWorld, 10);\n      var cwid = parseInt(this.currentFrameWorld, 10);\n\n      if (dwid === pwid || dwid === cwid || owid === pwid || owid === cwid) {\n        // console.log(\'Added \' + this.previousFrameWorld + \', \'\n        // + u.destinationWid);\n        this.addPortalGraphics(u.portal, u.otherPortal, u.cameraPath, u.cameraTransform, u.depth, u.originPid, u.destinationPid, u.destinationWid, u.pidPathString);\n        addedFirst.push(i);\n        hasAddedSomething = true;\n      }\n    }\n\n    for (var j = addedFirst.length - 1; j >= 0; --j) {\n      portalUpdates.splice(addedFirst[j], 1);\n    }\n\n    if (!hasAddedSomething) {\n      u = portalUpdates.shift();\n      this.addPortalGraphics(u.portal, u.otherPortal, u.cameraPath, u.cameraTransform, u.depth, u.originPid, u.destinationPid, u.destinationWid, u.pidPathString);\n    }\n  },\n  flushPortalUpdates: function flushPortalUpdates() {\n    this.portalUpdates = [];\n  },\n  unflushPortalUpdates: function unflushPortalUpdates() {\n    var portalUpdates = this.portalUpdates;\n    var lastRenderPaths = this.lastRenderPaths;\n    var lastRenderGates = this.lastRenderGates; // Remove only screens and cameras that need to be.\n\n    var cameraManager = this.cameraManager;\n    var sceneManager = this.sceneManager;\n    var rp = new Set();\n    var rg = new Set();\n\n    for (var i = 0, l = portalUpdates.length; i < l; ++i) {\n      var currentUpdate = portalUpdates[i];\n      rp.add(currentUpdate.pidPathString);\n      rg.add(currentUpdate.originPid);\n    }\n\n    lastRenderPaths.forEach(function (path) {\n      if (!rp.has(path)) cameraManager.removeCameraFromScene(path);\n    });\n    lastRenderGates.forEach(function (gate) {\n      if (!rg.has(gate)) sceneManager.removeScreen(gate);\n    }); // Flush render targets.\n\n    this.rendererManager.setRenderRegister([]);\n    this.lastRenderPaths = new Set();\n    this.lastRenderGates = new Set();\n  },\n  addPortalGraphics: function addPortalGraphics(portal, otherPortal, cameraPath, cameraTransform, depth, originPid, destinationPid, destinationWid, pidPathString) {\n    var renderRegister = this.rendererManager.getRenderRegister();\n\n    for (var i in renderRegister) {\n      if (renderRegister.hasOwnProperty(i) && renderRegister[i].id === pidPathString) return;\n    } // already added.\n\n\n    this.addStubPortalObject(portal);\n    this.completeStubPortalObject(portal, otherPortal, cameraPath, cameraTransform);\n    var screens = this.sceneManager.screens;\n    var cameras = this.cameraManager.subCameras;\n    var scenes = this.sceneManager.subScenes; // For each camera, remember its path.\n    // When rendering is performed,\n    // Every camera shall have to render from its transformed state back to the root.\n    // So reorder rendering phase according to camera depths.\n\n    renderRegister.push({\n      id: pidPathString,\n\n      /*depth: */\n      depth: depth,\n      screen1: screens.get(originPid),\n      screen2: screens.get(destinationPid),\n      sceneId: destinationWid,\n      scene: scenes.get(destinationWid),\n      camera: cameras.get(pidPathString)\n    });\n    this.lastRenderPaths.add(pidPathString);\n    this.lastRenderGates.add(originPid); // Sort in reverse order! (high depth to low depth).\n\n    renderRegister.sort(function (a, b) {\n      return b.depth - a.depth;\n    }); // Update renderer.\n\n    this.rendererManager.setRenderRegister(renderRegister);\n  },\n  addPortalObject: function addPortalObject(portal, otherPortal, cameraPath, cameraTransform, depth, originPid, destinationPid, destinationWid, pidPathString) {\n    this.portalUpdates.push({\n      portal: portal,\n      otherPortal: otherPortal,\n      cameraPath: cameraPath,\n      cameraTransform: cameraTransform,\n      depth: depth,\n      originPid: originPid,\n      destinationPid: destinationPid,\n      destinationWid: destinationWid,\n      pidPathString: pidPathString\n    });\n  },\n  // Remove link between portal (which is still present) and otherPortal\n  // which is to be removed. Portal used to lead to otherPortal.\n  removePartOfPortalObject: function removePartOfPortalObject(portal, otherPortal\n  /*, worldMap*/\n  ) {\n    // let worldId = portal.worldId;\n    // console.log(\'Removing stub: p(\' + portal.portalId + \') -> o(\' + otherPortal.portalId + \')\');\n    // Remove screen and subCameras.\n    var currentPortalId = portal.portalId;\n    var otherPortalId = otherPortal.portalId;\n    var screenToBeRemoved = this.getScreen(otherPortalId);\n    var screenToBeAltered = this.getScreen(currentPortalId); // 1 portal <=> 1 screen\n    // But beware! 1 portal <=> multiple cameras.\n    // Camera paths are necessary for handling redundancy in portal\n    // chains.\n    // Implementation hints:\n    // - a camera must know its full render path.\n    // - search in depth and remove every portal in the chain.\n    // - remove screen otherWorldId\n    // - remove in-depth subCameras.\n    // - remove backwards variable\n\n    if (!screenToBeAltered) {\n      console.log(\'WARN @portals.js: screen to be altered not found.\');\n    } else {\n      screenToBeAltered.setOtherWorldId(null); // Tweak to prevent weird stuff when a portal camera has been unloaded but\n      // the rendered texture is still displaying the last rendered frame.\n\n      screenToBeAltered.getRenderTarget().setSize(0, 0);\n    }\n\n    if (!screenToBeRemoved) {\n      console.log(\'WARN @portals.js: screen to be removed not found.\');\n    } else {//this.removeScreen(screenToBeRemoved.screenId);\n    }\n  },\n  // Remove the aforementioned portal.\n  // TODO [PORTAL] manage portal removal\n  removePortalObject: function removePortalObject(portal) //, worldMap\n  {\n    // let worldId = portal.worldId;\n    var currentPortalId = portal.portalId;\n    console.log("Removing full portal: p(".concat(portal.portalId, ")")); // Search in depth and remove every portal in the chain.\n    // 1 screen <-> 1 portal\n\n    var screenToBeRemoved = this.getScreen(currentPortalId);\n    this.removeScreen(screenToBeRemoved.screenId);\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/render/camera.js\n/**\n * Camera wrapper.\n */\n\n\n\n\n\nvar camera_Camera = function Camera(fov, aspect, nearPlane, farPlane, worldId) {\n  // Wrap for primitive manipulation simplicity.\n  var camera = new three_module["nb" /* PerspectiveCamera */](fov, aspect, nearPlane, farPlane);\n  camera.position.set(0, 0, 0);\n  camera.rotation.set(0, 0, 0);\n  var pitch = new three_module["kb" /* Object3D */]();\n  var yaw = new three_module["kb" /* Object3D */]();\n  var up = new three_module["kb" /* Object3D */]();\n  pitch.add(camera);\n  yaw.add(pitch);\n  up.add(yaw);\n  up.rotation.reorder(\'ZYX\'); // 4D logic\n\n  this.worldId = worldId;\n  this.cameraId = null;\n  this.cameraTransform = [0, 0, 0, // Pos transform\n  0, 0, 0 // Rot transform\n  ]; // Don\'t expose these internal variables.\n\n  this.up = up; // 3D \'gravity\' constraint (full rotation)\n\n  this.yaw = yaw; // Top-level    (rotation.z, position)\n\n  this.pitch = pitch; // Intermediate (rotation.x)\n\n  this.cameraObject = camera; // Explicit     (constant)\n\n  this.screen = null;\n};\n\nextend(camera_Camera.prototype, {\n  setCameraId: function setCameraId(cameraId) {\n    this.cameraId = cameraId;\n  },\n  getCameraId: function getCameraId() {\n    return this.cameraId;\n  },\n  setWorldId: function setWorldId(worldId) {\n    this.worldId = worldId;\n  },\n  getWorldId: function getWorldId() {\n    return this.worldId;\n  },\n  getRecorder: function getRecorder() {\n    return this.cameraObject;\n  },\n  get3DObject: function get3DObject() {\n    return this.up;\n  },\n  getCameraPosition: function getCameraPosition() {\n    return this.up.position;\n  },\n  getUpRotation: function getUpRotation() {\n    return this.up.rotation;\n  },\n  rotateX: function rotateX(deltaX) {\n    var pitch = this.pitch;\n    pitch.rotation.x += deltaX;\n    pitch.rotation.x = Math.max(0, Math.min(Math.PI, pitch.rotation.x));\n  },\n  rotateZ: function rotateZ(deltaZ) {\n    var yaw = this.yaw;\n    yaw.rotation.z += deltaZ;\n  },\n  setUpRotation: function setUpRotation(x, y, z) {\n    // TODO [PORTAL] use local transform\n    var up = this.up;\n    up.rotation.x = x;\n    up.rotation.y = y;\n    up.rotation.z = z;\n  },\n  getXRotation: function getXRotation() {\n    return this.pitch.rotation.x;\n  },\n  setXRotation: function setXRotation(rotationX) {\n    // TODO [PORTAL] use local transform\n    this.pitch.rotation.x = rotationX;\n  },\n  getZRotation: function getZRotation() {\n    return this.yaw.rotation.z;\n  },\n  setZRotation: function setZRotation(rotationZ) {\n    // TODO [PORTAL] use local transform\n    this.yaw.rotation.z = rotationZ;\n  },\n  copyCameraPosition: function copyCameraPosition(otherCamera) {\n    // TODO [PORTAL] use local transform?\n    if (otherCamera) {\n      var up = this.up.position;\n      var oup = otherCamera.getCameraPosition();\n      up.x = oup.x;\n      up.y = oup.y;\n      up.z = oup.z;\n    }\n  },\n  copyCameraUpRotation: function copyCameraUpRotation(otherCamera) {\n    // TODO [PORTAL] use local transform?\n    if (otherCamera) {\n      var ur = this.up.rotation;\n      var our = otherCamera.getUpRotation();\n      ur.x = our.x;\n      ur.y = our.y;\n      ur.z = our.z;\n    }\n  },\n  addPositionTransform: function addPositionTransform() {\n    var p = this.up.position;\n    var transform = this.cameraTransform;\n    if (!transform) return;\n    p.x += transform[0];\n    p.y += transform[1];\n    p.z += transform[2];\n  },\n  addRotationTransform: function addRotationTransform() {// let rup = this.get3DObject().rotation;\n    // let transform = this.cameraTransform;\n    // if (!transform) return;\n    // rup.x += transform[3];\n  },\n  setCameraPosition: function setCameraPosition(x, y, z) {\n    // TODO [PORTAL] use local transform?\n    var up = this.up;\n    var sin = Math.sin;\n    var cos = Math.cos;\n    var PI = Math.PI;\n    var rup = this.get3DObject().rotation;\n    var theta0 = rup.z + PI;\n    var theta1 = rup.x;\n    var f = 0.7999; // Formula works for 4 out of 6 faces...\n\n    var upVector = [-f * sin(theta1) * sin(theta0), f * sin(theta1) * cos(theta0), f * cos(theta1)];\n    up.position.x = x + upVector[0];\n    up.position.y = y + upVector[1];\n    up.position.z = z + upVector[2];\n  },\n  setScreen: function setScreen(screen) {\n    if (screen) this.screen = screen;\n  },\n  getScreen: function getScreen() {\n    return this.screen; // || (function() {throw Error(\'Screen \' + this.getCameraId + \' undefined\')})();\n  },\n  setCameraTransform: function setCameraTransform(cameraTransform) {\n    this.cameraTransform = cameraTransform;\n  },\n  getCameraTransform: function getCameraTransform() {\n    return this.cameraTransform;\n  },\n  setFirstPerson: function setFirstPerson() {\n    this.cameraObject.position.z = 0;\n  },\n  setThirdPerson: function setThirdPerson() {\n    var p = this.cameraObject.position;\n    p.x = 0;\n    p.y = 0;\n    p.z = 4;\n  },\n  getCameraForwardVector: function getCameraForwardVector() {\n    var nv = new three_module["Sb" /* Vector3 */](0, -1, 0); // nv.normalize();\n\n    var camQ = new three_module["vb" /* Quaternion */]();\n    this.cameraObject.getWorldQuaternion(camQ);\n    nv.applyQuaternion(camQ);\n    return nv;\n  },\n  getModelForwardVector: function getModelForwardVector() {\n    var nv = new three_module["Sb" /* Vector3 */](0, 0, -1);\n    var camQ = new three_module["vb" /* Quaternion */]();\n    this.cameraObject.getWorldQuaternion(camQ);\n    nv.applyQuaternion(camQ);\n    return nv;\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/water/watercamera.js\n\nvar WaterCameraModule = {\n  createWaterCamera: function createWaterCamera() {\n    var fov = this.mainFOV;\n    var aspect = this.mainAspect;\n    var near = this.mainNear;\n    var far = this.mainFar;\n    var waterRenderTarget = new three_module["Wb" /* WebGLRenderTarget */](512, 512, {\n      minFilter: three_module["N" /* LinearFilter */],\n      magFilter: three_module["N" /* LinearFilter */],\n      format: three_module["zb" /* RGBFormat */]\n    });\n    var waterCamObject = new three_module["nb" /* PerspectiveCamera */](fov, aspect, near, far);\n    return {\n      camera: waterCamObject,\n      waterRenderTarget: waterRenderTarget,\n      mirrorPlane: new three_module["ob" /* Plane */](),\n      normal: new three_module["Sb" /* Vector3 */](),\n      mirrorWorldPosition: new three_module["Sb" /* Vector3 */](),\n      cameraWorldPosition: new three_module["Sb" /* Vector3 */](),\n      rotationMatrix: new three_module["V" /* Matrix4 */](),\n      lookAtPosition: new three_module["Sb" /* Vector3 */](0, 0, -1),\n      clipPlane: new three_module["Tb" /* Vector4 */](),\n      view: new three_module["Sb" /* Vector3 */](),\n      target: new three_module["Sb" /* Vector3 */](),\n      q: new three_module["Tb" /* Vector4 */](),\n      textureMatrix: new three_module["V" /* Matrix4 */](),\n      clipBias: 0.01,\n      eye: new three_module["Sb" /* Vector3 */](0, 0, 0) // waterCameraHelper: new CameraHelper(this.waterCamera)\n\n    };\n  },\n  // Set from mirror and clip oblique\n  updateWaterCamera: function updateWaterCamera(camera) {\n    var waterCamera = this.waterCamera;\n    if (!waterCamera) return; // let camera = this.mainCamera.cameraObject;\n\n    var mirrorCamera = waterCamera.camera;\n    var clipBias = waterCamera.clipBias;\n    var mirrorPlane = waterCamera.mirrorPlane;\n    var normal = waterCamera.normal;\n    var mirrorWorldPosition = waterCamera.mirrorWorldPosition;\n    var cameraWorldPosition = waterCamera.cameraWorldPosition;\n    var lookAtPosition = waterCamera.lookAtPosition;\n    var clipPlane = waterCamera.clipPlane;\n    var view = waterCamera.view;\n    var target = waterCamera.target;\n    var q = waterCamera.q;\n    var textureMatrix = waterCamera.textureMatrix;\n    var rotationMatrix = waterCamera.rotationMatrix; // for mirror mesh.\n\n    var eye = waterCamera.eye;\n\n    if (!this._waterCameraObject) {\n      this._waterCameraObject = new three_module["kb" /* Object3D */]();\n\n      this._waterCameraObject.position.set(0, 0, 16);\n\n      this._waterCameraObject.rotation.set(0, 0, 0);\n\n      this._waterCameraObject.updateMatrixWorld();\n    }\n\n    var scope = this._waterCameraObject;\n    mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);\n    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);\n    rotationMatrix.extractRotation(scope.matrixWorld);\n    normal.set(0, 0, 1);\n    normal.applyMatrix4(rotationMatrix);\n    view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away\n\n    if (view.dot(normal) > 0) return;\n    view.reflect(normal).negate();\n    view.add(mirrorWorldPosition);\n    rotationMatrix.extractRotation(camera.matrixWorld);\n    lookAtPosition.set(0, 0, -1);\n    lookAtPosition.applyMatrix4(rotationMatrix);\n    lookAtPosition.add(cameraWorldPosition);\n    target.subVectors(mirrorWorldPosition, lookAtPosition);\n    target.reflect(normal).negate();\n    target.add(mirrorWorldPosition);\n    mirrorCamera.position.copy(view);\n    mirrorCamera.up.set(0, 1, 0);\n    mirrorCamera.up.applyMatrix4(rotationMatrix);\n    mirrorCamera.up.reflect(normal);\n    mirrorCamera.lookAt(target);\n    mirrorCamera.far = camera.far; // Used in WebGLBackground\n\n    mirrorCamera.updateMatrixWorld();\n    mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update texture matrix\n\n    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n    textureMatrix.multiply(mirrorCamera.projectionMatrix);\n    textureMatrix.multiply(mirrorCamera.matrixWorldInverse); // Oblique clip\n\n    mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);\n    mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n    clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);\n    var projectionMatrix = mirrorCamera.projectionMatrix;\n    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Scale plane vector\n\n    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replace third row\n\n    projectionMatrix.elements[2] = clipPlane.x;\n    projectionMatrix.elements[6] = clipPlane.y;\n    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;\n    projectionMatrix.elements[14] = clipPlane.w; // Sunlight\n\n    eye.setFromMatrixPosition(camera.matrixWorld);\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/render/cameras.js\n/**\n * Camera management.\n */\n\n\n\n\n\n\nvar DEFAULT_CAMERA = {\n  fov: 90,\n  aspect: window.innerWidth / window.innerHeight,\n  near: 0.0001,\n  far: 100000\n};\n\nvar cameras_CameraManager = function CameraManager(graphicsEngine) {\n  this.graphicsEngine = graphicsEngine; // Camera properties.\n\n  this.mainFOV = DEFAULT_CAMERA.fov;\n  this.mainAspect = window.innerWidth / window.innerHeight;\n  this.mainNear = DEFAULT_CAMERA.near;\n  this.mainFar = DEFAULT_CAMERA.far; // Cameras.\n\n  this.mainCamera = this.createCamera(false, -1);\n  this.mainCamera.setCameraId(-1); // Raycast with different near plane\n\n  this.mainRaycasterCamera = this.createCamera(true, -1);\n  this.raycaster = this.createRaycaster(); // Portals\n\n  this.subCameras = new Map();\n  this.stencilCamera = new three_module["nb" /* PerspectiveCamera */](this.mainFOV, this.mainAspect, this.mainNear, this.mainFar);\n  this.stencilCamera.matrixAutoUpdate = false; // Water\n\n  this.waterCamera = this.createWaterCamera(); // Optimization\n\n  this.incomingRotationEvents = [];\n  this.oldTheta0 = 0;\n  this.oldTheta1 = 0;\n}; // Factory.\n\n\nextend(cameras_CameraManager.prototype, {\n  createCamera: function createCamera(forRaycaster, worldId) {\n    // Resize (when window is resized on hub, portals are not affected)\n    this.mainAspect = window.innerWidth / window.innerHeight;\n    return new camera_Camera(this.mainFOV, this.mainAspect, forRaycaster ? 1 : this.mainNear, this.mainFar, worldId);\n  },\n  addCamera: function addCamera(frameSource, frameDestination, cameraPath, cameraTransform, screen) {\n    var cameraId = cameraPath;\n\n    if (this.subCameras.has(cameraId)) {\n      // console.log(\'[CameraManager] Skipping camera addition.\');\n      // This happens quite often.\n      return;\n    }\n\n    var mainCamera = this.mainCamera;\n    var camera = this.createCamera(false);\n    camera.setCameraId(cameraId);\n    camera.setCameraTransform(cameraTransform);\n    if (screen) camera.setScreen(screen);\n    this.subCameras.set(cameraId, camera); // TODO [PORTAL] manage rotation and position transform from path\n\n    camera.copyCameraPosition(mainCamera);\n    camera.copyCameraUpRotation(mainCamera);\n    camera.setZRotation(mainCamera.getZRotation());\n    camera.setXRotation(mainCamera.getXRotation());\n  },\n  addCameraToScene: function addCameraToScene(cameraId, worldId, screen) {\n    worldId = parseInt(worldId, 10);\n    var camera = this.subCameras.get(cameraId);\n    if (!camera && cameraId === this.mainCamera.getCameraId()) camera = this.mainCamera;\n\n    if (!camera) {\n      console.log("@addCamera: could not get wrapper for camera ".concat(cameraId));\n      return;\n    }\n\n    camera.setWorldId(worldId);\n    if (screen) camera.setScreen(screen);\n    this.graphicsEngine.addToScene(camera.get3DObject(), worldId);\n    camera.getRecorder().updateProjectionMatrix();\n    camera.getRecorder().updateMatrixWorld();\n    camera.getRecorder().matrixWorldInverse.getInverse(camera.getRecorder().matrixWorld); // console.log(`Successfully added side camera to scene ${worldId}`);\n  },\n  removeCameraFromScene: function removeCameraFromScene(cameraId, worldId) {\n    worldId = parseInt(worldId, 10);\n    var camera = this.subCameras.get(cameraId);\n    if (!camera && cameraId === this.mainCamera.getCameraId()) camera = this.mainCamera;\n\n    if (!camera) {\n      console.log("@removeCamera: could not get wrapper for camera ".concat(cameraId, "."));\n      return;\n    }\n\n    if (!worldId) worldId = camera.getWorldId();\n    this.graphicsEngine.removeFromScene(camera.get3DObject(), worldId, true);\n  },\n  switchMainCameraToWorld: function switchMainCameraToWorld(oldMainSceneId, sceneId) {\n    var mainCamera = this.mainCamera;\n    var mainRaycasterCamera = this.mainRaycasterCamera;\n    var graphics = this.graphicsEngine;\n    graphics.removeFromScene(mainCamera.get3DObject(), oldMainSceneId);\n    graphics.removeFromScene(mainRaycasterCamera.get3DObject(), oldMainSceneId);\n    graphics.addToScene(mainCamera.get3DObject(), sceneId);\n    graphics.addToScene(mainRaycasterCamera.get3DObject(), sceneId);\n  },\n\n  /** @deprecated */\n  switchToCamera: function switchToCamera(oldWorldId, newWorldId) {\n    console.log("Deprecated call to switchToCamera ".concat(newWorldId, "."));\n  },\n  // Update.\n  updateCameraPosition: function updateCameraPosition(vector) {\n    var sin = Math.sin;\n    var cos = Math.cos; // let PI = Math.PI;\n\n    var cams = [this.mainCamera, this.mainRaycasterCamera];\n    this.subCameras.forEach(function (cam) {\n      cams.push(cam);\n    });\n    var localRecorder = this.mainCamera.getRecorder();\n    var i = this.graphicsEngine.getCameraInteraction(); // XXX [PERF] switch to quaternion (also server-side)\n\n    var up = this.mainCamera.get3DObject().rotation;\n    var theta0 = up.z;\n    var theta1 = up.x;\n    var f = 0; // 1.6;\n\n    var upVector = [f * sin(theta1) * cos(theta0), // theta0 - PI / 2),\n    f * sin(theta1) * sin(theta0), // theta0 - PI / 2),\n    f * cos(theta1)];\n    var x = vector.x + upVector[0];\n    var y = vector.y + upVector[1];\n    var z = vector.z + upVector[2]; // let x = vector[0];\n    // let y = vector[1];\n    // let z = vector[2] + 1.6;\n    //let z = vector[2];\n\n    if (i.isFirstPerson()) {\n      cams.forEach(function (cam\n      /*, cameraId*/\n      ) {\n        // TODO [PORTAL] update differently from portal transforms.\n        cam.setCameraPosition(x, y, z);\n        cam.setFirstPerson();\n        cam.addPositionTransform();\n        var mirrorCamera = cam.getRecorder();\n\n        if (mirrorCamera) {\n          var screen = cam.getScreen();\n\n          if (screen) {\n            var mirror = screen.getMesh();\n            this.clipOblique(mirror, mirrorCamera, localRecorder);\n          }\n        }\n      }.bind(this));\n    } else if (i.isThirdPerson()) {\n      cams.forEach(function (cam\n      /*, cameraId*/\n      ) {\n        cam.setCameraPosition(x, y, z);\n        cam.setThirdPerson();\n        cam.addPositionTransform();\n        var mirrorCamera = cam.getRecorder();\n\n        if (mirrorCamera) {\n          var screen = cam.getScreen();\n\n          if (screen) {\n            var mirror = screen.getMesh();\n            this.clipOblique(mirror, mirrorCamera, localRecorder);\n          }\n        }\n      }.bind(this));\n    }\n  },\n  addCameraRotationEvent: function addCameraRotationEvent(relX, relY, absX, absY) {\n    this.incomingRotationEvents.push([relX, relY, absX, absY]);\n  },\n  refresh: function refresh() {\n    var incoming = this.incomingRotationEvents;\n    if (incoming.length < 1) return;\n    var rotation = [0, 0, 0, 0];\n    var acc = [0, 0, 0, 0];\n\n    for (var i = 0, l = incoming.length; i < l; ++i) {\n      var inc = incoming[i];\n      acc[0] += inc[0];\n      acc[1] += inc[1];\n      acc[2] += inc[2];\n      acc[3] += inc[3];\n    } // console.log(incoming.length);\n\n\n    var rot = [0, 0, 0, 0];\n    rot = this.moveCameraFromMouse(acc[0], acc[1], acc[2], acc[3]);\n    rotation[0] = rot[0];\n    rotation[1] = rot[1];\n    rotation[2] = rot[2];\n    rotation[3] = rot[3];\n    this.incomingRotationEvents = []; // Here we could perform additional filtering\n\n    if (rotation) {\n      // console.log(`\n      //     ${rotation[0].toFixed(4)},\n      //     ${rotation[1].toFixed(4)};\n      //     ${rotation[2].toFixed(4)},\n      //     ${rotation[3].toFixed(4)}\n      // `);\n      var clientModel = this.graphicsEngine.app.model.client;\n      clientModel.triggerEvent(\'r\', rotation);\n    }\n  },\n  clipOblique: function clipOblique(mirror, mirrorCamera, localRecorder) {\n    var matrix = new three_module["V" /* Matrix4 */]();\n    matrix.extractRotation(mirror.matrix); // Reversal criterion: vector(pos(x)-pos(cam)) dot vector(x normal)\n    // x normal\n\n    var vec1 = new three_module["Sb" /* Vector3 */](0, 0, 1);\n    vec1.applyMatrix4(matrix); // pos(x)-pos(camera)\n\n    var posX = mirror.position; //let  = localRecorder.position;\n\n    var posC = new three_module["Sb" /* Vector3 */]();\n    posC.setFromMatrixPosition(localRecorder.matrixWorld);\n    var vec2 = new three_module["Sb" /* Vector3 */]();\n    vec2.x = posX.x - posC.x;\n    vec2.y = posX.y - posC.y;\n    vec2.z = posX.z - posC.z; // mirrorCamera.getWorldDirection(vec2);\n    //let camPosition = new Vector3();\n    //camPosition.setFromMatrixPosition(mirrorCamera.matrixWorld);\n    //let vec1 = mirror.normal;\n    //let vec2 = new Vector3(0,0, -1);\n    //vec2.applyQuaternion(mirrorCamera.quaternion);\n    //let vec2 = new Vector3(mirrorCamera.matrix[8], mirrorCamera.matrix[9], mirrorCamera.matrix[10]);\n\n    if (!vec1 || !vec2) {\n      console.log(\'[XCam] Dot product error.\');\n      return;\n    } //let dot = mirror.position.dot(camPosition);\n\n\n    var dot = vec1.dot(vec2);\n    var s = Math.sign(dot); //console.log(s);\n    //console.log(dot);\n\n    var normalFactor = 1; // [Expert] replace with -1 to invert normal.\n\n    var N = new three_module["Sb" /* Vector3 */](0, 0, s * normalFactor);\n    N.applyMatrix4(matrix); //update mirrorCamera matrices!!\n    //mirrorCamera.\n\n    mirrorCamera.updateProjectionMatrix();\n    mirrorCamera.updateMatrixWorld();\n    mirrorCamera.matrixWorldInverse.getInverse(mirrorCamera.matrixWorld); // now update projection matrix with new clip plane\n    // implementing code from: http://www.terathon.com/code/oblique.html\n    // paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\n    var clipPlane = new three_module["ob" /* Plane */]();\n    clipPlane.setFromNormalAndCoplanarPoint(N, mirror.position);\n    clipPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);\n    clipPlane = new three_module["Tb" /* Vector4 */](clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\n    var q = new three_module["Tb" /* Vector4 */]();\n    var projectionMatrix = mirrorCamera.projectionMatrix;\n    var sgn = Math.sign;\n    q.x = (sgn(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\n    q.y = (sgn(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\n    q.z = -1.0;\n    q.w = (1.0 + projectionMatrix.elements[10]) / mirrorCamera.projectionMatrix.elements[14]; // Calculate the scaled plane vector\n\n    var c = new three_module["Tb" /* Vector4 */]();\n    c = clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replace the third row of the projection matrix\n\n    projectionMatrix.elements[2] = c.x;\n    projectionMatrix.elements[6] = c.y;\n    projectionMatrix.elements[10] = c.z + 1.0;\n    projectionMatrix.elements[14] = c.w;\n  },\n  setAbsRotationFromServer: function setAbsRotationFromServer(theta0, theta1) {\n    if (this.oldTheta1 === theta1 && this.oldTheta0 === theta0) return false;\n    this.setAbsRotation(theta0, theta1);\n    this.oldTheta0 = theta0;\n    this.oldTheta1 = theta1;\n    return true;\n  },\n  setAbsRotation: function setAbsRotation(theta0, theta1) {\n    var camera = this.mainCamera;\n    var raycasterCamera = this.mainRaycasterCamera;\n    theta1 = Math.max(0, Math.min(Math.PI, theta1)); // | this line is unsafe\n    // V\n\n    camera.setUpRotation(theta1, 0, theta0); // because the camera rotation has changed since the last update,\n    // therefore the new angle set here is outdated\n    // resulting in camera jitters whenever this is called\n    // (for variable gravity or on the edge of 3D worlds)\n    // Solution: client-wise gravity computation (milestone).\n\n    raycasterCamera.setUpRotation(theta1, 0, theta0);\n  },\n  setRelRotation: function setRelRotation(theta0, theta1) {\n    var camera = this.mainCamera;\n    var raycasterCamera = this.mainRaycasterCamera; // let rotationZ = camera.getZRotation();\n    // let rotationX = camera.getXRotation();\n\n    raycasterCamera.setZRotation(theta0);\n    raycasterCamera.setXRotation(theta1);\n    camera.setZRotation(theta0);\n    camera.setXRotation(theta1);\n  },\n  moveCameraFromMouse: function moveCameraFromMouse(relX, relY, absX, absY) {\n    // Rotate main camera.\n    var camera = this.mainCamera;\n    camera.rotateZ(-relX * 0.002);\n    camera.rotateX(-relY * 0.002);\n    var rotationZ = camera.getZRotation();\n    var rotationX = camera.getXRotation(); // Current up vector -> angles.\n\n    var up = camera.get3DObject().rotation;\n    var theta0 = up.z;\n    var theta1 = up.x; // Rotate raycaster camera.\n\n    var raycasterCamera = this.mainRaycasterCamera;\n    raycasterCamera.setZRotation(rotationZ);\n    raycasterCamera.setXRotation(rotationX);\n\n    if (absX !== 0 || absY !== 0) {\n      // Add angles.\n      this.setAbsRotation(theta0 + absX, theta1 + absY); // theta0 = theta0 + absX;\n      // theta1 = Math.max(0, Math.min(Math.PI, theta1 + absY));\n      // camera.setUpRotation(theta1, 0, theta0);\n      // raycasterCamera.setUpRotation(theta1, 0, theta0);\n    } // Apply transform to portals.\n\n\n    this.updateCameraPortals(camera, rotationZ, rotationX, theta1, theta0); // Apply transform to local model.\n\n    this.graphicsEngine.app.model.server.selfModel.cameraMoved(this.mainCamera); // drunken controls: tmpQuaternion.set(- movementY * 0.002, - movementX * 0.002, 0, 1).normalize();\n    // camera.quaternion.multiply(tmpQuaternion);\n    // camera.rotation.setFromQuaternion(camera.quaternion, camera.rotation.order);\n\n    return [rotationZ, rotationX, theta0, theta1];\n  },\n  updateCameraPortals: function updateCameraPortals(camera, rotationZ, rotationX, theta1, theta0) {\n    var localRecorder = camera.getRecorder();\n    this.subCameras.forEach(function (subCamera) //, cameraId\n    {\n      // TODO [PORTAL] update cam pos, rot, rel. to portal position.\n      // remark. shouldnt i clip after having rotated?\n      subCamera.setZRotation(rotationZ);\n      subCamera.setXRotation(rotationX);\n      subCamera.setUpRotation(theta1, 0, theta0);\n      subCamera.addRotationTransform();\n      var mirrorCamera = subCamera.getRecorder();\n      var mirror = subCamera.getScreen().getMesh(); //let camera = mirrorCamera;\n\n      if (mirrorCamera) {\n        this.clipOblique(mirror, mirrorCamera, localRecorder);\n      }\n    }.bind(this));\n  },\n  resize: function resize(width, height) {\n    var aspect = width / height; // Main cam\n\n    var camera = this.mainCamera.getRecorder();\n    camera.aspect = aspect;\n    camera.updateProjectionMatrix(); // Raycast\n\n    var raycasterCamera = this.mainRaycasterCamera.getRecorder();\n    raycasterCamera.aspect = aspect;\n    raycasterCamera.updateProjectionMatrix(); // Portals\n\n    this.subCameras.forEach(function (currentCamera\n    /*, cameraId*/\n    ) {\n      var recorder = currentCamera.getRecorder();\n      recorder.aspect = aspect;\n      recorder.updateProjectionMatrix();\n    });\n    this.stencilCamera.aspect = aspect;\n    this.stencilCamera.updateProjectionMatrix(); // Water\n\n    this.waterCamera.camera.aspect = aspect;\n    this.waterCamera.camera.updateProjectionMatrix();\n  },\n  // Raycasting.\n  createRaycaster: function createRaycaster() {\n    return new three_module["Ab" /* Raycaster */]();\n  },\n  performRaycast: function performRaycast() {\n    var graphicsEngine = this.graphicsEngine;\n    var chunkModel = graphicsEngine.app.model.server.chunkModel;\n    var selfModel = graphicsEngine.app.model.server.selfModel;\n    var raycaster = this.raycaster;\n    var camera = this.mainRaycasterCamera.getRecorder();\n    var mc = this.mainCamera.getRecorder();\n    mc.updateMatrixWorld();\n    camera.matrixWorld.copy(mc.matrixWorld);\n    var terrain = chunkModel.getCloseTerrain(selfModel.worldId, selfModel.position);\n    var intersects;\n    raycaster.setFromCamera(new three_module["Rb" /* Vector2 */](0, 0), camera);\n    intersects = raycaster.intersectObjects(terrain);\n    return intersects;\n  },\n  cleanup: function cleanup() {\n    this.mainCamera = this.createCamera(false, -1);\n    this.mainCamera.setCameraId(-1);\n    this.subCameras.clear();\n    this.mainRaycasterCamera = this.createCamera(true, -1);\n    this.raycaster = this.createRaycaster();\n    this.oldTheta0 = 0;\n    this.oldTheta1 = 0;\n  }\n});\nextend(cameras_CameraManager.prototype, WaterCameraModule);\n/** Interface with graphics engine. **/\n\nvar CamerasModule = {\n  createCameraManager: function createCameraManager() {\n    return new cameras_CameraManager(this);\n  },\n  getCameraCoordinates: function getCameraCoordinates() {\n    return this.cameraManager.mainCamera.getCameraPosition();\n  },\n  getCameraForwardVector: function getCameraForwardVector() {\n    return this.cameraManager.mainCamera.getCameraForwardVector();\n  },\n  getModelForwardVector: function getModelForwardVector() {\n    return this.cameraManager.mainCamera.getModelForwardVector();\n  },\n\n  /** @deprecated */\n  switchToCamera: function switchToCamera(oldId, newId) {\n    return this.cameraManager.switchToCamera(oldId, newId);\n  }\n};\n\n// EXTERNAL MODULE: ./node_modules/three/examples/jsm/postprocessing/ShaderPass.js\nvar ShaderPass = __webpack_require__(6);\n\n// EXTERNAL MODULE: ./node_modules/three/examples/jsm/postprocessing/MaskPass.js\nvar MaskPass = __webpack_require__(7);\n\n// EXTERNAL MODULE: ./node_modules/three/examples/jsm/postprocessing/ClearPass.js\nvar ClearPass = __webpack_require__(40);\n\n// EXTERNAL MODULE: ./node_modules/three/examples/jsm/shaders/CopyShader.js\nvar CopyShader = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\nvar EffectComposer = __webpack_require__(8);\n\n// EXTERNAL MODULE: ./node_modules/three/examples/jsm/postprocessing/RenderPass.js\nvar RenderPass = __webpack_require__(21);\n\n// EXTERNAL MODULE: ./node_modules/three/examples/jsm/shaders/FXAAShader.js\nvar FXAAShader = __webpack_require__(22);\n\n// EXTERNAL MODULE: ./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js + 1 modules\nvar UnrealBloomPass = __webpack_require__(25);\n\n// EXTERNAL MODULE: ./node_modules/three/examples/jsm/postprocessing/Pass.js\nvar Pass = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/render/ShadowPass.js\n\n\n\nvar ShadowPass_ShadowPass = function ShadowPass(scene, camera, lights, sceneShadows) {\n  Pass["a" /* Pass */].call(this);\n  this.scene = scene;\n  this.camera = camera;\n  this.sceneShadows = sceneShadows;\n  this.lights = lights;\n  this.clear = false;\n  this.needsSwap = false;\n};\n\nShadowPass_ShadowPass.prototype = Object.assign(Object.create(Pass["a" /* Pass */].prototype), {\n  constructor: ShadowPass_ShadowPass,\n  render: function render(renderer, writeBuffer, readBuffer) {\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n    var gl = renderer.getContext();\n    var scene = this.scene;\n    var camera = this.camera;\n    var sceneShadows = this.sceneShadows; // Clears color, depth and stencil buffers\n\n    renderer.clear(); // Disable lights to draw ambient pass using .intensity = 0\n    // instead of .visible = false to not force a slow shader\n    // recomputation.\n    // lights.forEach(function(l) {\n    //     l.intensity = 0;\n    // });\n\n    var lights = this.lights; // lights.ambientLight.intensity = 0;\n\n    lights.directionalLight.intensity = 0;\n    lights.hemisphereLight.intensity = 0; // Render the scene with ambient lights only\n\n    renderer.render(scene, camera); // Compute shadows into the stencil buffer.\n    // Enable stencils\n\n    gl.enable(gl.STENCIL_TEST); // Config the stencil buffer to test each fragment\n\n    gl.stencilFunc(gl.ALWAYS, 1, 0xff); // Disable writes to depth buffer and color buffer\n    // Only want to write to stencil\n\n    gl.depthMask(false);\n    gl.colorMask(false, false, false, false); // Begin depth fail algorithm for stencil updates\n    // Cull front faces\n\n    gl.cullFace(gl.FRONT); // Increment on depth fail (2nd param)\n\n    gl.stencilOp(gl.KEEP, gl.INCR, gl.KEEP); // gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR_WRAP); // z-pass approach\n    // Render shadow volumes\n\n    renderer.render(sceneShadows, camera); // Cull back faces\n\n    gl.cullFace(gl.BACK); // Decrement on depth fail (2nd param)\n\n    gl.stencilOp(gl.KEEP, gl.DECR, gl.KEEP); // gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR_WRAP); // z-pass approach\n    // Render shadow volumes again\n\n    renderer.render(sceneShadows, camera); // Redraw against the stencil non-shadowed regions\n    // Stencil buffer now reads 0 for non-shadow\n\n    gl.stencilFunc(gl.EQUAL, 0, 0xff); // Don\'t update stencil buffer anymore\n\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP); // Re-enable writes to the depth and color buffers\n\n    gl.depthMask(true);\n    gl.colorMask(true, true, true, true); // Re-enable lights for render\n    // lights.forEach(function(l) {\n    //     l.intensity = 1;\n    // });\n    // lights.ambientLight.intensity = 1;\n\n    lights.directionalLight.intensity = LightDefaultIntensities.DIRECTIONAL;\n    lights.hemisphereLight.intensity = LightDefaultIntensities.HEMISPHERE; // Render scene that\'s not in shadow with light calculations\n\n    renderer.clearDepth();\n    renderer.render(scene, camera); // Disable stencil test\n\n    gl.disable(gl.STENCIL_TEST); // if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n    // renderer.render(this.scene, this.camera);\n  }\n});\n\n// EXTERNAL MODULE: ./node_modules/three/examples/jsm/postprocessing/SAOPass.js + 3 modules\nvar SAOPass = __webpack_require__(24);\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/render/renderer.factory.js\n/**\n * Renderer and composers creation.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar RendererFactory = {\n  createPortalComposer: function createPortalComposer(rendrr, sc, cam, target, maskScene, maskCamera) {\n    var maskPass = new MaskPass["b" /* MaskPass */](maskScene, maskCamera);\n    var clearPass = new ClearPass["a" /* ClearPass */]();\n    var clearMaskPass = new MaskPass["a" /* ClearMaskPass */]();\n    var copy = new ShaderPass["a" /* ShaderPass */](CopyShader["a" /* CopyShader */]);\n    var composer = new EffectComposer["a" /* EffectComposer */](rendrr, target);\n    composer.renderTarget1.stencilBuffer = true;\n    composer.renderTarget2.stencilBuffer = true;\n    var scenePass = new RenderPass["a" /* RenderPass */](sc, cam);\n    scenePass.clear = false;\n    maskPass.inverse = false;\n    composer.addPass(clearPass);\n    composer.addPass(maskPass);\n    composer.addPass(scenePass);\n    composer.addPass(copy);\n    composer.addPass(clearMaskPass); // composer.addPass(copy);\n    // Anti-alias\n\n    var resolutionX = 1 / window.innerWidth;\n    var resolutionY = 1 / window.innerHeight;\n    var fxaa = new ShaderPass["a" /* ShaderPass */](FXAAShader["a" /* FXAAShader */]);\n    var u = \'resolution\';\n    fxaa.uniforms[u].value.set(resolutionX, resolutionY); // composer.addPass(fxaa);\n    // composer.addPass(fxaa);\n    // composer.addPass(copy);\n    // Bloom\n\n    var bloomPass = new UnrealBloomPass["a" /* UnrealBloomPass */](new three_module["Rb" /* Vector2 */](window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);\n    bloomPass.exposure = 0.5;\n    bloomPass.threshold = 0.3;\n    bloomPass.strength = 1.0;\n    bloomPass.radius = 0;\n    var bloomComposer = new EffectComposer["a" /* EffectComposer */](rendrr, target);\n    bloomComposer.renderToScreen = false;\n    bloomComposer.renderTarget1.stencilBuffer = true;\n    bloomComposer.renderTarget2.stencilBuffer = true;\n    bloomComposer.addPass(clearPass);\n    bloomComposer.addPass(maskPass);\n    bloomComposer.addPass(scenePass);\n    bloomComposer.addPass(clearMaskPass);\n    bloomComposer.addPass(bloomPass); // no fxaa on the bloom pass\n\n    var bloomMergePass = new ShaderPass["a" /* ShaderPass */](new three_module["Eb" /* ShaderMaterial */]({\n      uniforms: {\n        baseTexture: {\n          value: null\n        },\n        bloomTexture: {\n          value: bloomComposer.renderTarget2.texture\n        }\n      },\n      vertexShader: this.graphics.getBloomSelectiveVertexShader(),\n      fragmentShader: this.graphics.getBloomSelectiveFragmentShader(),\n      defines: {}\n    }), \'baseTexture\');\n    bloomMergePass.needsSwap = true;\n    var finalComposer = new EffectComposer["a" /* EffectComposer */](rendrr, target);\n    finalComposer.renderTarget1.stencilBuffer = true;\n    finalComposer.renderTarget2.stencilBuffer = true;\n    finalComposer.addPass(clearPass);\n    finalComposer.addPass(maskPass);\n    finalComposer.addPass(scenePass);\n    finalComposer.addPass(bloomMergePass);\n    finalComposer.addPass(fxaa);\n    finalComposer.addPass(clearMaskPass);\n    finalComposer.addPass(copy);\n    return [bloomComposer, finalComposer, composer];\n  },\n  createMainComposer: function createMainComposer(rendrr, sc, cam, lights) {\n    // Anti-alias\n    var resolutionX = 1 / window.innerWidth;\n    var resolutionY = 1 / window.innerHeight;\n    var fxaa = new ShaderPass["a" /* ShaderPass */](FXAAShader["a" /* FXAAShader */]);\n    var u = \'resolution\';\n    fxaa.uniforms[u].value.set(resolutionX, resolutionY); // let copy = new ShaderPass(CopyShader);\n\n    var composer = new EffectComposer["a" /* EffectComposer */](rendrr);\n    composer.renderTarget1.stencilBuffer = true;\n    composer.renderTarget2.stencilBuffer = true;\n    var scenePass = new RenderPass["a" /* RenderPass */](sc, cam);\n    var shadowPass;\n\n    if (this.shadowVolumes) {\n      shadowPass = new ShadowPass_ShadowPass(sc, cam, lights, this.sceneShadows);\n      composer.addPass(shadowPass);\n    } else {\n      composer.addPass(scenePass);\n    }\n\n    composer.addPass(fxaa); // Bloom\n\n    var bloomPass = new UnrealBloomPass["a" /* UnrealBloomPass */](new three_module["Rb" /* Vector2 */](window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);\n    bloomPass.exposure = 0.5;\n    bloomPass.threshold = 0.3;\n    bloomPass.strength = 1.0;\n    bloomPass.radius = 0;\n    var bloomComposer = new EffectComposer["a" /* EffectComposer */](rendrr);\n    bloomComposer.renderTarget1.stencilBuffer = true;\n    bloomComposer.renderTarget2.stencilBuffer = true;\n    bloomComposer.renderToScreen = false;\n\n    if (this.shadowVolumes) {\n      bloomComposer.addPass(shadowPass);\n    } else {\n      bloomComposer.addPass(scenePass);\n    }\n\n    bloomComposer.addPass(bloomPass); // no fxaa on the bloom pass\n\n    var bloomMergePass = new ShaderPass["a" /* ShaderPass */](new three_module["Eb" /* ShaderMaterial */]({\n      uniforms: {\n        baseTexture: {\n          value: null\n        },\n        bloomTexture: {\n          value: bloomComposer.renderTarget2.texture\n        }\n      },\n      vertexShader: this.graphics.getBloomSelectiveVertexShader(),\n      fragmentShader: this.graphics.getBloomSelectiveFragmentShader(),\n      defines: {}\n    }), \'baseTexture\');\n    bloomMergePass.needsSwap = true;\n    var finalComposer = new EffectComposer["a" /* EffectComposer */](rendrr);\n    finalComposer.addPass(scenePass);\n    finalComposer.addPass(bloomMergePass);\n    finalComposer.addPass(fxaa); // Ambient occlusion\n\n    var ambientOcclusion = this.ambientOcclusion;\n\n    if (ambientOcclusion) {\n      var sao = new SAOPass["a" /* SAOPass */](sc, cam, false, false);\n      sao.params.output = SAOPass["a" /* SAOPass */].OUTPUT.Default;\n      sao.params.saoBias = 0.1;\n      sao.params.saoIntensity = 1.8;\n      sao.params.saoScale = 10000;\n      sao.params.saoKernelRadius = 100;\n      sao.params.saoMinResolution = 0.000004;\n      sao.params.saoBlur = 1;\n      sao.params.saoBlurRadius = 8;\n      sao.params.saoBlurStdDev = 4;\n      sao.params.saoBlurDepthCutoff = 0.01;\n      finalComposer.addPass(sao);\n    }\n\n    return [bloomComposer, finalComposer, composer];\n  },\n  createRenderer: function createRenderer() {\n    // Configure renderer\n    var renderer = new three_module["Xb" /* WebGLRenderer */]({\n      antialias: false,\n      alpha: true,\n      logarithmicDepthBuffer: this.shadowVolumes // precision: \'mediump\'\n\n    });\n\n    if (this.shadowMap) {\n      renderer.shadowMap.enabled = true;\n      renderer.shadowMap.type = three_module["mb" /* PCFSoftShadowMap */];\n    }\n\n    renderer.autoClear = false;\n    renderer.outputEncoding = three_module["Zb" /* sRGBEncoding */];\n    renderer.setClearColor(this.cssToHex(\'#362c6b\'), 1);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.info.autoReset = false;\n    return renderer;\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/render/renderer.updates.js\n/**\n * Functions called at every render pass.\n */\n\n\nvar RendererUpdates = {\n  darkenNonBloomed: function darkenNonBloomed(obj, materials) {\n    if (obj.isMesh && obj.userData.bloom !== true) {\n      materials[obj.uuid] = obj.material;\n      obj.material = this.darkMaterial;\n    }\n  },\n  restoreMaterial: function restoreMaterial(obj, materials) {\n    if (materials[obj.uuid]) {\n      obj.material = materials[obj.uuid];\n      delete materials[obj.uuid];\n    }\n  },\n  updateSkies: function updateSkies(mainCamera) {\n    var _this = this;\n\n    var skies = this.graphics.app.model.server.chunkModel.skies;\n    skies.forEach(function (sky, worldId) {\n      // TODO [SKY] manage with other cameras\n      _this.graphics.updateSunPosition(mainCamera, sky, worldId);\n    });\n  },\n  updateWaters: function updateWaters(cameraManager, renderer, mainScene, mainCam) {\n    var _this2 = this;\n\n    // Update uniforms\n    var worlds = this.graphics.app.model.server.chunkModel.worlds;\n    var skies = this.graphics.app.model.server.chunkModel.skies;\n    var eye = cameraManager.waterCamera.eye; // let instancedMaterials = this.graphics.instancedMaterials;\n\n    var waterMaterials = this.graphics.waterMaterials;\n    var darkWater = this.darkWater;\n    worlds.forEach(function (w) {\n      // const materialsFoWorld = instancedMaterials.get(wid);\n      // const materialForWater = materialsFoWorld[1];\n      // let sky = skies.get(wid);\n      // let sdir = this.graphics.getSunDirection(sky);\n      w.forEach(function (chunk) {\n        var m = chunk.meshes;\n\n        for (var i = 0; i < m.length; ++i) {\n          if (!chunk.water[i]) continue;\n          var mi = m[i];\n          mi.visible = false;\n\n          if (mi.material) {\n            // mi.material = materialForWater;\n            mi.material = darkWater;\n          } // if (mi.material && mi.material.uniforms && mi.material.uniforms.time)\n          // {\n          //     mi.material.uniforms.eye.value = eye;\n          //     mi.material.uniforms.sunDirection.value = sdir;\n          //     mi.material.uniforms.time.value += 0.01;\n          // }\n\n        }\n      });\n    }); // Update main camera\n\n    this.updateWaterCamera(cameraManager, renderer, mainScene, mainCam); // Update display\n\n    worlds.forEach(function (w, wid) {\n      var sky = skies.get(wid);\n\n      var sdir = _this2.graphics.getSunDirection(sky);\n\n      var materialForWater = waterMaterials.get(wid);\n\n      if (!materialForWater) {// console.error(\'[Renderer/Updates] Material not found.\');\n        // Possibly has no water -> its not an error\n      }\n\n      w.forEach(function (chunk) {\n        var m = chunk.meshes;\n\n        for (var i = 0; i < m.length; ++i) {\n          if (!chunk.water[i]) continue;\n          var mi = m[i];\n          mi.visible = true;\n\n          if (mi.material) {\n            mi.material = materialForWater;\n          }\n        }\n      });\n\n      if (materialForWater && materialForWater.uniforms && materialForWater.uniforms.eye) {\n        materialForWater.uniforms.eye.value = eye;\n        materialForWater.uniforms.sunDirection.value = sdir;\n        materialForWater.uniforms.time.value += 0.01;\n      }\n    });\n  },\n  updateWaterCamera: function updateWaterCamera(cameraManager, renderer, mainScene, mainCamera) {\n    // Update mirror camera\n    cameraManager.updateWaterCamera(mainCamera);\n    if (this.shortCircuitWaterReflection) return; // Perform render\n\n    var scene = mainScene;\n    var waterCamera = cameraManager.waterCamera;\n    var renderTarget = waterCamera.waterRenderTarget;\n    var mirrorCamera = cameraManager.waterCamera.camera; // Save\n\n    var currentRenderTarget = renderer.getRenderTarget();\n    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate; // let currentXrEnabled = renderer.xr.enabled;\n    // scope.visible = false; // single side, no need\n    // renderer.xr.enabled = false; // Avoid camera modification and recursion\n\n    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n    renderer.setRenderTarget(renderTarget);\n    if (renderer.autoClear === false) renderer.clear();\n    renderer.render(scene, mirrorCamera); // Restore\n    // scope.visible = true; // single side, no need\n    // renderer.xr.enabled = currentXrEnabled;\n\n    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n    renderer.setRenderTarget(currentRenderTarget); // let viewport = camera.viewport;\n    // if (viewport !== undefined) {\n    //     renderer.state.viewport(viewport);\n    // }\n  },\n  updateShadows: function updateShadows() // cameraManager)\n  {\n    var graphics = this.graphics;\n    var worlds = graphics.app.model.server.chunkModel.worlds;\n    var skies = graphics.app.model.server.chunkModel.skies; // let eye = cameraManager.waterCamera.eye;\n\n    var eye = graphics.getCameraCoordinates(); // let eyedir = cameraManager.mainCamera.getCameraForwardVector();\n\n    worlds.forEach(function (w, wid) {\n      var sky = skies.get(wid);\n      var sdir = graphics.getSunDirection(sky);\n      sdir.set(-sdir.x, sdir.y, sdir.z).negate();\n      w.forEach(function (chunk) {\n        if (!chunk.shadow) return;\n        var mi = chunk.shadow;\n\n        if (mi.material && mi.material.uniforms) {\n          mi.material.uniforms.lightPosition.value = sdir;\n          mi.material.uniforms.eyePosition.value = eye;\n        }\n      });\n    });\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/render/renderer.js\n/**\n * Renderer, render layers management.\n */\n\n\n\n\n\n\n\n\n\nvar renderer_RendererManager = function RendererManager(graphicsEngine) {\n  this.graphics = graphicsEngine; // Graphical settings\n\n  this.selectiveBloom = true;\n  this.waterReflection = true; // To disable water reflection, but not the moving water texture\n\n  this.shortCircuitWaterReflection = false; // Shadows:\n  // - not compatible with portals\n  // - only for blocks\n  // - shadow map =\n  //          soft shadows, capped distance, flickering at the edges\n  //          ~=CPU load\n  //          ++GPU load (adding a render pass + depends on tex resolution).\n  // - shadow volumes =\n  //          crisp shadows, stable and high-fidelity\n  //          not yet working with non-manifold edges\n  //          ++CPU load at chunk create/update.\n  //          +++GPU load (adding render passes + fill time).\n\n  this.shadowVolumes = false;\n  this.shadowMap = false;\n  this.highResolutionShadowMap = false;\n\n  if (this.shadowVolumes && this.shadowMap) {\n    console.error(\'[Renderer] Cannot use both shadow map and shadow volume.\');\n    this.shadowVolumes = false;\n  } // ISSUES\n  // Performance issue with Firefox + three (water reflection)\n  // const isFirefox = navigator.userAgent.toLowerCase().indexOf(\'firefox\') > -1;\n  // if (isFirefox)\n  //     this.shortCircuitWaterReflection = true;\n  // Bloom + light intensity issue on mobile\n\n\n  var isMobile = \'ontouchstart\' in window || navigator.msMaxTouchPoints > 0;\n\n  if (isMobile) {\n    this.selectiveBloom = false;\n    LightDefaultIntensities.HEMISPHERE *= 4;\n    LightDefaultIntensities.DIRECTIONAL *= 4;\n    LightDefaultIntensities.AMBIENT *= 4;\n  } // \\ISSUES\n  // No support for AO atm.\n\n\n  this.ambientOcclusion = false; // Cap number of passes.\n\n  this.renderMax = 10;\n  this.renderer = this.createRenderer();\n  this.renderer.autoClear = false;\n  this.composers = new Map(); // Lightweight screen, camera and scene manager for portals.\n\n  this.renderRegister = [];\n  this.stencilScene = new three_module["Db" /* Scene */]();\n  this.stencilScreen = new three_module["W" /* Mesh */](new three_module["pb" /* PlaneBufferGeometry */](1, 2), new three_module["X" /* MeshBasicMaterial */]({\n    color: 0xaaaaaa,\n    side: three_module["t" /* DoubleSide */],\n    transparent: false\n  }));\n  this.stencilScene.add(this.stencilScreen);\n  this.corrupted = 0;\n  this.stop = false;\n  this.thenstop = false; // Bloom\n\n  this.darkMaterial = new three_module["X" /* MeshBasicMaterial */]({\n    color: \'black\',\n    side: three_module["t" /* DoubleSide */],\n    morphTargets: true\n  });\n  this.darkWater = new three_module["X" /* MeshBasicMaterial */]({\n    color: \'black\',\n    side: three_module["t" /* DoubleSide */],\n    morphTargets: true\n  });\n\n  if (this.shadowVolumes) {\n    this.sceneShadows = new three_module["Db" /* Scene */]();\n  }\n};\n\nextend(renderer_RendererManager.prototype, {\n  addToShadows: function addToShadows(mesh) {\n    this.sceneShadows.add(mesh);\n  },\n  removeFromShadows: function removeFromShadows(mesh) {\n    this.sceneShadows.remove(mesh);\n  },\n  cssToHex: function cssToHex(cssColor) {\n    return 0 | cssColor.replace(\'#\', \'0x\');\n  },\n  getRenderRegister: function getRenderRegister() {\n    return this.renderRegister;\n  },\n  setRenderRegister: function setRenderRegister(renderRegister) {\n    this.renderRegister = renderRegister;\n  },\n  render: function render(sceneManager, cameraManager) {\n    var _this = this;\n\n    if (this.stop) return;\n    var renderer = this.renderer;\n    var renderRegister = this.renderRegister; // Util.\n\n    var materials = {}; // Render first pass.\n\n    var mainScene = sceneManager.mainScene;\n    var mainCamera = cameraManager.mainCamera.getRecorder(); // Update main camera.\n\n    mainCamera.updateProjectionMatrix();\n    mainCamera.updateMatrixWorld();\n    mainCamera.matrixWorldInverse.getInverse(mainCamera.matrixWorld);\n    mainScene.updateMatrixWorld(); // Updates.\n\n    try {\n      this.updateSkies(mainCamera);\n\n      if (this.waterReflection) {\n        // get main\n        var currentWid = this.graphics.app.model.server.selfModel.worldId.toString();\n        if (currentWid === \'-1\') this.updateWaters(cameraManager, renderer, mainScene, mainCamera);else {\n          for (var j = 0, m = renderRegister.length; j < m; ++j) {\n            var pass = renderRegister[j];\n            var sc = pass.scene;\n            if (!sc) continue;\n            sceneId = pass.sceneId.toString();\n\n            if (sceneId === \'-1\') {\n              var cm = pass.camera.cameraObject;\n              this.updateWaters(cameraManager, renderer, sc, cm);\n              break;\n            }\n          }\n        }\n      }\n\n      if (this.shadowVolumes) this.updateShadows(cameraManager, renderer, mainScene, mainCamera);\n    } catch (e) {\n      console.error(e);\n      this.stop = true;\n      return;\n    } // Render every portal.\n\n\n    var renderCount = 0;\n    var renderMax = this.renderMax;\n    var currentPass;\n    var screen1;\n    var screen2;\n    var camera;\n    var bufferScene;\n    var bufferCamera;\n    var bufferTexture;\n    var otherEnd; // let otherSceneId;\n    // This fixes the 1-frame lag for inner-most scenes.\n\n    for (var _j = 0, _m = renderRegister.length; _j < _m; ++_j) {\n      currentPass = renderRegister[_j];\n      bufferScene = currentPass.scene;\n      if (!bufferScene) continue; // Latencx fix for inner scenes.\n\n      bufferScene.updateMatrixWorld(); // Flickering fix for linking to the same scene.\n      // bufferCamera = currentPass.camera.getRecorder();\n      // bufferCamera.updateProjectionMatrix();\n      // bufferCamera.updateMatrixWorld();\n    }\n\n    var stencilCamera = cameraManager.stencilCamera;\n    this.stencilScene.updateMatrixWorld();\n    this.graphics.cameraManager.moveCameraFromMouse(0, 0, 0, 0);\n    var worlds = this.graphics.app.model.server.chunkModel.worlds;\n    var pathId;\n    var sceneId;\n    var instancedMaterials = this.graphics.instancedMaterials;\n    var waterMaterials = this.graphics.waterMaterials;\n\n    var _loop2 = function _loop2(i, n) {\n      if (renderCount++ > renderMax) return "break";\n      currentPass = renderRegister[i];\n      screen1 = currentPass.screen1;\n      screen2 = currentPass.screen2;\n      camera = currentPass.camera;\n      sceneId = currentPass.sceneId.toString();\n      pathId = currentPass.id;\n      var defaultMaterials = instancedMaterials.get(sceneId);\n      var defaultMaterial = void 0;\n      var defaultWaterMaterial = void 0;\n\n      if (!defaultMaterials) {// console.error(\'[Renderer] Default material not found!\');\n      } else {\n        defaultMaterial = defaultMaterials[0];\n        defaultWaterMaterial = waterMaterials.get(sceneId);\n      }\n\n      var passMaterial = instancedMaterials.get(pathId);\n      var passWaterMaterial = waterMaterials.get(pathId);\n\n      if (!passMaterial && defaultMaterial) {\n        passMaterial = defaultMaterial.clone();\n        instancedMaterials.set(pathId, passMaterial);\n\n        if (defaultWaterMaterial) {\n          passWaterMaterial = defaultWaterMaterial.clone();\n          waterMaterials.set(pathId, passWaterMaterial);\n        }\n      }\n\n      var chks = worlds.get(sceneId);\n\n      if (!chks) {// console.log(\'No chunks there.\');\n      }\n\n      bufferScene = currentPass.scene;\n      if (!camera) return "continue";\n      bufferCamera = camera.getRecorder();\n      bufferTexture = screen1.getRenderTarget();\n\n      if (!bufferScene) {\n        if (_this.corrupted < 5) {\n          // console.log(`[Renderer] Could not get buffer scene ${currentPass.sceneId}.`);\n          // Happens while loading other worlds.\n          _this.corrupted++;\n        } // Sometimes the x model would be initialized before the w model.\n\n\n        if (currentPass.sceneId) {\n          currentPass.scene = sceneManager.getScene(currentPass.sceneId);\n        }\n\n        return "continue";\n      }\n\n      if (!bufferCamera) {\n        console.log(\'Could not get buffer camera.\');\n        return "continue";\n      }\n\n      if (!bufferTexture) {\n        console.log(\'Could not get buffer texture.\');\n        return "continue";\n      }\n\n      if (screen2) {\n        // otherSceneId = currentPass.sceneId;\n        otherEnd = screen2.getMesh();\n        otherEnd.visible = false; // sceneManager.removeObject(otherEnd, otherSceneId, true);\n      } //console.log(\'[Renderer] Rendering.\');\n      //screen1.getMesh().updateMatrixWorld();\n      //if (screen2) screen2.getMesh().updateMatrixWorld();\n      //bufferCamera.updateProjectionMatrix();\n      //bufferCamera.updateProjectionMatrix();\n      // bufferCamera.updateMatrixWorld();\n      //bufferCamera.matrixWorldInverse.getInverse(bufferCamera.matrixWorld);\n      // this.graphics.cameraManager.moveCameraFromMouse(0, 0, 0, 0);\n      // Render scene into screen1\n\n\n      var s1 = screen1.getMesh(); // s1.updateMatrixWorld();\n      // this.stencilScreen.matrixWorld.copy(s1.matrixWorld);\n\n      var sts = _this.stencilScreen;\n      var t = camera.getCameraTransform();\n      sts.position.copy(s1.position);\n      sts.position.x += t[0];\n      sts.position.y += t[1];\n      sts.position.z += t[2];\n      sts.rotation.copy(s1.rotation); // sts.rotation.y += t[3];\n\n      sts.updateMatrixWorld(); // sts.position.set(s1.position.x, s1.position.y + 0.1, s1.position.z);\n      // bufferCamera.updateProjectionMatrix();\n      // stc.position.copy(bufferCamera.position);\n      // stc.rotation.copy(bufferCamera.rotation);\n      // bufferCamera.updateMatrixWorld(true);\n\n      stencilCamera.matrixWorld.copy(bufferCamera.matrixWorld); // stc.matrixWorld.copy(bufferCamera.matrixWorld);\n      // stc.projectionMatrix.copy(bufferCamera.projectionMatrix);\n      // renderer.setRenderTarget(bufferTexture);\n\n      var id = currentPass.id.toString();\n      var bufferComposer = void 0;\n\n      if (_this.composers.has(id)) {\n        bufferComposer = _this.composers.get(id);\n      } else {\n        bufferComposer = _this.createPortalComposer(renderer, bufferScene, bufferCamera, bufferTexture, _this.stencilScene, stencilCamera);\n\n        _this.composers.set(id, bufferComposer);\n      }\n\n      if (chks && defaultMaterial && passMaterial) chks.forEach(function (c) {\n        var m = c.meshes;\n\n        for (var cc = 0; cc < m.length; ++cc) {\n          var mi = m[cc];\n          if (!mi) continue;\n\n          if (c.water[cc]) {// mi.material = passWaterMaterial;\n          } else if (mi.material) {\n            mi.material = passMaterial;\n          }\n        }\n      });\n      s1.visible = false;\n\n      if (_this.selectiveBloom) {\n        bufferScene.traverse(function (obj) {\n          return _this.darkenNonBloomed(obj, materials);\n        });\n        bufferComposer[0].render();\n        bufferScene.traverse(function (obj) {\n          return _this.restoreMaterial(obj, materials);\n        });\n        bufferComposer[1].render();\n      } else {\n        bufferComposer[2].render();\n      }\n\n      s1.visible = true;\n      if (chks && defaultMaterial && passMaterial) chks.forEach(function (c) {\n        var m = c.meshes;\n\n        for (var cc = 0; cc < m.length; ++cc) {\n          var mi = m[cc];\n          if (!mi) continue;\n\n          if (c.water[cc]) {// mi.material = defaultWaterMaterial;\n          } else if (mi.material) {\n            mi.material = defaultMaterial;\n          }\n        }\n      });\n\n      if (screen2) {\n        // sceneManager.addObject(otherEnd, otherSceneId);\n        otherEnd.visible = true;\n      }\n    };\n\n    _loop: for (var i = 0, n = renderRegister.length; i < n; ++i) {\n      var _ret = _loop2(i, n);\n\n      switch (_ret) {\n        case "break":\n          break _loop;\n\n        case "continue":\n          continue;\n      }\n    } // Make composer\n    // XXX [PERF] optimise composer creation\n\n\n    var id = this.graphics.app.model.server.selfModel.worldId.toString();\n    var composer;\n\n    if (this.composers.has(id)) {\n      composer = this.composers.get(id);\n    } else {\n      var skies = this.graphics.app.model.server.chunkModel.skies;\n      var s = skies.get(id);\n\n      if (s && s.lights) {\n        composer = this.createMainComposer(renderer, mainScene, mainCamera, s.lights);\n        this.composers.set(id, composer);\n      } else return;\n    } // MAIN RENDER\n\n\n    if (this.selectiveBloom) {\n      mainScene.traverse(function (obj) {\n        return _this.darkenNonBloomed(obj, materials);\n      });\n      composer[0].render();\n      mainScene.traverse(function (obj) {\n        return _this.restoreMaterial(obj, materials);\n      });\n      composer[1].render();\n    } else {\n      composer[2].render();\n    } // Compute draw calls\n    // console.log(renderer.info.render.calls);\n\n\n    renderer.info.reset();\n  },\n  resize: function resize(width, height) {\n    var _this2 = this;\n\n    if (!width) width = window.innerWidth;\n    if (!height) height = window.innerHeight;\n    this.renderer.setSize(width, height);\n    this.composers.forEach(function (cs) {\n      var _loop3 = function _loop3(i) {\n        var c = cs[i];\n        c.setSize(width, height);\n\n        var pixelRatio = _this2.renderer.getPixelRatio();\n\n        var r = \'resolution\';\n        var passes = c.passes;\n        passes.forEach(function (p) {\n          if (!p || !(p instanceof ShaderPass["a" /* ShaderPass */])) return;\n          if (!p.material || !p.material.uniforms) return;\n          if (!p.material.uniforms[r]) return;\n          p.material.uniforms[r].value.x = 1 / (width * pixelRatio);\n          p.material.uniforms[r].value.y = 1 / (height * pixelRatio);\n        });\n      };\n\n      for (var i = 0; i < cs.length; ++i) {\n        _loop3(i);\n      }\n    });\n  },\n  // Triggered at the start of a switch-to-world.\n  switchAvatarToScene: function switchAvatarToScene()\n  /*sceneId*/\n  {// console.log(\'Mesh switch\');\n    // this.renderRegister;\n  },\n  cleanup: function cleanup() {\n    this.composers.forEach(function () {// XXX [UNLOAD] composer cleanup\n    });\n    this.composers = new Map();\n    this.renderRegister.length = 0;\n  }\n});\nextend(renderer_RendererManager.prototype, RendererFactory);\nextend(renderer_RendererManager.prototype, RendererUpdates);\n/** Interface with graphics engine. **/\n\nvar RenderersModule = {\n  createRendererManager: function createRendererManager() {\n    return new renderer_RendererManager(this);\n  },\n  hasShadowMap: function hasShadowMap() {\n    return this.rendererManager.shadowMap;\n  },\n  hasHighResShadows: function hasHighResShadows() {\n    return this.rendererManager.highResolutionShadowMap;\n  },\n  hasShadowVolumes: function hasShadowVolumes() {\n    return this.rendererManager.shadowVolumes;\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/render/scene.js\n/**\n * Scenes management.\n */\n\n\n\n\n\nvar SceneManager = function SceneManager() {\n  this.mainScene = this.createScene(-1);\n  this.subScenes = new Map();\n  this.screens = new Map();\n};\n\nextend(SceneManager.prototype, {\n  createScene: function createScene(newSceneId) {\n    var scene = new three_module["Db" /* Scene */]();\n    scene.sceneId = newSceneId;\n    scene.autoUpdate = false;\n    return scene;\n  },\n  // Create and push scene with \'newSceneId\' in this.subScenes.\n  // If scene exists already (i.e. it\'s \'mainScene\'), simply push it into this.subScenes\n  addScene: function addScene(newSceneId, scene) {\n    if (!scene) scene = this.createScene(newSceneId);\n    this.subScenes.set(newSceneId, scene);\n    return scene;\n  },\n  hasScene: function hasScene(sceneId) {\n    sceneId = parseInt(sceneId, 10);\n    return this.subScenes.has(sceneId);\n  },\n  // Switch main scene with some scene that must be in this.subScenes\n  switchToScene: function switchToScene(sceneId, cameraManager, avatar) {\n    sceneId = parseInt(sceneId, 10);\n    var newMainScene = this.subScenes.get(sceneId);\n\n    if (!newMainScene) {\n      console.log("Failed to switch to scene ".concat(sceneId, "!"));\n      return;\n    }\n\n    var oldMainScene = this.mainScene;\n    var oldMainSceneId = oldMainScene.sceneId;\n    this.mainScene = newMainScene;\n    this.subScenes["delete"](sceneId);\n    this.addScene(oldMainSceneId, oldMainScene);\n\n    if (avatar) {\n      oldMainScene.remove(avatar);\n      newMainScene.add(avatar);\n    }\n\n    cameraManager.switchMainCameraToWorld(oldMainSceneId, sceneId);\n  },\n  addObject: function addObject(object, sceneId) {\n    var scene = this.getScene(sceneId);\n    if (scene && object.parent !== scene) scene.add(object);\n  },\n  removeObject: function removeObject(object, sceneId, doNotDispose) {\n    var scene = this.getScene(sceneId);\n\n    if (scene) {\n      scene.remove(object);\n\n      if (!doNotDispose) {\n        if (object.geometry) {\n          object.geometry.dispose();\n          object.geometry = null;\n        }\n\n        if (object.material) {\n          object.material.dispose();\n          object.material = null;\n        }\n      }\n    }\n  },\n  getScene: function getScene(sceneId) {\n    return parseInt(sceneId, 10) === parseInt(this.mainScene.sceneId, 10) ? this.mainScene : this.subScenes.get(sceneId);\n  },\n  resize: function resize(width, height) {\n    if (!width) width = window.innerWidth;\n    if (!height) height = window.innerHeight;\n    var screens = this.screens;\n    screens.forEach(function (screen, portalId) {\n      if (!screen.isLinked()) {\n        console.log("Not resizing screen ".concat(portalId, "."));\n        return;\n      }\n\n      var bufferTexture = screen.getRenderTarget();\n      bufferTexture.setSize(width, height);\n    });\n  },\n  removeScreen: function removeScreen(screenId) {\n    var screen = this.screens.get(screenId);\n    if (!screen) return;\n    var scene = this.getScene(screen.getWorldId());\n    if (scene) scene.remove(screen); // Do not dispose of the object! Later use for screen when we get back to this world.\n\n    this.removeObject(screen.getMesh(), screen.getWorldId(), true); // this.screens.delete(screenId);\n  },\n  cleanup: function cleanup() {\n    this.mainScene.dispose();\n    this.mainScene = this.createScene(-1);\n    this.subScenes.forEach(function (s) {\n      s.dispose();\n    });\n    this.subScenes.clear();\n    this.screens.forEach(function (s) {\n      if (s.mesh) {\n        s.mesh.geometry.dispose();\n        s.mesh.material.dispose();\n      }\n\n      if (s.renderTarget) {\n        s.renderTarget.dispose();\n      }\n    });\n    this.screens.clear();\n  }\n});\n/** Interface with graphics engine. **/\n\nvar ScenesModule = {\n  createSceneManager: function createSceneManager() {\n    return new SceneManager(this);\n  },\n  addToShadows: function addToShadows(mesh) {\n    this.rendererManager.addToShadows(mesh);\n  },\n  removeFromShadows: function removeFromShadows(mesh) {\n    this.rendererManager.removeFromShadows(mesh);\n  },\n  addToScene: function addToScene(object3D, sceneId) {\n    var sceneManager = this.sceneManager;\n    if (!sceneId) sceneId = sceneManager.mainScene.sceneId;\n    sceneId = parseInt(sceneId, 10);\n    sceneManager.addObject(object3D, sceneId);\n  },\n  removeFromScene: function removeFromScene(object3D, sceneId, doNotDispose) {\n    var sceneManager = this.sceneManager;\n    if (!sceneId) sceneId = sceneManager.mainScene.sceneId;\n    sceneId = parseInt(sceneId, 10);\n    sceneManager.removeObject(object3D, sceneId, doNotDispose);\n  },\n  addScene: function addScene(newSceneId) {\n    newSceneId = parseInt(newSceneId, 10);\n    var sceneManager = this.sceneManager; // Trying to add an existing scene\n\n    if (parseInt(newSceneId, 10) === parseInt(sceneManager.mainScene.sceneId, 10) || sceneManager.subScenes.has(newSceneId)) {\n      // console.log(`Trying to add an existing scene: ${newSceneId}`);\n      return;\n    }\n\n    return sceneManager.addScene(newSceneId);\n  },\n  // XXX [UNLOAD] unload scene.\n  forgetScene: function forgetScene(sceneId) {\n    var sceneManager = this.sceneManager; // Don\'t delete current scene or a scene that does not exist.\n\n    if (parseInt(sceneId, 10) === parseInt(sceneManager.mainScene.sceneId, 10) || !sceneManager.subScenes.has(sceneId)) {\n      console.log("Trying to delete main scene or unknown scene: ".concat(sceneId));\n      return;\n    }\n\n    this.subScenes["delete"](sceneId);\n  },\n  getScene: function getScene(sceneId, force) {\n    var scene = this.sceneManager.getScene(sceneId);\n\n    if (!scene && force) {\n      scene = this.addScene(sceneId);\n    }\n\n    return scene;\n  },\n  addScreen: function addScreen(screenId, screenObject) {\n    this.sceneManager.screens.set(screenId, screenObject);\n  },\n  getScreen: function getScreen(screenId) {\n    return this.sceneManager.screens.get(screenId);\n  },\n  removeScreen: function removeScreen(screenId) {\n    this.sceneManager.removeScreen(screenId);\n  },\n  switchToScene: function switchToScene(oldSceneId, newSceneId) //, avatar\n  {\n    // console.log(`Switching from ${oldSceneId} to ${newSceneId}`);\n    this.sceneManager.switchToScene(newSceneId, this.cameraManager);\n    this.rendererManager.switchAvatarToScene(newSceneId);\n    this.previousFrameWorld = parseInt(oldSceneId, 10);\n    this.currentFrameWorld = parseInt(newSceneId, 10);\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/terrain/faces.js\n/**\n *\n */\n\n\nvar FacesModule = {\n  /**\n   * old 1-color-cube API\n   * @deprecated\n   */\n  setColor: function setColor() // iChunkOffset, jChunkOffset, kChunkOffset, color\n  {//let chunkSizeX = this.chunkSizeX;\n    //let chunkSizeY = this.chunkSizeY;\n    //color.setRGB((iChunkOffset/chunkSizeX)%2/2+0.5, (jChunkOffset/chunkSizeY)%2/2+0.5, 0.6);\n  },\n  getTexture: function getTexture(nature) {\n    return this.textureCoordinates[nature];\n  },\n  setPNC1: function setPNC1(positions, colors, normals, i, normal, color, ax, ay, az, bx, by, bz, cx, cy, cz, pA, pB, pC, ab, cb, iChunkOffset, jChunkOffset, kChunkOffset) {\n    // Positions\n    positions[i + 0] = normal ? cx : cx;\n    positions[i + 1] = normal ? cy : cy;\n    positions[i + 2] = normal ? cz : cz;\n    positions[i + 3] = normal ? bx : ax;\n    positions[i + 4] = normal ? by : ay;\n    positions[i + 5] = normal ? bz : az;\n    positions[i + 6] = normal ? ax : bx;\n    positions[i + 7] = normal ? ay : by;\n    positions[i + 8] = normal ? az : bz; // Normals\n\n    pA.set(ax, ay, az);\n    normal ? pB.set(bx, by, bz) : pB.set(cx, cy, cz);\n    normal ? pC.set(cx, cy, cz) : pC.set(bx, by, bz);\n    cb.subVectors(pC, pB);\n    ab.subVectors(pA, pB);\n    cb.cross(ab);\n    cb.normalize();\n    var nx = cb.x;\n    var ny = cb.y;\n    var nz = cb.z;\n\n    for (var j = 0; j < 3; ++j) {\n      normals[i + 3 * j] = -nx;\n      normals[i + 3 * j + 1] = -ny;\n      normals[i + 3 * j + 2] = -nz;\n    } // Colors\n\n\n    this.setColor(iChunkOffset, jChunkOffset, kChunkOffset, color);\n\n    for (var _j = 0; _j < 3; ++_j) {\n      colors[i + _j * 3] = color.r;\n      colors[i + _j * 3 + 1] = color.g;\n      colors[i + _j * 3 + 2] = color.b;\n    }\n  },\n  setPNC2: function setPNC2(positions, colors, normals, i, normal, color, ax, ay, az, cx, cy, cz, dx, dy, dz, pA, pB, pC, ab, cb, iChunkOffset, jChunkOffset, kChunkOffset) {\n    // Positions\n    positions[i + 9] = normal ? cx : cx;\n    positions[i + 10] = normal ? cy : cy;\n    positions[i + 11] = normal ? cz : cz;\n    positions[i + 12] = normal ? ax : dx;\n    positions[i + 13] = normal ? ay : dy;\n    positions[i + 14] = normal ? az : dz;\n    positions[i + 15] = normal ? dx : ax;\n    positions[i + 16] = normal ? dy : ay;\n    positions[i + 17] = normal ? dz : az; // Normals\n\n    pA.set(ax, ay, az);\n    normal ? pB.set(cx, cy, cz) : pB.set(dx, dy, dz);\n    normal ? pC.set(dx, dy, dz) : pC.set(cx, cy, cz);\n    cb.subVectors(pC, pB);\n    ab.subVectors(pA, pB);\n    cb.cross(ab);\n    cb.normalize();\n    var nx = cb.x;\n    var ny = cb.y;\n    var nz = cb.z;\n\n    for (var j = 0; j < 3; ++j) {\n      normals[i + 9 + 3 * j] = -nx;\n      normals[i + 9 + 3 * j + 1] = -ny;\n      normals[i + 9 + 3 * j + 2] = -nz;\n    } // Colors\n\n\n    this.setColor(iChunkOffset, jChunkOffset, kChunkOffset, color);\n\n    for (var _j2 = 0; _j2 < 3; ++_j2) {\n      colors[i + 9 + _j2 * 3] = color.r;\n      colors[i + 9 + _j2 * 3 + 1] = color.g;\n      colors[i + 9 + _j2 * 3 + 2] = color.b;\n    }\n  },\n  addFace: function addFace(faceId, pos, iS, ijS, ijkS, positions, normals, colors, uvs, nature, iChunkOffset, jChunkOffset, kChunkOffset, pA, pB, pC, cb, ab, normal, color) {\n    var i = pos * 18;\n    var j;\n    var ax;\n    var bx;\n    var cx;\n    var dx;\n    var ay;\n    var by;\n    var cy;\n    var dy;\n    var az;\n    var bz;\n    var cz;\n    var dz;\n    var ii;\n    var jj;\n    var kk; // UVS\n\n    var uvi = 2 * i / 3;\n    var scalingHD = 8; // depends on texture resolution\n    // let scalingHD = 1; // for 512 texture\n\n    var eps = 0.00390625 / scalingHD; // remove 1 pixel (prevent from texture interpolation on edges)\n\n    var txCoords = this.getTexture(nature);\n\n    if (!txCoords) {\n      console.log("Texture not found for index ".concat(nature, "."));\n      return;\n    }\n\n    var offsetU;\n    var offsetV;\n    var rotate = nature === 1 && // grass\n    Math.random() > 0.5;\n\n    if (faceId < ijkS) // I\n      {\n        ii = faceId % iS;\n        jj = (faceId - ii) % ijS / iS; // [Info] % is prioritary over /\n\n        kk = Math.floor(faceId / ijS);\n        ax = iChunkOffset + 1 + ii;\n        ay = jChunkOffset + jj;\n        az = kChunkOffset + kk;\n        bx = ax;\n        by = ay;\n        bz = az + 1;\n        cx = ax;\n        cy = ay + 1;\n        cz = az + 1;\n        dx = ax;\n        dy = ay + 1;\n        dz = az;\n        if (rotate) this.setPNC1(positions, colors, normals, i, normal, color, bx, by, bz, cx, cy, cz, dx, dy, dz, pA, pB, pC, ab, cb, iChunkOffset, jChunkOffset, kChunkOffset);else this.setPNC1(positions, colors, normals, i, normal, color, ax, ay, az, bx, by, bz, cx, cy, cz, pA, pB, pC, ab, cb, iChunkOffset, jChunkOffset, kChunkOffset); // UVs H1\n\n        offsetU = (normal ? txCoords[0][0] : txCoords[3][0]) * 0.0625;\n        offsetV = (normal ? txCoords[0][1] : txCoords[3][1]) * 0.0625;\n        uvs[uvi] = offsetU + eps;\n        uvs[uvi + 1] = offsetV + eps;\n        uvs[uvi + 2] = offsetU + (normal ? eps : 0.0625 - eps);\n        uvs[uvi + 3] = offsetV + 0.0625 - eps;\n        uvs[uvi + 4] = offsetU + (normal ? 0.0625 - eps : eps);\n        uvs[uvi + 5] = offsetV + 0.0625 - eps;\n        if (rotate) this.setPNC2(positions, colors, normals, i, normal, color, bx, by, bz, dx, dy, dz, ax, ay, az, pA, pB, pC, ab, cb, iChunkOffset, jChunkOffset, kChunkOffset);else this.setPNC2(positions, colors, normals, i, normal, color, ax, ay, az, cx, cy, cz, dx, dy, dz, pA, pB, pC, ab, cb, iChunkOffset, jChunkOffset, kChunkOffset); // UVs H2\n\n        uvs[uvi + 6] = offsetU + eps;\n        uvs[uvi + 7] = offsetV + eps;\n        uvs[uvi + 8] = offsetU + 0.0625 - eps;\n        uvs[uvi + 9] = offsetV + (normal ? 0.0625 - eps : eps);\n        uvs[uvi + 10] = offsetU + 0.0625 - eps;\n        uvs[uvi + 11] = offsetV + (normal ? eps : 0.0625 - eps);\n      } else if (faceId < 2 * ijkS) // J\n      {\n        faceId -= ijkS;\n        ii = faceId % iS;\n        jj = (faceId - ii) % ijS / iS; // % > /\n\n        kk = Math.floor(faceId / ijS);\n        ax = iChunkOffset + ii;\n        ay = jChunkOffset + 1 + jj;\n        az = kChunkOffset + kk;\n        bx = ax + 1;\n        by = ay;\n        bz = az;\n        cx = ax + 1;\n        cy = ay;\n        cz = az + 1;\n        dx = ax;\n        dy = ay;\n        dz = az + 1;\n        if (rotate) this.setPNC1(positions, colors, normals, i, normal, color, bx, by, bz, cx, cy, cz, dx, dy, dz, pA, pB, pC, ab, cb, iChunkOffset, jChunkOffset, kChunkOffset);else this.setPNC1(positions, colors, normals, i, normal, color, ax, ay, az, bx, by, bz, cx, cy, cz, pA, pB, pC, ab, cb, iChunkOffset, jChunkOffset, kChunkOffset); // UVs H1\n\n        offsetU = (normal ? txCoords[1][0] : txCoords[4][0]) * 0.0625;\n        offsetV = (normal ? txCoords[1][1] : txCoords[4][1]) * 0.0625;\n        uvs[uvi] = offsetU + (normal ? 0.0625 - eps : eps);\n        uvs[uvi + 1] = offsetV + eps;\n        uvs[uvi + 2] = offsetU + (normal ? eps : 0.0625 - eps);\n        uvs[uvi + 3] = offsetV + (normal ? eps : 0.0625 - eps);\n        uvs[uvi + 4] = offsetU + (normal ? eps : 0.0625 - eps);\n        uvs[uvi + 5] = offsetV + (normal ? 0.0625 - eps : eps);\n        if (rotate) this.setPNC2(positions, colors, normals, i, normal, color, bx, by, bz, dx, dy, dz, ax, ay, az, pA, pB, pC, ab, cb, iChunkOffset, jChunkOffset, kChunkOffset);else this.setPNC2(positions, colors, normals, i, normal, color, ax, ay, az, cx, cy, cz, dx, dy, dz, pA, pB, pC, ab, cb, iChunkOffset, jChunkOffset, kChunkOffset); // UVs H2\n\n        uvs[uvi + 6] = offsetU + (normal ? 0.0625 - eps : eps);\n        uvs[uvi + 7] = offsetV + eps;\n        uvs[uvi + 8] = offsetU + eps;\n        uvs[uvi + 9] = offsetV + 0.0625 - eps;\n        uvs[uvi + 10] = offsetU + 0.0625 - eps;\n        uvs[uvi + 11] = offsetV + 0.0625 - eps;\n      } else // K\n      {\n        faceId -= 2 * ijkS;\n        ii = faceId % iS;\n        jj = (faceId - ii) % ijS / iS; // % > /\n\n        kk = Math.floor(faceId / ijS);\n        ax = iChunkOffset + ii;\n        ay = jChunkOffset + jj;\n        az = kChunkOffset + 1 + kk;\n        bx = ax;\n        by = ay + 1;\n        bz = az;\n        cx = ax + 1;\n        cy = ay + 1;\n        cz = az;\n        dx = ax + 1;\n        dy = ay;\n        dz = az;\n        if (rotate) this.setPNC1(positions, colors, normals, i, normal, color, bx, by, bz, cx, cy, cz, dx, dy, dz, pA, pB, pC, ab, cb, iChunkOffset, jChunkOffset, kChunkOffset);else this.setPNC1(positions, colors, normals, i, normal, color, ax, ay, az, bx, by, bz, cx, cy, cz, pA, pB, pC, ab, cb, iChunkOffset, jChunkOffset, kChunkOffset); // UVs H1\n\n        offsetU = (normal ? txCoords[2][0] : txCoords[5][0]) * 0.0625;\n        offsetV = (normal ? txCoords[2][1] : txCoords[5][1]) * 0.0625;\n        uvs[uvi] = offsetU + eps;\n        uvs[uvi + 1] = offsetV + eps;\n        uvs[uvi + 2] = offsetU + (normal ? eps : 0.0625 - eps);\n        uvs[uvi + 3] = offsetV + 0.0625 - eps;\n        uvs[uvi + 4] = offsetU + (normal ? 0.0625 - eps : eps);\n        uvs[uvi + 5] = offsetV + 0.0625 - eps;\n        if (rotate) this.setPNC2(positions, colors, normals, i, normal, color, bx, by, bz, dx, dy, dz, ax, ay, az, pA, pB, pC, ab, cb, iChunkOffset, jChunkOffset, kChunkOffset);else this.setPNC2(positions, colors, normals, i, normal, color, ax, ay, az, cx, cy, cz, dx, dy, dz, pA, pB, pC, ab, cb, iChunkOffset, jChunkOffset, kChunkOffset); // UVs H2\n\n        uvs[uvi + 6] = offsetU + eps;\n        uvs[uvi + 7] = offsetV + eps;\n        uvs[uvi + 8] = offsetU + 0.0625 - eps;\n        uvs[uvi + 9] = offsetV + (normal ? 0.0625 - eps : eps);\n        uvs[uvi + 10] = offsetU + 0.0625 - eps;\n        uvs[uvi + 11] = offsetV + (normal ? eps : 0.0625 - eps);\n      }\n\n    for (j = 0; j < 18; ++j) {\n      if (isNaN(positions[i + j])) {\n        console.log("Transferred miscalculation on ".concat(i, "th component.") + "\\tnormal: ".concat(normal, "\\n") + "\\tfaceId: ".concat(faceId));\n        return;\n      }\n    }\n  }\n};\n\n// EXTERNAL MODULE: ./node_modules/three/src/renderers/shaders/ShaderLib.js + 135 modules\nvar ShaderLib = __webpack_require__(23);\n\n// EXTERNAL MODULE: ./node_modules/three/src/renderers/shaders/UniformsUtils.js\nvar UniformsUtils = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/portal/portal.fragment.glsl\n/* harmony default export */ var portal_fragment = ("uniform sampler2D texture1;\\n\\nvarying vec4 pos_frag;\\n\\nvoid main() {\\n\\n   vec2 ratio = pos_frag.xy / pos_frag.w;\\n   vec2 correctedUv = (ratio + vec2(1.0)) * 0.5;\\n\\n   gl_FragColor = texture2D(texture1, correctedUv);\\n}\\n");\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/portal/portal.vertex.glsl\n/* harmony default export */ var portal_vertex = ("varying vec4 pos_frag;\\n\\nvoid main() {\\n\\n   pos_frag = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\n   gl_Position = pos_frag;\\n}\\n");\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/sword/trail.vertex.glsl\n/* harmony default export */ var trail_vertex = ("/* To use with RingBufferGeometry */\\n\\nuniform float time;\\nvarying vec2 vUv;\\nvarying vec3 vPosition;\\nvoid main()\\n{\\n    vPosition = position;\\n    vUv = uv;\\n\\n    vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\\n    gl_Position = projectionMatrix * modelViewPosition;\\n}\\n");\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/sword/trail.fragment.glsl\n/* harmony default export */ var trail_fragment = ("/* To use with RingBufferGeometry */\\n/* Example:\\nvar ringGeometry = new THREE.RingBufferGeometry(\\n    5, 13, 20, 1, 0, Math.PI\\n);\\nvar material = new THREE.ShaderMaterial({\\n    uniforms: {\\n        time: { value: 1.0 },\\n        outerRadius: { value: 13.0 },\\n        innerRadius: { value: 5.0 }\\n    },\\n    vertexShader: document.getElementById(\'vertexShader\').textContent,\\n    fragmentShader: document.getElementById(\'fragmentShader\').textContent,\\n    side: THREE.DoubleSide,\\n    transparent: true\\n});\\n// Time from 0. to 1.: ring appears\\n// Time from 1. to 2.: inner ring continues to spin\\n// Linear time interpolation.\\n*/\\n\\nuniform float time;\\nuniform float outerRadius;\\nuniform float innerRadius;\\nvarying vec3 vPosition;\\nvarying vec2 vUv;\\nconst float PI = 3.1415926535897932384626433832795;\\n\\n// Same noise fn as usual\\nfloat rand(vec2 n)\\n{\\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\\n}\\n\\n// From https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\\nfloat noise(vec2 p)\\n{\\n    vec2 ip = floor(p);\\n    vec2 u = fract(p);\\n    u = u * u * (3.0 - 2.0 * u);\\n    float res = mix(\\n        mix(\\n            rand(ip),\\n            rand(ip + vec2(1.0, 0.0)),\\n            u.x\\n        ),\\n        mix(\\n            rand(ip + vec2(0.0, 1.0)),\\n            rand(ip + vec2(1.0, 1.0)),\\n            u.x\\n        ),\\n        u.y\\n    );\\n    return res*res;\\n}\\n\\n// Sekiro inspired\\nvoid main()\\n{\\n    float x = vPosition.x;\\n    float y = vPosition.y;\\n    float opacity = 1.0;\\n\\n    float ringWidth = outerRadius - innerRadius;\\n    float dist = distance(vPosition.xy, vec2(0.0));\\n    float distanceFromTop = (outerRadius - dist) / ringWidth;\\n\\n    float numberOfStripes = 7.0;\\n    float stripeWidth = ringWidth / numberOfStripes;\\n    float distanceFromTopI = (outerRadius - stripeWidth - dist) / (ringWidth - stripeWidth);\\n\\n    float stripeId = floor(mod(distanceFromTop * numberOfStripes, numberOfStripes));\\n\\n    float isOuterStripe = step(stripeId, 0.0);\\n\\n    float multStripe = 1.0 * PI; // 0.1 * isOuterStripe;\\n    float angle = atan(y, x);\\n    float distanceFromStart = angle + clamp(time * multStripe, 0.0, PI - 0.32) + 0.0; //+ offsetStripe;\\n\\n    float isHead = step(distanceFromStart, PI);\\n    float isTail = step(PI - angle, 0.32);\\n\\n    // opacity = sin(PI * fract(distanceFromTop * numberOfStripes));\\n    opacity = 1.0;\\n\\n    float d = distanceFromStart / PI;\\n    float edge = 0.9;\\n    d = 1.0 - max(d - edge, 0.0) / (1.0 - edge);\\n    float isIn = step(0.0, d - edge - 0.1);\\n    opacity -= isHead * d * d; // * sin(PI * fract(distanceFromStart));\\n    opacity -= isHead * isOuterStripe * d * d;\\n    float d2 = 1.0 - (PI - angle) / 0.32;\\n    opacity -= isTail * pow(d2 * d2, 4.0);\\n\\n    float smoothOuterStripeEdges = 1.0 - sin(PI * fract(distanceFromTop * numberOfStripes));\\n    opacity -= isOuterStripe * smoothOuterStripeEdges;\\n\\n    float chi = sin(PI * fract((distanceFromTopI) * (1.0)));\\n    // x3 e-x/2\\n    //float chi = 1.0 - fract((distanceFromTopI) * (1.0));\\n    //chi = pow(chi, 3.0) * exp(-chi * chi);\\n    float smoothSecondStripeEdges = 1.0 - pow(chi, 0.5);\\n    opacity -= (1.0 - isOuterStripe) * (smoothSecondStripeEdges + 0.2);\\n\\n    opacity -= (1.0 - isIn) * (1.0 - isOuterStripe) *\\n        noise(vec2(\\n            distanceFromTop * ringWidth * 9.0,\\n            (distanceFromStart + clamp(time * multStripe - PI + 0.4, 0.0, PI)) * 2.0\\n        ));\\n\\n    gl_FragColor = vec4(1.0, 1.0, 1.0, opacity);\\n}\\n");\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/sky/skyFlat.fragment.glsl\n/* harmony default export */ var skyFlat_fragment = ("precision mediump float;\\n\\nvarying vec3 vWorldPosition;\\nvarying vec3 vSunDirection;\\nvarying float vSunfade;\\nvarying vec3 vBetaR;\\nvarying vec3 vBetaM;\\nvarying float vSunE;\\n\\nuniform float luminance;\\nuniform float mieDirectionalG;\\nconst vec3 up = vec3(0.0, 0.0, 1.0);\\n\\nconst vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\\n\\n// constants for atmospheric scattering\\nconst float pi = 3.141592653589793238462643383279502884197169;\\n\\n// optical length at zenith for molecules\\nconst float rayleighZenithLength = 8.4E3;\\nconst float mieZenithLength = 1.25E3;\\n// 66 arc seconds -> degrees, and the cosine of that\\nconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\\n\\nconst float THREE_OVER_SIXTEENPI = 0.05968310365946075;\\nconst float ONE_OVER_FOURPI = 0.07957747154594767;\\n\\nfloat random(vec2 st) {\\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\\n}\\n\\nfloat rayleighPhase( float cosTheta ) {\\n    return THREE_OVER_SIXTEENPI * ( 1.0 + pow( abs(cosTheta), 2.0 ) );\\n}\\n\\nfloat hgPhase( float cosTheta, float g ) {\\n    float g2 = pow( abs(g), 2.0 );\\n    float inverse = 1.0 / pow( abs(1.0 - 2.0 * g * cosTheta + g2), 1.5 );\\n    return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\\n}\\n\\n// Filmic ToneMapping http://filmicgames.com/archives/75\\nconst float A = 0.15;\\nconst float B = 0.50;\\nconst float C = 0.10;\\nconst float D = 0.20;\\nconst float E = 0.02;\\nconst float F = 0.30;\\n\\nconst float whiteScale = 1.0748724675633854; // 1.0 / Uncharted2Tonemap(1000.0)\\n\\nvec3 Uncharted2Tonemap( vec3 x ) {\\n    return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;\\n}\\n\\n\\nvoid main() {\\n\\n    vec3 direction = normalize( vWorldPosition - cameraPos );\\n\\n// night starry sky\\n    bool closeToHorizon = false;\\n    float vse = vSunE;\\n    float fafa = 100.0;\\n    float fdx = floor(direction.x * fafa + 0.5);\\n    float fdy = floor(direction.y * fafa + 0.5);\\n    float fdz = floor(direction.z * fafa + 0.5);\\n    float d = distance(direction, (1.0 / fafa) * (vec3(fdx, fdy, fdz)));\\n    float proba = random(vec2(fdx * fdz, fdy));\\n    float probaMax = mix(0.05, 0.00, 0.001 * vSunE);\\n    float dMax = mix(0.002, 0.00, 0.001 * vSunE);\\n    if (d < dMax && proba < probaMax && direction.z > 0.0) {\\n        // if (d < 0.002 && proba < 0.05) // from 0.05 to 0.005\\n    \\tvse = max(vSunE, 20.0 * proba * 500.0);\\n    \\tcloseToHorizon = vSunDirection.z < 0.1; // ? 0.1 - vSunDirection.y : 0.0;\\n    }\\n\\n// optical length\\n// cutoff angle at 90 to avoid singularity in next formula.\\n    float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\\n    float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( abs(93.885 - ( ( zenithAngle * 180.0 ) / pi )), -1.253 ) );\\n    float sR = rayleighZenithLength * inverse;\\n    float sM = mieZenithLength * inverse;\\n\\n// combined extinction factor\\n    vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\\n\\n// in scattering\\n    float cosTheta = dot( direction, vSunDirection );\\n\\n    float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\\n    vec3 betaRTheta = vBetaR * rPhase;\\n\\n    float mPhase = hgPhase( cosTheta, mieDirectionalG );\\n    vec3 betaMTheta = vBetaM * mPhase;\\n\\n    vec3 Lin = pow( abs(vse * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex )), vec3( 1.5 ) );\\n    Lin *= mix(\\n        vec3( 1.0 ),\\n        pow( abs(vse * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex),\\n        vec3( 1.0 / 2.0 ) ),\\n        clamp( pow( abs(1.0 - dot( up, vSunDirection )), 5.0 ), 0.0, 1.0 )\\n    );\\n\\n// nightsky\\n    vec3 L0 = vec3( 0.1 ) * Fex;\\n\\n// composition + solar disc\\n    float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\\n    L0 += ( vse * 19000.0 * Fex ) * sundisk;\\n\\n    vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\\n\\n    vec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( abs(luminance), 4.0 ) ) ) * texColor );\\n    vec3 color = curr * whiteScale;\\n\\n    vec3 retColor = pow( abs(color), vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\\n\\n// starry sky colorfix\\n    if (closeToHorizon) {\\n        float mean = (retColor.x + retColor.y + retColor.z) / 3.0;\\n        retColor = vec3(mean);\\n    }\\n\\n\\tgl_FragColor = vec4( retColor, 1.0 );\\n\\n    // quick dithering pass\\n    vec3 vp = vSunDirection; // normalize(vWorldPosition);\\n    float noise = random(vp.xy);\\n    float m = mix(-0.5 / 255.0, 0.5 / 255.0, noise);\\n    gl_FragColor.rgb += 1.0 * vec3(m);\\n}\\n");\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/sky/skyFlat.vertex.glsl\n/* harmony default export */ var skyFlat_vertex = ("precision mediump float;\\n\\nuniform vec3 sunPosition;\\nuniform float rayleigh;\\nuniform float turbidity;\\nuniform float mieCoefficient;\\nconst vec3 up = vec3(0.0, 0.0, 1.0);\\n\\nvarying vec3 vWorldPosition;\\nvarying vec3 vSunDirection;\\nvarying float vSunfade;\\nvarying vec3 vBetaR;\\nvarying vec3 vBetaM;\\nvarying float vSunE;\\n\\n// constants for atmospheric scattering\\nconst float e = 2.71828182845904523536028747135266249775724709369995957;\\n//const float pi = 3.141592653589793238462643383279502884197169;\\n\\n// wavelength of used primaries, according to preetham\\n//const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\\n// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\\n// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\\nconst vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\\n\\n// mie stuff\\n// K coefficient for the primaries\\n//const float v = 4.0;\\n//const vec3 K = vec3( 0.686, 0.678, 0.666 );\\n// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\\nconst vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\\n\\n// earth shadow hack\\n// cutoffAngle = pi / 1.95;\\nconst float cutoffAngle = 1.6110731556870734;\\nconst float steepness = 1.5;\\nconst float EE = 1000.0;\\n\\nfloat sunIntensity( float zenithAngleCos ) {\\n    zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\\n    return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\\n}\\n\\nvec3 totalMie( float T ) {\\n    float c = ( 0.2 * T ) * 10E-18;\\n    return 0.434 * c * MieConst;\\n}\\n\\nvoid main() {\\n\\n    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n    vWorldPosition = worldPosition.xyz;\\n\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n    gl_Position.z = gl_Position.w; // set z to camera.far\\n\\n    vSunDirection = normalize( sunPosition );\\n\\n    vSunE = sunIntensity( dot( vSunDirection, up ) );\\n\\n    vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\\n\\n    float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\\n\\n// extinction (absorbtion + out scattering)\\n// rayleigh coefficients\\n    vBetaR = totalRayleigh * rayleighCoefficient;\\n\\n// mie coefficients\\n    vBetaM = totalMie( turbidity ) * mieCoefficient;\\n}\\n");\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/sky/skyCube.fragment.glsl\n/* harmony default export */ var skyCube_fragment = ("precision mediump float;\\n\\nvarying vec3 cps[8];\\nvarying vec3 cps2[8];\\n\\nvarying vec3 vWorldPosition;\\nvarying vec3 vSunDirection;\\nvarying float vSunfade;\\nvarying vec3 vBetaR;\\nvarying vec3 vBetaM;\\nvarying vec3 vCenter;\\n\\nuniform float luminance;\\nuniform float mieDirectionalG;\\n\\n//const vec3 cameraPos = vec3(0.0, 0.0, 0.0);\\nuniform vec3 cameraPos;\\nconst vec3 worldCenter = vec3(-100.0, 100.0, 50.0);\\n\\n// constants for atmospheric scattering\\nconst float pi = 3.141592653589793238462643383279502884197169;\\n\\n// optical length at zenith for molecules\\nconst float rayleighZenithLength = 8.4E3;\\nconst float mieZenithLength = 1.25E3;\\n//const vec3 up = vec3(0.0, 0.0, 1.0);\\n\\n// 66 arc seconds -> degrees, and the cosine of that\\nconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\\n\\n// 3.0 / ( 16.0 * pi )\\nconst float THREE_OVER_SIXTEENPI = 0.05968310365946075;\\n// 1.0 / ( 4.0 * pi )\\nconst float ONE_OVER_FOURPI = 0.07957747154594767;\\n\\nfloat rayleighPhase(float cosTheta) {\\n    return THREE_OVER_SIXTEENPI * (1.0 + pow(abs(cosTheta), 2.0));\\n}\\n\\nfloat hgPhase(float cosTheta, float g) {\\n    float g2 = pow(abs(g), 2.0);\\n    float inverse = 1.0 / pow(abs(1.0 - 2.0 * g * cosTheta + g2), 1.5);\\n    return ONE_OVER_FOURPI * ((1.0 - g2) * inverse);\\n}\\n\\nfloat random(vec2 st) {\\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\\n}\\n\\n// Filmic ToneMapping http://filmicgames.com/archives/75\\nconst float A = 0.15;\\nconst float B = 0.50;\\nconst float C = 0.10;\\nconst float D = 0.20;\\nconst float E = 0.02;\\nconst float F = 0.30;\\n\\nconst float whiteScale = 1.0748724675633854; // 1.0 / Uncharted2Tonemap(1000.0)\\n\\nvec3 Uncharted2Tonemap( vec3 x ) {\\n    return\\n        (\\n            (x * (A * x + C * B) + D * E) /\\n            (x * (A * x + B) + D * F )\\n        ) - E / F;\\n}\\n\\nconst float e = 2.71828182845904523536028747135266249775724709369995957;\\nconst float cutoffAngle = 1.6110731556870734; // HERE hack\\nconst float steepness = 2.5; // HERE hack\\nconst float EE = 10000.0; // HERE hack\\nfloat sunIntensity(float zenithAngleCos) {\\n    zenithAngleCos = clamp(zenithAngleCos, -1.0, 1.0);\\n    return EE * max(0.0, 1.0 - pow(abs(e), -((cutoffAngle - acos(zenithAngleCos)) / steepness)));\\n}\\n\\nbool doesCLieOnTheRightOfAB(vec2 a, vec2 b, vec2 c) {\\n    return (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y) > 0.0;\\n}\\n\\n// a = origin\\nbool isInsideAngle(vec2 x, vec2 a, vec2 b, vec2 c) {\\n    // dot1 = dot(x, b);\\n    // dot2 = dot(x, c);\\n    // if (dot1 < 0.0 || dot2 < 0.0) return false; // discard inverted angles\\n\\n    float dot1 = dot(vec3(0.0, 0.0, 1.0), cross(vec3(b, 0.0), vec3(b - c, 0.0)));\\n    bool invert = dot1 > 0.0;\\n\\n    bool rightAB = doesCLieOnTheRightOfAB(a, b, x);\\n    bool rightAC = doesCLieOnTheRightOfAB(a, c, x);\\n    return invert ? (!rightAB && rightAC) : (rightAB && !rightAC);\\n}\\n\\nfloat distanceTo2DIntersection(vec2 x, vec2 origin, vec2 a, vec2 b) {\\n    // x * p = a + q * b\\n    // (x*p, y*p) = (a.x + q*b.x, a.y, q*b.y)\\n    // x*p = a.x + q*b.x\\n    // y*p = a.y + q*b.y\\n    vec2 o = origin;\\n    float x1 = o.x;\\n    float y1 = o.y;\\n    float x2 = x.x;\\n    float y2 = x.y;\\n\\n    float x3 = a.x;\\n    float y3 = a.y;\\n    float x4 = b.x;\\n    float y4 = b.y;\\n\\n    // Using determinants.\\n    float y1my2 = y1 - y2; float y3my4 = y3 - y4;\\n    float x1mx2 = x1 - x2; float x3mx4 = x3 - x4;\\n    float den = x1mx2 * y3my4 - y1my2 * x3mx4;\\n    if (den == 0.0 || abs(den) <= 0.00001) return -1.0;\\n\\n    float n1 = x1 * y2 - y1 * x2;\\n    float n2 = x3 * y4 - y3 * x4;\\n    float num1 = n1 * (x3mx4) - n2 * (x1mx2);\\n    float num2 = n1 * (y3my4) - n2 * (y1my2);\\n    vec2 res = vec2(num1 / den, num2 / den);\\n\\n    float dx = res.x - o.x;\\n    float dy = res.y - o.y;\\n\\n    return (dx * dx + dy * dy);\\n}\\n\\n// PERF [VXS] flag stands for temporary code for\\n// using vertices instead of the neighbor edge lookup\\nvoid main()\\n{\\n    vec3 cpp = cameraPos;\\n    vec3 deltaWorldCamera = normalize(vWorldPosition - cpp);\\n\\n    vec3 vc = normalize(vCenter);\\n    vec3 vp = normalize(vWorldPosition);\\n    vec3 diff;\\n\\n    // Compupte projection plane.\\n    vec3 midPoint = 0.5 * (cps[0] + cps[1]);\\n    vec3 dpv = midPoint - vc * dot(midPoint, vc);\\n    vec3 xVector = dpv;\\n    vec3 yVector = cross(xVector, vc);\\n\\n    // Project cube on 2D plane.\\n    vec2 xys[8];\\n    vec2 dpc2D2;\\n    vec2 dpv2D2;\\n    dpc2D2 = vec2(dot(vCenter, xVector), dot(vCenter, yVector));\\n    dpv2D2 = vec2(dot(vWorldPosition, xVector), dot(vWorldPosition, yVector));\\n    for (int i = 0; i < 8; ++i) {\\n        xys[i] = vec2(dot(cps[i], xVector), dot(cps[i], yVector));\\n    }\\n\\n    // Quadratically determine best segments.\\n    vec2 bestA;\\n    vec2 bestB;\\n    vec3 bestCPA;\\n    vec3 bestCPB;\\n    float tempDistance = -1.0;\\n\\n    float newDistance;\\n    if (isInsideAngle(dpv2D2, dpc2D2, xys[0], xys[1]) && (newDistance =\\n        distanceTo2DIntersection(dpv2D2, dpc2D2, xys[0], xys[1])) > tempDistance) {\\n        bestA = xys[0]; bestB = xys[1];\\n        bestCPA = cps2[0]; bestCPB = cps2[1];\\n        tempDistance = newDistance;\\n    }\\n    if (isInsideAngle(dpv2D2, dpc2D2, xys[0], xys[2]) && (newDistance =\\n        distanceTo2DIntersection(dpv2D2, dpc2D2, xys[0], xys[2])) > tempDistance) {\\n        bestA = xys[0]; bestB = xys[2];\\n        bestCPA = cps2[0]; bestCPB = cps2[2];\\n        tempDistance = newDistance;\\n    }\\n    if (isInsideAngle(dpv2D2, dpc2D2, xys[1], xys[3]) && (newDistance =\\n        distanceTo2DIntersection(dpv2D2, dpc2D2, xys[1], xys[3])) > tempDistance) {\\n        bestA = xys[1]; bestB = xys[3];\\n        bestCPA = cps2[1]; bestCPB = cps2[3];\\n        tempDistance = newDistance;\\n    }\\n    if (isInsideAngle(dpv2D2, dpc2D2, xys[2], xys[3]) && (newDistance =\\n        distanceTo2DIntersection(dpv2D2, dpc2D2, xys[2], xys[3])) > tempDistance) {\\n        bestA = xys[2]; bestB = xys[3];\\n        bestCPA = cps2[2]; bestCPB = cps2[3];\\n        tempDistance = newDistance;\\n    }\\n    if (isInsideAngle(dpv2D2, dpc2D2, xys[4], xys[5]) && (newDistance =\\n        distanceTo2DIntersection(dpv2D2, dpc2D2, xys[4], xys[5])) > tempDistance) {\\n        bestA = xys[4]; bestB = xys[5];\\n        bestCPA = cps2[4]; bestCPB = cps2[5];\\n        tempDistance = newDistance;\\n    }\\n    if (isInsideAngle(dpv2D2, dpc2D2, xys[4], xys[6]) && (newDistance =\\n        distanceTo2DIntersection(dpv2D2, dpc2D2, xys[4], xys[6])) > tempDistance) {\\n        bestA = xys[4]; bestB = xys[6];\\n        bestCPA = cps2[4]; bestCPB = cps2[6];\\n        tempDistance = newDistance;\\n    }\\n    if (isInsideAngle(dpv2D2, dpc2D2, xys[5], xys[7]) && (newDistance =\\n        distanceTo2DIntersection(dpv2D2, dpc2D2, xys[5], xys[7])) > tempDistance) {\\n        bestA = xys[5]; bestB = xys[7];\\n        bestCPA = cps2[5]; bestCPB = cps2[7];\\n        tempDistance = newDistance;\\n    }\\n    if (isInsideAngle(dpv2D2, dpc2D2, xys[6], xys[7]) && (newDistance =\\n        distanceTo2DIntersection(dpv2D2, dpc2D2, xys[6], xys[7])) > tempDistance) {\\n        bestA = xys[6]; bestB = xys[7];\\n        bestCPA = cps2[6]; bestCPB = cps2[7];\\n        tempDistance = newDistance;\\n    }\\n    if (isInsideAngle(dpv2D2, dpc2D2, xys[0], xys[4]) && (newDistance =\\n        distanceTo2DIntersection(dpv2D2, dpc2D2, xys[0], xys[4])) > tempDistance) {\\n        bestA = xys[0]; bestB = xys[4];\\n        bestCPA = cps2[0]; bestCPB = cps2[4];\\n        tempDistance = newDistance;\\n    }\\n    if (isInsideAngle(dpv2D2, dpc2D2, xys[1], xys[5]) && (newDistance =\\n        distanceTo2DIntersection(dpv2D2, dpc2D2, xys[1], xys[5])) > tempDistance) {\\n        bestA = xys[1]; bestB = xys[5];\\n        bestCPA = cps2[1]; bestCPB = cps2[5];\\n        tempDistance = newDistance;\\n    }\\n    if (isInsideAngle(dpv2D2, dpc2D2, xys[2], xys[6]) && (newDistance =\\n        distanceTo2DIntersection(dpv2D2, dpc2D2, xys[2], xys[6])) > tempDistance) {\\n        bestA = xys[2]; bestB = xys[6];\\n        bestCPA = cps2[2]; bestCPB = cps2[6];\\n        tempDistance = newDistance;\\n    }\\n    if (isInsideAngle(dpv2D2, dpc2D2, xys[3], xys[7]) && (newDistance =\\n        distanceTo2DIntersection(dpv2D2, dpc2D2, xys[3], xys[7])) > tempDistance) {\\n        bestA = xys[3]; bestB = xys[7];\\n        bestCPA = cps2[3]; bestCPB = cps2[7];\\n        // tempDistance = newDistance;\\n    }\\n\\n    // Get nearest cube vertex.\\n    float dotNA = dot(normalize(bestA), dpv2D2);\\n    float dotNB = dot(normalize(bestB), dpv2D2);\\n    bool whichOne = dotNA > dotNB;\\n    vec2 iE = whichOne ? bestA : bestB;\\n    vec2 iE2 = whichOne ? bestB : bestA;\\n\\n    // Determine neighbor of best segment.\\n    vec2 neighborSegment = iE + 0.1 * (iE - iE2);\\n        // this vector should be inside the neighbor\'s angle\\n        // (2019-03[madblade] or is this wrong?)\\n        // (2019-03[madblade] if it is, switch to the ugly but more efficient interp using the best vertex)\\n    vec2 bestNeighborProjected;\\n    vec3 bestCPNeighbor;\\n    tempDistance = -1.0;\\n    for (int i = 0; i < 8; ++i) {\\n        vec2 other = xys[i];\\n        if (isInsideAngle(neighborSegment, dpc2D2, iE, other)) {\\n            newDistance = distanceTo2DIntersection(neighborSegment, dpc2D2, iE, other);\\n            if (newDistance > tempDistance) {\\n                bestNeighborProjected = xys[i];\\n                bestCPNeighbor = cps2[i];\\n                tempDistance = newDistance;\\n            }\\n        }\\n    }\\n\\n    vec2 interpolatorEnd = normalize(iE);\\n    float dotEV = dot(interpolatorEnd, normalize(dpv2D2));\\n    vec2 middle = 0.5 * (bestA + bestB);\\n    float dotES = dot(interpolatorEnd, normalize(middle));\\n    float interpolatorFactor = 0.0;\\n\\n    // Tweak this function for smoothing the interp at the cube angles.\\n    float start = 0.9;\\n    float ceiler = 1.0 / (1.0 - start);\\n    float agreement = (dotEV - start) * ceiler;\\n    if (dotEV > start) {\\n        float increaseMe = 20.0; // HERE tweak (200 was default without terrain)\\n            // increase this to limit the range for interpolation\\n            // (causes sharper edges at cube vertices)\\n        interpolatorFactor = 0.5 * pow(abs(agreement), increaseMe);\\n        // PERF [VXS]\\n        // interpolatorFactor = 1.0 * pow(abs(agreement), 200.0);\\n    }\\n\\n    float iF = 1.0 * interpolatorFactor;\\n    // iF = 0.0; // (uncomment to discard interpolation, BAD! edges will be sharp)\\n\\n    {\\n        vec2 bestSegment = -bestA + bestB;\\n        vec3 verticalCros = cross(vec3(bestSegment, 0.0), vec3(0.0, 0.0, 1.0));\\n        bool whichOrientation = dot(vec2(verticalCros.x, verticalCros.y), bestB) > 0.0;\\n        float coeffOrientation = whichOrientation ? -1.0 : 1.0;\\n\\n        vec3 closestCP = whichOne ? bestCPA : bestCPB;\\n        vec3 bestEdge = cross(0.5 * (bestCPA + bestCPB), coeffOrientation * (bestCPA - bestCPB));\\n\\n        vec2 bestSegment2 = -bestNeighborProjected + iE;\\n        vec3 verticalCros2 = cross(vec3(bestSegment2, 0.0), vec3(0.0, 0.0, 1.0));\\n        bool whichOrientation2 = dot(vec2(verticalCros2.x, verticalCros2.y), iE) < 0.0;\\n        float coeffOrientation2 = whichOrientation2 ? -1.0 : 1.0;\\n        vec3 bestEdge2 = cross(0.5 * (closestCP + bestCPNeighbor), coeffOrientation2 * (closestCP - bestCPNeighbor));\\n\\n        diff = normalize(iF * normalize(bestEdge2) + (1.0 - iF) * normalize(bestEdge));\\n    }\\n\\n    // Change this coefficient for the sky gradient: 1.0 = sharp, 0.001 = smooth.\\n    float smoothCoefficient = 0.01; // HERE tweak (0.02 was default without terrain)\\n    vec3 nup = diff * smoothCoefficient;\\n\\n    // XXX check if needed to hack sun intensity from intersection (2019-03[madblade]: low priority)\\n    float lum = luminance;\\n    float vsf = vSunfade;\\n    float vse = sunIntensity(dot(vSunDirection, nup));\\n\\n    // optical length\\n    // cutoff angle at 90 to avoid singularity in next formula.\\n    // XXX zenith angle coefficient should be interpolated (2019-03[madblade]: huh?)\\n    float coeff = 50.0; // HERE tweak\\n    float dotUpDelta = coeff * dot(nup, deltaWorldCamera);\\n    float cutoff = max(0.0, dotUpDelta);\\n    //\\tfloat zenithAngle = acos(cutoff);\\n    // XXX find the right coeff before atan (2019-03[madblade]: whatever this means, not a priority)\\n    float zenithAngle = 1.05 * atan(-cutoff) + pi * 0.5;\\n    float inverse = 1.0 / (cos(zenithAngle) + 0.15 * pow(abs(93.885 - ((zenithAngle * 180.0) / pi)), -1.253));\\n    float sR = rayleighZenithLength * inverse;\\n    float sM = mieZenithLength * inverse;\\n\\n    // combined extinction factor\\n    vec3 Fex = exp(-(vBetaR * sR + vBetaM * sM));\\n\\n    // in scattering\\n    float cosTheta = dot(deltaWorldCamera, vSunDirection);\\n    float rPhase = rayleighPhase(cosTheta * 0.5 + 0.5);\\n    vec3 betaRTheta = vBetaR * rPhase;\\n    float mPhase = hgPhase(cosTheta, mieDirectionalG);\\n    vec3 betaMTheta = vBetaM * mPhase;\\n\\n    vec3 Lin = pow(abs(vse * ((betaRTheta + betaMTheta) / (vBetaR + vBetaM)) * (1.0 - Fex)), vec3(1.5));\\n    Lin *= mix(\\n        vec3(1.0),\\n        pow(abs(vse * ((betaRTheta + betaMTheta) / (vBetaR + vBetaM)) * Fex),\\n        vec3(1.0 / 2.0)),\\n        clamp(pow(abs(1.0 - dot(nup, vSunDirection)), 5.0), 0.0, 1.0)\\n    );\\n\\n    // nightsky\\n    vec3 L0 = vec3(0.1) * Fex;\\n\\n    // composition + solar disc\\n    float sundisk = smoothstep(sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta);\\n    L0 += (vse * 19000.0 * Fex) * sundisk;\\n    vec3 texColor = (Lin + L0) * 0.04 + vec3(0.0, 0.0003, 0.00075);\\n    vec3 curr = Uncharted2Tonemap((log2(2.0 / pow(abs(lum), 4.0))) * texColor);\\n    vec3 color = curr * whiteScale;\\n    vec3 retColor = pow(abs(color), vec3(1.0 / (1.2 + (1.2 * vsf))));\\n\\n    // Debug here:\\n    // retColor = vec3(1.0, debugBeta1, 0.0);\\n\\n    gl_FragColor = vec4(retColor, 1.0);\\n    // (the following displays center-to-cube-vertices lines in red)\\n    // for (int i = 0; i < 8; ++i) {\\n    //     if (distance(normalize(dpv2D2), normalize(xys2[i])) < 0.005)\\n    //         gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n    // }\\n\\n    // Dithering (removes gradient banding)\\n    // (there is still banding at 0.2 noise)\\n    float noise = random(vp.xy);\\n    float m = mix(-0.5 / 255.0, 0.5 / 255.0, noise);\\n    gl_FragColor.rgb += 3.0 * vec3(m);\\n}\\n");\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/sky/skyCube.vertex.glsl\n/* harmony default export */ var skyCube_vertex = ("precision mediump float;\\n\\nuniform vec3 sunPosition;\\nuniform float rayleigh;\\nuniform float turbidity;\\nuniform float mieCoefficient;\\nuniform vec3 cameraPos;\\n\\nvarying vec3 vWorldPosition;\\nvarying vec3 vSunDirection;\\nvarying float vSunfade;\\nvarying vec3 vBetaR;\\nvarying vec3 vBetaM;\\nvarying vec3 vCenter;\\n\\nvarying vec3 cps[8];\\nvarying vec3 cps2[8];\\n\\nuniform vec3 worldCenter; // = vec3(-100.0, 100.0, 50.0);\\nuniform float cubeRadius; // = 50.0;\\n//const vec3 up = vec3(0.0, 0.0, 1.0);\\n\\n// constants for atmospheric scattering\\n//const float e = 2.71828182845904523536028747135266249775724709369995957;\\n//const float pi = 3.141592653589793238462643383279502884197169;\\n\\n// wavelength of used primaries, according to preetham\\nconst vec3 lambda = vec3(680E-9, 550E-9, 450E-9);\\n// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\\n// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\\nconst vec3 totalRayleigh = vec3(5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5);\\n\\n// mie stuff\\n// K coefficient for the primaries\\n//const float v = 4.0;\\n//const vec3 K = vec3(0.686, 0.678, 0.666);\\n// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\\nconst vec3 MieConst = vec3(1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14);\\n\\n// earth shadow hack\\n// cutoffAngle = pi / 1.95;\\nconst float cutoffAngle = 1.6110731556870734;\\nconst float steepness = 1.5;\\nconst float EE = 1000.0;\\n\\nvec3 totalMie(float T) {\\n    float c = (0.2 * T) * 10E-18;\\n    return 0.434 * c * MieConst;\\n}\\n\\nvoid main()\\n{\\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\\n    vWorldPosition = worldPosition.xyz;\\n\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n    vCenter = (vec4(\\n        worldCenter.x - modelMatrix[3][0],\\n        worldCenter.y - modelMatrix[3][1],\\n        worldCenter.z - modelMatrix[3][2],\\n         1.0)).xyz;\\n\\n    gl_Position.z = gl_Position.w; // set z to camera.far\\n\\n    vSunDirection = normalize(sunPosition);\\n\\n//    float cubeRadius = 12.5;\\n//    cubeRadius *= 2.0;\\n\\n    // night\\n    vec3 centerToCamera = cameraPos - worldCenter;\\n    float cx = centerToCamera.x; float acx = abs(cx);\\n    float cy = centerToCamera.y; float acy = abs(cy);\\n    float cz = centerToCamera.z; float acz = abs(cz);\\n    bool isX = acx > acy && acx > acz;\\n    bool isY = acy > acx && acy > acz;\\n    bool isZ = !isX && !isY;\\n    vec3 nsp = normalize(sunPosition);\\n    float projection = isX ? sign(cx) * nsp.x : isY ? sign(cy) * nsp.y : sign(cz) * nsp.z;\\n//\\tvSunfade = 1.0 - clamp(1.0 - exp((sunPosition.y / 450000.0)), 0.0, 1.0);\\n//\\tvSunfade = 1.0 - clamp(1.0 - exp(projection / 150000.0), 0.0, 1.0);\\n    vSunfade = 1.0 - 1.0 * clamp(1.0 - exp(projection), 0.0, 1.0);\\n//    vSunfade = isZ ? 1.0 : 0.0;\\n\\n    float rayleighCoefficient = rayleigh - (1.0 * (1.0 - vSunfade));\\n\\n// extinction (absorbtion + out scattering)\\n// rayleigh coefficients\\n    vBetaR = totalRayleigh * rayleighCoefficient;\\n\\n// mie coefficients\\n    vBetaM = totalMie(turbidity) * mieCoefficient;\\n\\n// pass center coordinates\\n    vec3 center = vCenter;\\n    cps2[0] = center + vec3( cubeRadius,  cubeRadius,  cubeRadius);\\n    cps2[1] = center + vec3(-cubeRadius,  cubeRadius,  cubeRadius);\\n    cps2[2] = center + vec3( cubeRadius, -cubeRadius,  cubeRadius);\\n    cps2[3] = center + vec3(-cubeRadius, -cubeRadius,  cubeRadius);\\n    cps2[4] = center + vec3( cubeRadius,  cubeRadius, -cubeRadius);\\n    cps2[5] = center + vec3(-cubeRadius,  cubeRadius, -cubeRadius);\\n    cps2[6] = center + vec3( cubeRadius, -cubeRadius, -cubeRadius);\\n    cps2[7] = center + vec3(-cubeRadius, -cubeRadius, -cubeRadius);\\n\\n    // Deprojection (should not depend on fov or near/far planes).\\n    // Used for computing the right part of the projected convex hull.\\n    float near = 0.1;\\n    float far = 20000.0;\\n    float fmn = far - near;\\n    vec3 tcenter = normalize(vCenter);\\n    for (int i = 0; i < 8; ++i) {\\n        vec3 currentC = 1.0 * (cps2[i] - center) + center;\\n        float alpha = dot(currentC, tcenter);\\n        float beta = dot(normalize(currentC), normalize(tcenter));\\n        float R = beta < 0.1 ? fmn : fmn / alpha;\\n        vec3 yc = currentC - alpha * tcenter;\\n        cps[i] = currentC + yc * (R - 1.0);\\n    }\\n}\\n");\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/water/water.fragment.glsl\n/* harmony default export */ var water_fragment = ("uniform sampler2D mirrorSampler;\\nuniform float alpha;\\nuniform float time;\\nuniform float size;\\nuniform float distortionScale;\\nuniform sampler2D normalSampler;\\nuniform vec3 sunColor;\\nuniform vec3 sunDirection;\\nuniform vec3 eye;\\nuniform vec3 waterColor;\\n\\nvarying vec3 vNormal;\\nvarying float trueZ;\\n\\nvarying vec4 mirrorCoord;\\nvarying vec4 worldPosition;\\n\\nvec4 getNoise(vec2 uv) {\\n\\tvec2 uv0 = (uv / 103.0) + vec2(time / 17.0, time / 29.0);\\n\\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0);\\n\\tvec2 uv2 = uv / vec2(890.70, 980.30) + vec2(time / 101.0, time / 97.0);\\n\\tvec2 uv3 = uv / vec2(1091.0, 1027.0) - vec2(time / 109.0, time / -113.0);\\n\\tvec4 noise = texture2D(normalSampler, uv0) +\\n\\t\\ttexture2D(normalSampler, uv1) +\\n\\t\\ttexture2D(normalSampler, uv2) +\\n\\t\\ttexture2D(normalSampler, uv3);\\n\\n\\treturn noise * 0.5 - 1.0;\\n//\\treturn vec4(1, 1, 1, 1) * 0.5 - 1.0; // activate water normals here\\n}\\n\\nvoid sunLight(\\n    const vec3 surfaceNormal, const vec3 eyeDirection,\\n    float shiny, float spec, float diffuse,\\n    inout vec3 diffuseColor, inout vec3 specularColor)\\n{\\n\\tvec3 reflection = normalize( reflect(-sunDirection, surfaceNormal) );\\n\\tfloat direction = max( 0.0, dot(eyeDirection, reflection) );\\n\\tspecularColor += pow(abs(direction), shiny) * sunColor * spec;\\n\\tdiffuseColor += max( dot(sunDirection, surfaceNormal), 0.0 ) * sunColor * diffuse;\\n}\\n\\n//#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <lights_pars_begin>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n\\nvoid main() {\\n\\n    #include <logdepthbuf_fragment>\\n\\n\\tif (abs(trueZ - 16.0) < 0.01)\\n\\t{\\n\\t\\tvec4 noise = getNoise( worldPosition.xy * size );\\n\\t\\tvec3 surfaceNormal = normalize( noise.xyz * vec3( 1.5, 1.0, 1.5 ) ); // this for texture\\n\\n\\t\\tvec3 diffuseLight = vec3(0.0);\\n\\t\\tvec3 specularLight = vec3(0.0);\\n\\n\\t\\tvec3 worldToEye = eye - worldPosition.xyz;\\n\\t\\tvec3 eyeDirection = normalize( worldToEye );\\n\\t\\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\\n\\n\\t\\tfloat distance = length(worldToEye);\\n\\n\\t\\tvec2 distortion = surfaceNormal.xy * ( 0.001 + 1.0 / distance ) * distortionScale;\\n\\t\\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\\n\\n\\t\\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\\n\\t\\tfloat rf0 = 0.3;\\n\\t\\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( abs( 1.0 - theta ), 5.0 );\\n\\t\\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\\n\\t\\tvec3 albedo = mix(\\n\\t\\t( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(),\\n\\t\\t( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ),\\n\\t\\treflectance\\n\\t\\t);\\n\\t\\tvec3 outgoingLight = albedo;\\n\\t\\tgl_FragColor = vec4( outgoingLight, alpha );\\n\\t} else {\\n\\t\\tfloat fac = dot(vNormal, vec3(sunDirection.x, sunDirection.y, -sunDirection.z));\\n\\t\\tgl_FragColor = vec4(fac * waterColor, alpha);\\n\\t}\\n\\n    #include <tonemapping_fragment>\\n    #include <fog_fragment>\\n}\\n");\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/water/water.vertex.glsl\n/* harmony default export */ var water_vertex = ("\\nuniform mat4 textureMatrix;\\nuniform float time;\\n\\nvarying vec3 vNormal;\\nvarying float trueZ;\\n\\nvarying vec4 mirrorCoord;\\nvarying vec4 worldPosition;\\n\\n//#include <common>\\n#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n\\nvoid main()\\n{\\n    trueZ = position.z;\\n\\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\\n\\tworldPosition = mirrorCoord.xyzw;\\n\\tmirrorCoord = textureMatrix * mirrorCoord;\\n\\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\\n\\n    vNormal = normal;\\n    gl_Position = projectionMatrix * mvPosition;\\n\\n    #include <logdepthbuf_vertex>\\n    #include <fog_vertex>\\n    #include <shadowmap_vertex>\\n}\\n");\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/water/ocean.fragment.glsl\n/* harmony default export */ var ocean_fragment = ("uniform sampler2D mirrorSampler;\\nuniform float alpha;\\nuniform float time;\\nuniform float size;\\nuniform float distortionScale;\\nuniform sampler2D normalSampler;\\nuniform vec3 sunColor;\\nuniform vec3 sunDirection;\\nuniform vec3 eye;\\nuniform vec3 waterColor;\\nvarying vec3 vvnormal;\\nvarying vec4 mirrorCoord;\\nvarying vec4 worldPosition;\\n\\nvec4 getNoise(vec2 uv) {\\n    vec2 uv0 = (uv / 103.0) + vec2(time / 17.0, time / 29.0);\\n    vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0);\\n    vec2 uv2 = uv / vec2(890.70, 980.30) + vec2(time / 101.0, time / 97.0);\\n    vec2 uv3 = uv / vec2(1091.0, 1027.0) - vec2(time / 109.0, time / -113.0);\\n    vec4 noise = texture2D(normalSampler, uv0) +\\n    texture2D(normalSampler, uv1) +\\n    texture2D(normalSampler, uv2) +\\n    texture2D(normalSampler, uv3);\\n\\n    return noise * 0.5 - 1.0;\\n}\\n\\nvoid sunLight(\\nconst vec3 surfaceNormal, const vec3 eyeDirection,\\nfloat shiny, float spec, float diffuse,\\ninout vec3 diffuseColor, inout vec3 specularColor)\\n{\\n    vec3 reflection = normalize( reflect(-sunDirection, surfaceNormal) );\\n    float direction = max( 0.0, dot(eyeDirection, reflection) );\\n    specularColor += pow(abs(direction), shiny) * sunColor * spec;\\n    diffuseColor += max( dot(sunDirection, surfaceNormal), 0.0 ) * sunColor * diffuse;\\n}\\n\\n    //#include <common>\\n    #include <packing>\\n    #include <bsdfs>\\n    #include <fog_pars_fragment>\\n    #include <logdepthbuf_pars_fragment>\\n    #include <lights_pars_begin>\\n    #include <shadowmap_pars_fragment>\\n    #include <shadowmask_pars_fragment>\\n\\nvoid main() {\\n\\n    #include <logdepthbuf_fragment>\\n    //\\tvec4 noise = getNoise( worldPosition.xz * size );\\n    vec4 noise = getNoise( worldPosition.xy * size );\\n    //\\tvec3 surfaceNormal = normalize(vvnormal); //normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) ); // this for gerstner\\n    \\tvec3 surfaceNormal = normalize( vvnormal + noise.xzy * vec3( 1.5, 1.0, 1.5 ) ); // this for mix\\n    //  vec3 surfaceNormal = normalize( noise.xyz * vec3( 1.5, 1.0, 1.5 ) ); // this for texture\\n\\n    vec3 diffuseLight = vec3(0.0);\\n    vec3 specularLight = vec3(0.0);\\n\\n    vec3 worldToEye = eye - worldPosition.xyz;\\n    vec3 eyeDirection = normalize( worldToEye );\\n    sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\\n\\n    float distance = length(worldToEye);\\n\\n    vec2 distortion = surfaceNormal.xy * ( 0.001 + 1.0 / distance ) * distortionScale;\\n    vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\\n\\n    float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\\n    float rf0 = 0.3;\\n    float reflectance = rf0 + ( 1.0 - rf0 ) * pow( abs( 1.0 - theta ), 5.0 );\\n    vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\\n    vec3 albedo = mix(\\n    ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(),\\n    ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ),\\n    reflectance\\n    );\\n    vec3 outgoingLight = albedo;\\n    gl_FragColor = vec4( outgoingLight, alpha );\\n\\n    #include <tonemapping_fragment>\\n    #include <fog_fragment>\\n}\\n");\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/water/ocean.vertex.glsl\n/* harmony default export */ var ocean_vertex = ("\\nuniform mat4 textureMatrix;\\nuniform float time;\\n\\nvarying vec4 mirrorCoord;\\nvarying vec4 worldPosition;\\n\\nvarying vec3 vvnormal;\\n//#include <common>\\n#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n\\n// Ref. in GPU Gems 1\\n// https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-1-effective-water-simulation-physical-models\\nvec3 gerstnerPositions(float x, float y) {\\n    float ox = x;\\n    float oy = y;\\n    float oz = 0.0;\\n    const int nbWaves = 1;\\n    for (int i = 0; i < nbWaves; i++) {\\n        float frequencyI = 0.05; // wi\\n        float amplitudeI = 20.0; // Ai\\n        float steepnessI = 1.0 / (frequencyI * amplitudeI); // Qi from 0 to 1/wiAi\\n        vec2 directionI = normalize(vec2(1.0, 0.0));\\n        float phaseI = 1.0; // phiI\\n        ox += steepnessI * amplitudeI * directionI.x * cos(frequencyI * dot(directionI, vec2(x, y)) + phaseI * time);\\n        oy += steepnessI * amplitudeI * directionI.y * cos(frequencyI * dot(directionI, vec2(x, y)) + phaseI * time);\\n        oz += amplitudeI * sin(frequencyI * dot(directionI, vec2(x, y)) + phaseI * time);\\n    }\\n    return vec3(ox, oy, oz);\\n}\\n\\nvec3 gerstnerNormals(float x, float y, vec3 p) {\\n    float nx = 0.0;\\n    float ny = 0.0;\\n    float nz = 1.0;\\n    const int nbWaves = 1;\\n    for (int i = 0; i < nbWaves; i++) {\\n        float frequencyI = 0.05; // wi\\n        float amplitudeI = 20.0; // Ai\\n        float steepnessI = 1.0 / (frequencyI * amplitudeI); // Qi from 0 to 1/wiAi\\n        vec2 directionI = normalize(vec2(1.0, 0.0));\\n        float phaseI = 1.0; // phiI\\n        nx -= (directionI.x * frequencyI * amplitudeI * cos(frequencyI * dot(vec3(directionI, 0.0), p) + phaseI * time) );\\n        ny -= (directionI.y * frequencyI * amplitudeI * cos(frequencyI * dot(vec3(directionI, 0.0), p) + phaseI * time) );\\n        nz -= (steepnessI * frequencyI * amplitudeI * sin(frequencyI * dot(vec3(directionI, 0.0), p) + phaseI * time) );\\n\\n    }\\n    return vec3(nx, ny, nz);\\n}\\n\\nvoid main()\\n{\\n    mirrorCoord = modelMatrix * vec4( position, 1.0 );\\n    worldPosition = mirrorCoord.xyzw;\\n    mirrorCoord = textureMatrix * mirrorCoord;\\n    vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\\n\\n    // this is how to use gerstner\\n    vec3 newPo = gerstnerPositions(position.x, position.y);\\n    vec3 gn = gerstnerNormals(position.x, position.y, newPo);\\n    vvnormal = normalMatrix * gn;\\n    mvPosition = modelViewMatrix * vec4(newPo.x, newPo.y, newPo.z, 1.0);\\n\\n    gl_Position = projectionMatrix * mvPosition;\\n\\n    #include <logdepthbuf_vertex>\\n    #include <fog_vertex>\\n    #include <shadowmap_vertex>\\n}\\n");\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/postprocessing/bloom.selective.fragment.glsl\n/* harmony default export */ var bloom_selective_fragment = ("uniform sampler2D baseTexture;\\nuniform sampler2D bloomTexture;\\n\\nvarying vec2 vUv;\\n\\nvec4 getTexture(sampler2D texelToLinearTexture) {\\n    return mapTexelToLinear(texture2D(texelToLinearTexture, vUv));\\n}\\n\\nvoid main() {\\n    gl_FragColor = (getTexture(baseTexture) + vec4(1.0) * getTexture(bloomTexture));\\n}\\n");\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/postprocessing/bloom.selective.vertex.glsl\n/* harmony default export */ var bloom_selective_vertex = ("varying vec2 vUv;\\n\\nvoid main() {\\n    vUv = uv;\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n");\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/shadow/shadow.vertex.glsl\n/* harmony default export */ var shadow_vertex = ("// @author madblade\\n// MAKE SURE TOACTIVATETHE LOGDEPTHBUFFER\\n\\nuniform vec3 lightPosition;\\nuniform float bias;\\nuniform vec3 eyePosition;\\n\\nvarying vec3 vViewPosition;\\n\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\nvarying vec3 vLightBack;\\nvarying vec3 vIndirectBack;\\n#endif\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n    #include <uv_vertex>\\n    #include <uv2_vertex>\\n    #include <color_vertex>\\n    #include <beginnormal_vertex>\\n    #include <morphnormal_vertex>\\n    #include <skinbase_vertex>\\n    #include <skinnormal_vertex>\\n    #include <defaultnormal_vertex>\\n    #include <begin_vertex>\\n    #include <morphtarget_vertex>\\n    #include <skinning_vertex>\\n\\n    // #include <project_vertex>\\n    vec3 nn = objectNormal;\\n    vec3 translated = transformed;\\n    vec3 nlight = normalize(vec3(lightPosition.x, lightPosition.y + 0.2, lightPosition.z));\\n    float d = dot(normalize(nn), nlight);\\n\\n    float d2 = distance(eyePosition, translated);\\n    float dot2 = dot(nlight, vec3(0.0, 0.0, 1.0));\\n    bool allowed = dot2 > 0.01;\\n\\n    vec3 infty;\\n    if (allowed)\\n    {\\n        if (d < bias) {\\n            infty = translated - nlight * 10000000.0;\\n        } else {\\n            vec3 correction = nlight;\\n            infty = translated - correction * 0.01;\\n        }\\n    } else {\\n        infty = vec3(0);\\n    }\\n    translated = infty;\\n    vec4 mvPosition =  modelViewMatrix * vec4(translated, 1.0);\\n    gl_Position = projectionMatrix * mvPosition;\\n\\n    #include <logdepthbuf_vertex>\\n    #include <clipping_planes_vertex>\\n    #include <worldpos_vertex>\\n    #include <envmap_vertex>\\n    #include <lights_lambert_vertex>\\n    #include <shadowmap_vertex>\\n    #include <fog_vertex>\\n}\\n");\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/shadow/shadow.fragment.glsl\n/* harmony default export */ var shadow_fragment = ("\\nvoid main()\\n{\\n    gl_FragColor = vec4(1.0, 1.0, 1.0, 0.1);\\n}\\n");\n// CONCATENATED MODULE: ./client/app/engine/graphics/shaders/shaders.js\n/**\n *\n */\n // Portals\n\n\n // Effects\n\n\n // Sky\n\n\n\n\n // Water\n\n\n\n\n // Post-proc\n\n\n\n\n\nvar ShadersModule = {\n  // Portal\n  getPortalVertexShader: function getPortalVertexShader() {\n    return portal_vertex;\n  },\n  getPortalFragmentShader: function getPortalFragmentShader() {\n    return portal_fragment;\n  },\n  // Melee\n  getSwordTrailVertexShader: function getSwordTrailVertexShader() {\n    return trail_vertex;\n  },\n  getSwordTrailFragmentShader: function getSwordTrailFragmentShader() {\n    return trail_fragment;\n  },\n  // Sky\n  getSkyCubeVertexShader: function getSkyCubeVertexShader() {\n    return skyCube_vertex;\n  },\n  getSkyCubeFragmentShader: function getSkyCubeFragmentShader() {\n    return skyCube_fragment;\n  },\n  getSkyFlatVertexShader: function getSkyFlatVertexShader() {\n    return skyFlat_vertex;\n  },\n  getSkyFlatFragmentShader: function getSkyFlatFragmentShader() {\n    return skyFlat_fragment;\n  },\n  // Water\n  getWaterFragmentShader: function getWaterFragmentShader() {\n    return "\\n            #include <common>\\n            ".concat(water_fragment, "\\n        ");\n  },\n  getWaterVertexShader: function getWaterVertexShader() {\n    return "\\n            #include <common>\\n            ".concat(water_vertex, "\\n        ");\n  },\n  getOceanFragmentShader: function getOceanFragmentShader() {\n    return "\\n            #include <common>\\n            ".concat(ocean_fragment, "\\n        ");\n  },\n  getOceanVertexShader: function getOceanVertexShader() {\n    return "\\n            #include <common>\\n            ".concat(ocean_vertex, "\\n        ");\n  },\n  // Post-proc\n  getBloomSelectiveVertexShader: function getBloomSelectiveVertexShader() {\n    return bloom_selective_vertex;\n  },\n  getBloomSelectiveFragmentShader: function getBloomSelectiveFragmentShader() {\n    return bloom_selective_fragment;\n  },\n  getShadowVertexShader: function getShadowVertexShader() {\n    return "\\n            #include <common>\\n            ".concat(shadow_vertex, "\\n        ");\n  },\n  getShadowFragmentShader: function getShadowFragmentShader() {\n    return "\\n            ".concat(shadow_fragment, "\\n        ");\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/terrain/shadow.js\n// Adapted from https://github.com/gkjohnson/threejs-sandbox/tree/master/shadow-volumes\n\n\n\n\nvar shadow_v0 = new three_module["Sb" /* Vector3 */]();\nvar shadow_v1 = new three_module["Sb" /* Vector3 */]();\nvar v2 = new three_module["Sb" /* Vector3 */]();\nvar shadow_v01 = new three_module["Sb" /* Vector3 */]();\nvar v12 = new three_module["Sb" /* Vector3 */]();\nvar shadow_norm = new three_module["Sb" /* Vector3 */]();\n\nfunction getDynamicShadowVolumeGeometry(geometry, count) {\n  var shadowGeom = geometry.index ? geometry.toNonIndexed() : geometry.clone(); // Generate per-face normals\n\n  var posAttr = shadowGeom.getAttribute(\'position\');\n\n  if (count > posAttr.count) {\n    console.warn(\'inv geom count\');\n    return;\n  }\n\n  var posArr = [];\n  var normArr = [];\n\n  for (var i = 0, l = count; i < l; i += 3) {\n    shadow_v0.x = posAttr.getX(i);\n    shadow_v0.y = posAttr.getY(i);\n    shadow_v0.z = posAttr.getZ(i);\n    shadow_v1.x = posAttr.getX(i + 1);\n    shadow_v1.y = posAttr.getY(i + 1);\n    shadow_v1.z = posAttr.getZ(i + 1);\n    v2.x = posAttr.getX(i + 2);\n    v2.y = posAttr.getY(i + 2);\n    v2.z = posAttr.getZ(i + 2);\n    shadow_v01.subVectors(shadow_v0, shadow_v1);\n    v12.subVectors(shadow_v1, v2);\n    shadow_norm.crossVectors(shadow_v01, v12).normalize();\n    normArr.push(shadow_norm.x, shadow_norm.y, shadow_norm.z);\n    normArr.push(shadow_norm.x, shadow_norm.y, shadow_norm.z);\n    normArr.push(shadow_norm.x, shadow_norm.y, shadow_norm.z);\n    posArr.push(shadow_v0.x, shadow_v0.y, shadow_v0.z);\n    posArr.push(shadow_v1.x, shadow_v1.y, shadow_v1.z);\n    posArr.push(v2.x, v2.y, v2.z);\n  }\n\n  var indexArr = []; // 1. Front cap generation using the existing geometry\n\n  var addFrontCap = true;\n\n  if (addFrontCap) {\n    indexArr = new Array(count).fill().map(function (e, i) {\n      return i;\n    });\n  } // 2. Computing boundary edges\n\n\n  var edgeHash = new Map();\n\n  for (var _i = 0, _l = count; _i < _l; _i += 3) {\n    for (var j = 0; j < 3; j++) {\n      var e00 = _i + j;\n      var e01 = _i + (j + 1) % 3;\n      shadow_v0.x = posAttr.getX(e00);\n      shadow_v0.y = posAttr.getY(e00);\n      shadow_v0.z = posAttr.getZ(e00);\n      shadow_v1.x = posAttr.getX(e01);\n      shadow_v1.y = posAttr.getY(e01);\n      shadow_v1.z = posAttr.getZ(e01); // Diagonal edges dont need to be filled.\n\n      var del = (shadow_v0.x === shadow_v1.x) + (shadow_v0.y === shadow_v1.y) + (shadow_v0.z === shadow_v1.z);\n      if (del !== 2) continue; // Compute an edge hash (order by z, x, then y).\n\n      var hash = void 0;\n      if (shadow_v1.z !== shadow_v0.z) hash = shadow_v0.z < shadow_v1.z ? ~~shadow_v0.x + \',\' + ~~shadow_v0.y + \',\' + ~~shadow_v0.z + \',\' + ~~shadow_v1.x + \',\' + ~~shadow_v1.y + \',\' + ~~shadow_v1.z : ~~shadow_v1.x + \',\' + ~~shadow_v1.y + \',\' + ~~shadow_v1.z + \',\' + ~~shadow_v0.x + \',\' + ~~shadow_v0.y + \',\' + ~~shadow_v0.z;else if (shadow_v1.y !== shadow_v0.y) hash = shadow_v0.y < shadow_v1.y ? ~~shadow_v0.x + \',\' + ~~shadow_v0.y + \',\' + ~~shadow_v0.z + \',\' + ~~shadow_v1.x + \',\' + ~~shadow_v1.y + \',\' + ~~shadow_v1.z : ~~shadow_v1.x + \',\' + ~~shadow_v1.y + \',\' + ~~shadow_v1.z + \',\' + ~~shadow_v0.x + \',\' + ~~shadow_v0.y + \',\' + ~~shadow_v0.z;else if (shadow_v1.x !== shadow_v0.x) hash = shadow_v0.x < shadow_v1.x ? ~~shadow_v0.x + \',\' + ~~shadow_v0.y + \',\' + ~~shadow_v0.z + \',\' + ~~shadow_v1.x + \',\' + ~~shadow_v1.y + \',\' + ~~shadow_v1.z : ~~shadow_v1.x + \',\' + ~~shadow_v1.y + \',\' + ~~shadow_v1.z + \',\' + ~~shadow_v0.x + \',\' + ~~shadow_v0.y + \',\' + ~~shadow_v0.z; // Store edges.\n\n      var edges = edgeHash.get(hash);\n      if (edges) edges.push(e00, e01);else edgeHash.set(hash, [e00, e01]);\n    }\n  } // 3. Process edges to fill with new quads\n\n\n  var nbVerts = posArr.length / 3;\n  edgeHash.forEach(function (edges) {\n    var l = edges.length;\n    var nbEdges = l / 2;\n\n    if (nbEdges === 2) {\n      // 4 vertices = manifold edge.\n      var _e = edges[0];\n      var _e2 = edges[1];\n      var e10 = edges[2];\n      var e11 = edges[3];\n      var x1 = normArr[3 * _e];\n      var y1 = normArr[3 * _e + 1];\n      var z1 = normArr[3 * _e + 2];\n      var x2 = normArr[3 * e11];\n      var y2 = normArr[3 * e11 + 1];\n      var z2 = normArr[3 * e11 + 2]; // Edges between neighbour faces dont need a quad.\n\n      if (x1 === x2 && y1 === y2 && z1 === z2) return; // Fill with a quad.\n\n      indexArr.push(_e);\n      indexArr.push(e11);\n      indexArr.push(e10);\n      indexArr.push(_e);\n      indexArr.push(e10);\n      indexArr.push(_e2);\n    } else if (nbEdges === 1) {\n      // 2 vertices: boundary edge.\n      var e0 = edges[0];\n      var e1 = edges[1]; // Add two vertices.\n\n      var e2 = nbVerts;\n      var e3 = e2 + 1;\n      nbVerts += 2;\n      posArr.push(posAttr.getX(e0), posAttr.getY(e0), posAttr.getZ(e0));\n      posArr.push(posAttr.getX(e1), posAttr.getY(e1), posAttr.getZ(e1));\n      normArr.push(0, 0, -1);\n      normArr.push(0, 0, -1); // Make two quads.\n\n      indexArr.push(e0);\n      indexArr.push(e3);\n      indexArr.push(e1);\n      indexArr.push(e0);\n      indexArr.push(e2);\n      indexArr.push(e3);\n    } else if (nbEdges === 3) {// 6 vertices: non-manifold boundary edge.\n      // TODO [SHADOWS] handle non-manifold edges\n      // This can be computed with normals.\n    } else if (nbEdges === 4) {// 8 vertices: non manifold, non-boundary edge.\n      // TODO [SHADOWS] handle non-manifold non-boundary edges\n      // Same, can be computed with normals, but quite a handful of cases to manage.\n    } else {\n      console.warn(\'[ShadowVolumes] Non-manifold edge with more than four faces.\');\n    }\n  });\n  var normAttr = new three_module["j" /* BufferAttribute */](new Float32Array(normArr), 3, false);\n  shadowGeom.setAttribute(\'normal\', normAttr);\n  var indexAttr = new three_module["j" /* BufferAttribute */](new Uint32Array(indexArr), 1, false);\n  shadowGeom.setIndex(indexAttr);\n  var positionAttr = new three_module["j" /* BufferAttribute */](new Float32Array(posArr), 3, false);\n  shadowGeom.setAttribute(\'position\', positionAttr);\n  return shadowGeom;\n}\n\nfunction createShadowCastingMaterial(angleBias) {\n  var lightPosition = new three_module["Sb" /* Vector3 */]();\n  var eyePosition = new three_module["Sb" /* Vector3 */]();\n  var customUniforms = UniformsUtils["a" /* UniformsUtils */].merge([// ShaderLib.lambert.uniforms,\n  ShaderLib["a" /* ShaderLib */].basic.uniforms, {\n    lightPosition: {\n      value: lightPosition\n    },\n    eyePosition: {\n      value: eyePosition\n    },\n    bias: {\n      value: angleBias\n    }\n  }]);\n  return new three_module["Eb" /* ShaderMaterial */]({\n    uniforms: customUniforms,\n    vertexShader: ShadersModule.getShadowVertexShader(),\n    fragmentShader: ShaderLib["a" /* ShaderLib */].basic.fragmentShader,\n    // fragmentShader: ShaderLib.lambert.fragmentShader,\n    // lights: true,\n    // transparent: true,\n    // wireframe: true,\n    // flatShading: true,\n    side: three_module["z" /* FrontSide */]\n  });\n}\n\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/terrain/chunks.js\n/**\n *\n */\n\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\n\nvar debugChunks = false;\nvar ChunksModule = {\n  createChunk: function createChunk(chunkId, all, chunkSizeX, chunkSizeY, chunkSizeZ, isWorldFlat, worldId) {\n    var components = all[0];\n    var natures = all[1]; // console.log(components);\n    // console.log(natures);\n\n    var currentComponent;\n    var currentNatures;\n\n    if (!components.hasOwnProperty(\'1\') && !components.hasOwnProperty(\'2\')) {\n      if (debugChunks) console.log("[Terrain/Chunks] Empty chunk \\"".concat(chunkId, "\\"."));\n      return this.createEmptyChunkComponent(chunkId, chunkSizeX, chunkSizeY, chunkSizeZ, worldId, isWorldFlat);\n    }\n\n    var hasTerrain = components.hasOwnProperty(\'1\') && natures.hasOwnProperty(\'1\');\n    var hasWater = components.hasOwnProperty(\'2\') && natures.hasOwnProperty(\'2\');\n\n    if (debugChunks) {\n      if (!hasTerrain) console.log(\'New chunk with empty terrain.\');\n      if (!hasWater) console.log(\'New chunk with empty water.\');\n    }\n\n    var component1;\n\n    if (hasTerrain && hasWater) {\n      currentComponent = components[\'1\'];\n      currentNatures = natures[\'1\'];\n      component1 = this.createChunkComponent(chunkId, chunkSizeX, chunkSizeY, chunkSizeZ, currentComponent, currentNatures, false, 0, isWorldFlat, worldId);\n      currentComponent = components[\'2\'];\n      currentNatures = natures[\'2\'];\n      var component2 = this.createChunkComponent(chunkId, chunkSizeX, chunkSizeY, chunkSizeZ, currentComponent, currentNatures, true, 1, isWorldFlat, worldId); // Merge\n\n      component1.capacities.push(component2.capacities[0]);\n      component1.geometries.push(component2.geometries[0]); // component1.materials.push(component2.materials[0]);\n\n      component1.sizes.push(component2.sizes[0]);\n      component1.water.push(component2.water[0]);\n      component1.meshes.push(component2.meshes[0]); // let s1 = component1.whereToFindFace.size;\n      // let s2 = component2.whereToFindFace.size;\n\n      component1.whereToFindFace = new Map([].concat(_toConsumableArray(component1.whereToFindFace), _toConsumableArray(component2.whereToFindFace)));\n      component1.whichFaceIs = new Map([].concat(_toConsumableArray(component1.whichFaceIs), _toConsumableArray(component2.whichFaceIs))); // let s3 = component1.whereToFindFace.size;\n      // console.log(`${s1} + ${s2} = ${s3}`);\n    } else if (hasTerrain) {\n      currentComponent = components[\'1\'];\n      currentNatures = natures[\'1\'];\n      component1 = this.createChunkComponent(chunkId, chunkSizeX, chunkSizeY, chunkSizeZ, currentComponent, currentNatures, false, 0, isWorldFlat, // although not water so not important\n      worldId);\n    } else if (hasWater) {\n      currentComponent = components[\'2\'];\n      currentNatures = natures[\'2\'];\n      component1 = this.createChunkComponent(chunkId, chunkSizeX, chunkSizeY, chunkSizeZ, currentComponent, currentNatures, true, 0, isWorldFlat, worldId);\n    }\n\n    return component1;\n  },\n  createDebugMesh: function createDebugMesh(chunk, chunkSizeX, chunkSizeY, chunkSizeZ, iChunkOffset, jChunkOffset, kChunkOffset) {\n    chunk.debugMesh = this.createChunkDebugMesh(chunkSizeX, chunkSizeY, chunkSizeZ);\n    chunk.debugMesh.position.set(iChunkOffset + chunkSizeX / 2, jChunkOffset + chunkSizeY / 2, kChunkOffset + chunkSizeZ / 2);\n  },\n  createEmptyChunkComponent: function createEmptyChunkComponent(chunkId, chunkSizeX, chunkSizeY, chunkSizeZ, worldId, isWorldFlat) {\n    var sunCapacity = this._defaultEmptyChunkSize; // Math.floor(3 / 2 * triangles);\n\n    if (this.debug) {\n      console.log("On chunk ".concat(chunkId, ", init geometry will be ").concat(sunCapacity * 3 * 3, "-capable."));\n    }\n\n    var geometry = new three_module["k" /* BufferGeometry */]();\n    geometry.setAttribute(\'position\', new three_module["j" /* BufferAttribute */](new Float32Array(sunCapacity * 3 * 3), 3));\n    geometry.setAttribute(\'normal\', new three_module["j" /* BufferAttribute */](new Float32Array(sunCapacity * 3 * 3), 3));\n    geometry.setAttribute(\'color\', new three_module["j" /* BufferAttribute */](new Float32Array(sunCapacity * 3 * 3), 3));\n    geometry.setAttribute(\'uv\', new three_module["j" /* BufferAttribute */](new Float32Array(sunCapacity * 3 * 2), 2));\n    geometry.computeBoundingSphere();\n    var newMesh = this.createChunkMesh(geometry, false, false, worldId); // flat world or not, no water creation\n    // let material = newMesh.material;\n    // let material = this.createMaterial(\'textured-phong\', 0xaaaaaa);\n    // let newMesh = new Mesh(geometry, material);\n\n    if (isWorldFlat && this.hasShadowMap() && parseInt(worldId, 10) === -1) {\n      newMesh.castShadow = true;\n      newMesh.receiveShadow = true;\n    } // if (Math.random() < 0.5)\n\n\n    newMesh.userData.bloom = true;\n    var c = {\n      geometries: [geometry],\n      // materials:          [material],\n      meshes: [newMesh],\n      water: [false],\n      // is water\n      capacities: [sunCapacity / 2],\n      // 2 triangles per face\n      sizes: [0 / 2],\n      whereToFindFace: new Map(),\n      whichFaceIs: new Map()\n    };\n\n    if (this._debugChunkBoundingBoxes) {\n      var chunkIndices = chunkId.split(\',\');\n      var iChunkOffset = parseInt(chunkIndices[0], 10) * chunkSizeX;\n      var jChunkOffset = parseInt(chunkIndices[1], 10) * chunkSizeY;\n      var kChunkOffset = parseInt(chunkIndices[2], 10) * chunkSizeZ;\n      this.createDebugMesh(c, chunkSizeX, chunkSizeY, chunkSizeZ, iChunkOffset, jChunkOffset, kChunkOffset);\n    }\n\n    return c;\n  },\n  createChunkComponent: function createChunkComponent(chunkId, chunkSizeX, chunkSizeY, chunkSizeZ, currentComponent, currentNatures, isWater, componentIndex, isWorldFlat, worldId) {\n    var chunkIndices = chunkId.split(\',\');\n    var iChunkOffset = parseInt(chunkIndices[0], 10) * chunkSizeX;\n    var jChunkOffset = parseInt(chunkIndices[1], 10) * chunkSizeY;\n    var kChunkOffset = parseInt(chunkIndices[2], 10) * chunkSizeZ;\n    var iS = chunkSizeX;\n    var ijS = chunkSizeX * chunkSizeY;\n    var ijkS = ijS * chunkSizeZ;\n    var triangles = 2 * currentComponent.length;\n    var sunCapacity = Math.floor(3 / 2 * triangles);\n    sunCapacity += sunCapacity % 2; // Make it pair\n\n    if (this.debug) console.log("On chunk ".concat(chunkId, ", init geometry will be ").concat(sunCapacity * 3 * 3, "-capable."));\n    var positions = new Float32Array(sunCapacity * 3 * 3);\n    var normals = new Float32Array(sunCapacity * 3 * 3);\n    var colors = new Float32Array(sunCapacity * 3 * 3);\n    var uvs = new Float32Array(sunCapacity * 3 * 2);\n    var pA = new three_module["Sb" /* Vector3 */]();\n    var pB = new three_module["Sb" /* Vector3 */]();\n    var pC = new three_module["Sb" /* Vector3 */]();\n    var cb = new three_module["Sb" /* Vector3 */]();\n    var ab = new three_module["Sb" /* Vector3 */]();\n    var color = new three_module["n" /* Color */]();\n    var whereToFindFace = new Map();\n    var whichFaceIs = new Map();\n    var i = 0;\n\n    for (var f = 0; f < currentComponent.length; ++f) {\n      var faceId = Math.abs(currentComponent[f]);\n      var newGeometryId = componentIndex;\n      whereToFindFace.set(faceId, [newGeometryId, f]); // [In which geometry a given face is, at which position]\n\n      var wf0 = whichFaceIs.get(newGeometryId);\n\n      if (wf0 === undefined) {\n        wf0 = new Map();\n        whichFaceIs.set(newGeometryId, wf0);\n      }\n\n      wf0.set(f, faceId);\n      var normal = currentNatures[f] > 0;\n      this.addFace(faceId, i, iS, ijS, ijkS, positions, normals, colors, uvs, Math.abs(currentNatures[f]), iChunkOffset, jChunkOffset, kChunkOffset, pA, pB, pC, cb, ab, normal, color);\n      ++i;\n    }\n\n    var geometry = new three_module["k" /* BufferGeometry */]();\n    geometry.setAttribute(\'position\', new three_module["j" /* BufferAttribute */](positions, 3));\n    geometry.setAttribute(\'normal\', new three_module["j" /* BufferAttribute */](normals, 3));\n    geometry.setAttribute(\'color\', new three_module["j" /* BufferAttribute */](colors, 3));\n    geometry.setAttribute(\'uv\', new three_module["j" /* BufferAttribute */](uvs, 2));\n    geometry.computeBoundingSphere(); // let material;\n    // material = this.createMaterial(\'textured-phong\', 0xaaaaaa);\n    // if (isWater) { // transparency\n    //     material.transparent = true;\n    //     material.opacity = 0.3;\n    //     material.side = DoubleSide;\n    // }\n\n    var newMesh = this.createChunkMesh(geometry, isWater, isWorldFlat, worldId); // let material = newMesh.material;\n    // let newMesh = new Mesh(geometry, material);\n    // if (Math.random() < 0.5)\n\n    var shadowMesh;\n\n    if (!isWater) {\n      // s.material.uniforms.sunPosition.value\n      // if (iChunkOffset === 0 &&\n      //     jChunkOffset === -32 &&\n      //     kChunkOffset === 0)\n      // {\n      //     shadowMesh = new Mesh(\n      //         getDynamicShadowVolumeGeometry(geometry, triangles * 3),\n      //         createShadowCastingMaterial(0.0)\n      //     );\n      // }\n      var isMainWorld = parseInt(worldId, 10) === -1;\n\n      if (isWorldFlat && this.hasShadowVolumes() && isMainWorld) {\n        shadowMesh = new three_module["W" /* Mesh */](getDynamicShadowVolumeGeometry(geometry, triangles * 3), createShadowCastingMaterial(0.0));\n      }\n\n      if (isWorldFlat && this.hasShadowMap() && isMainWorld) {\n        newMesh.castShadow = true;\n        newMesh.receiveShadow = true;\n      }\n\n      newMesh.userData.bloom = true;\n    }\n\n    var c = {\n      geometries: [geometry],\n      // materials:          [material],\n      meshes: [newMesh],\n      water: [isWater],\n      // is water\n      capacities: [sunCapacity / 2],\n      sizes: [triangles / 2],\n      shadow: shadowMesh,\n      whereToFindFace: whereToFindFace,\n      whichFaceIs: whichFaceIs\n    };\n\n    if (this._debugChunkBoundingBoxes) {\n      this.createDebugMesh(c, chunkSizeX, chunkSizeY, chunkSizeZ, iChunkOffset, jChunkOffset, kChunkOffset);\n    }\n\n    return c;\n  },\n  updateChunk: function updateChunk(worldId, chunk, chunkId, components, chunkSizeX, chunkSizeY, chunkSizeZ, isWorldFlat) {\n    var geometries = chunk.geometries; // let materials =         chunk.materials;\n\n    var meshes = chunk.meshes;\n    var capacities = chunk.capacities;\n    var sizes = chunk.sizes;\n    var water = chunk.water;\n    var whereToFindFace = chunk.whereToFindFace;\n    var whichFaceIs = chunk.whichFaceIs;\n    var removed = components[0];\n    var added = components[1];\n    var updated = components[2];\n\n    if (this.debug) {\n      console.log(\'BUD\');\n      console.log(removed);\n      console.log(added);\n      console.log(updated);\n    } // Bundle updated faces.\n\n\n    for (var uid in updated) {\n      if (!updated.hasOwnProperty(uid)) continue;\n      var update = updated[uid];\n      removed[uid] = null;\n      added[uid] = update;\n    }\n\n    this.removeChunkFaces(worldId, removed, geometries, meshes, capacities, sizes, whereToFindFace, whichFaceIs);\n    this.addChunkFaces(worldId, added, geometries, meshes, capacities, sizes, water, whereToFindFace, whichFaceIs, chunkId, chunkSizeX, chunkSizeY, chunkSizeZ, isWorldFlat);\n\n    if (this.hasShadowVolumes() && chunk.shadow) {\n      for (var m = 0; m < meshes.length; ++m) {\n        if (water[m]) continue;\n        var g = geometries[m];\n        var s = sizes[m]; // Rebuild whole shadow volume.\n        // This is extremely inefficient.\n\n        this.removeFromShadows(chunk.shadow);\n        chunk.shadow = new three_module["W" /* Mesh */](getDynamicShadowVolumeGeometry(g, s * 2 * 3), createShadowCastingMaterial(0.0));\n        this.addToShadows(chunk.shadow); // Only on first geometry (bundles unsupported atm)\n\n        break;\n      }\n    }\n  },\n  removeChunkFaces: function removeChunkFaces(worldId, removed, geometries, meshes, capacities, sizes, whereToFindFace, whichFaceIs) {\n    var geometry;\n    var vertices;\n    var colors;\n    var normals;\n    var uvs;\n    var meshId;\n\n    for (var rrid in removed) {\n      if (!removed.hasOwnProperty(rrid)) continue;\n      var rid = parseInt(rrid, 10); // Get graphic data\n\n      if (!whereToFindFace.has(rid)) {\n        console.log("Trying to remove a face that is not present in chunk: ".concat(rid));\n        continue;\n      }\n\n      var wtffrid = whereToFindFace.get(rid);\n      meshId = wtffrid[0];\n      var position = wtffrid[1];\n      geometry = geometries[meshId];\n      vertices = geometry.attributes.position.array;\n      colors = geometry.attributes.color.array;\n      normals = geometry.attributes.normal.array;\n      uvs = geometry.attributes.uv.array;\n      var lastPosition = sizes[meshId] - 1;\n      var isLast = lastPosition === position; // Update\n\n      var i = void 0;\n      var p = void 0;\n\n      if (isLast) {\n        for (i = 0; i < 18; ++i) {\n          p = 18 * position + i; // Delete current\n\n          vertices[p] = normals[p] = colors[p] = 0;\n        }\n\n        for (i = 0; i < 12; ++i) {\n          uvs[12 * position + i] = 0;\n        }\n      } else {\n        for (i = 0; i < 18; ++i) {\n          p = 18 * position + i; // Swap current with last\n\n          var lp = 18 * lastPosition + i;\n          vertices[p] = vertices[lp];\n          normals[p] = normals[lp];\n          colors[p] = colors[lp]; // Delete last\n\n          vertices[lp] = normals[lp] = colors[lp] = 0;\n        }\n\n        for (i = 0; i < 12; ++i) {\n          p = 12 * position + i;\n          var lp1 = 12 * lastPosition + i;\n          uvs[p] = uvs[lp1];\n          uvs[lp1] = 0;\n        }\n      } // Update helpers (swap last if applicable).\n\n\n      if (!isLast) {\n        var whichFaceIsMeshId = whichFaceIs.get(meshId);\n\n        if (whichFaceIsMeshId.get(lastPosition) === undefined) {\n          console.log(\'WARN: swapping\');\n          console.log("".concat(whichFaceIs[meshId][lastPosition], " @mesh ").concat(meshId, " ") + "@lastposition ".concat(lastPosition, " @position ").concat(position));\n        }\n\n        whereToFindFace.set(whichFaceIsMeshId.get(lastPosition), [meshId, position]);\n        whichFaceIsMeshId.set(position, whichFaceIsMeshId.get(lastPosition));\n      }\n\n      whichFaceIs.get(meshId)["delete"](lastPosition);\n      whereToFindFace["delete"](rid);\n      sizes[meshId] -= 1; // Delete geometry if applicable.\n\n      if (sizes[meshId] === 0) {\n        console.log(\'INFO: geometry deletion.\'); // Remove mesh from scene.\n\n        this.removeFromScene(meshes[meshId], worldId);\n        geometries[meshId] = undefined; // materials[meshId]   = undefined;\n\n        meshes[meshId] = undefined;\n        sizes[meshId] = undefined;\n        capacities[meshId] = undefined;\n        whichFaceIs["delete"](meshId);\n      } else {\n        // Notify object\n        geometry.attributes.position.needsUpdate = true;\n        geometry.attributes.color.needsUpdate = true;\n        geometry.attributes.normal.needsUpdate = true;\n        geometry.attributes.uv.needsUpdate = true;\n        geometry.computeBoundingSphere();\n      }\n    }\n  },\n  addChunkFaces: function addChunkFaces(worldId, added, geometries, meshes, capacities, sizes, water, whereToFindFace, whichFaceIs, chunkId, chunkSizeX, chunkSizeY, chunkSizeZ, isWorldFlat) {\n    var geometry;\n    var vertices;\n    var colors;\n    var normals;\n    var uvs;\n    var meshId;\n    var faceId;\n    var iS = chunkSizeX;\n    var ijS = chunkSizeX * chunkSizeY;\n    var ijkS = ijS * chunkSizeZ;\n    var chunkIndices = chunkId.split(\',\');\n    var chunkI = parseInt(chunkIndices[0], 10);\n    var iChunkOffset = chunkI * chunkSizeX;\n    var chunkJ = parseInt(chunkIndices[1], 10);\n    var jChunkOffset = chunkJ * chunkSizeY;\n    var chunkK = parseInt(chunkIndices[2], 10);\n    var kChunkOffset = chunkK * chunkSizeZ;\n    var defaultGeometrySize = this.defaultGeometrySize;\n\n    for (var aaid in added) {\n      if (!added.hasOwnProperty(aaid)) continue;\n      var aid = parseInt(aaid, 10); // Get graphic data\n\n      faceId = Math.abs(aid);\n\n      if (whereToFindFace.hasOwnProperty(faceId)) {\n        console.log(\'Trying to add a face that is already present in chunk.\');\n        continue;\n      }\n\n      var nature = added[aid]; // If water, add into water mesh.\n\n      var isWater = Math.abs(nature) === ItemType.BLOCK_WATER; // Compute mesh id.\n\n      meshId = 0;\n      var meshHasToBeAdded = false;\n\n      while (meshes[meshId] !== undefined && (sizes[meshId] === capacities[meshId] || water[meshId] !== isWater)) {\n        ++meshId;\n      } // Add new mesh if necessary.\n\n\n      meshHasToBeAdded = sizes[meshId] === undefined;\n\n      if (this.debug) {\n        var progress = Math.floor(100 * sizes[meshId] / capacities[meshId]);\n        if (progress % 20 === 0) console.log("INFO: Geometry ".concat(meshId, " at ").concat(progress, "% capacity."));\n      }\n\n      if (meshHasToBeAdded) {\n        if (this.debug) {\n          console.log(\'INFO: Geometry addition: \' + "".concat(meshId) + "".concat(meshId % 10 === 1 ? \'st\' : meshId % 10 === 2 ? \'nd\' : meshId % 10 === 3 ? \'rd\' : \'th\') + \' geometry.\');\n        } // Create geometry.\n\n\n        geometry = new three_module["k" /* BufferGeometry */]();\n        geometries[meshId] = geometry; // let newMaterial = this.createMaterial(\'textured-phong\', 0xb8860b);\n        // if (isWater) {\n        //     newMaterial.transparent = true;\n        //     newMaterial.opacity = 0.3;\n        //     newMaterial.side = FrontSide;\n        // }\n        // materials[meshId] = newMaterial;\n\n        sizes[meshId] = 1;\n        water[meshId] = isWater;\n        whichFaceIs.set(meshId, new Map());\n        var triangles = 2 * defaultGeometrySize;\n        var sunCapacity = Math.floor(3 / 2 * triangles);\n        capacities[meshId] = sunCapacity / 2;\n        vertices = new Float32Array(sunCapacity * 3 * 3);\n        normals = new Float32Array(sunCapacity * 3 * 3);\n        colors = new Float32Array(sunCapacity * 3 * 3);\n        uvs = new Float32Array(sunCapacity * 3 * 2);\n\n        if (this.debug) {\n          console.log("New capacity will be ".concat(sunCapacity * 3 * 3, "."));\n        }\n      } else {\n        geometry = geometries[meshId];\n        sizes[meshId] += 1;\n        vertices = geometry.attributes.position.array;\n        colors = geometry.attributes.color.array;\n        normals = geometry.attributes.normal.array;\n        uvs = geometry.attributes.uv.array;\n      } // Add face.\n\n\n      var pA = new three_module["Sb" /* Vector3 */]();\n      var pB = new three_module["Sb" /* Vector3 */]();\n      var pC = new three_module["Sb" /* Vector3 */]();\n      var cb = new three_module["Sb" /* Vector3 */]();\n      var ab = new three_module["Sb" /* Vector3 */]();\n      var n = 800;\n      var color = new three_module["n" /* Color */]();\n      var pos = sizes[meshId] - 1;\n      var normal = nature > 0;\n      whereToFindFace.set(aid, [meshId, pos]);\n      var wfi = whichFaceIs.get(meshId);\n\n      if (!wfi) {\n        var m = new Map();\n        m.set(pos, aid);\n        whichFaceIs.set(meshId, m);\n      } else {\n        wfi.set(pos, aid);\n      }\n\n      this.addFace(faceId, pos, iS, ijS, ijkS, vertices, normals, colors, uvs, Math.abs(nature), iChunkOffset, jChunkOffset, kChunkOffset, pA, pB, pC, cb, ab, normal, color, n);\n\n      if (meshHasToBeAdded) {\n        geometry.setAttribute(\'position\', new three_module["j" /* BufferAttribute */](vertices, 3));\n        geometry.setAttribute(\'normal\', new three_module["j" /* BufferAttribute */](normals, 3));\n        geometry.setAttribute(\'color\', new three_module["j" /* BufferAttribute */](colors, 3));\n        geometry.setAttribute(\'uv\', new three_module["j" /* BufferAttribute */](uvs, 2)); // let addedMesh = new Mesh(geometry, materials[meshId]);\n        // meshes[meshId] = addedMesh;\n\n        var newMesh = this.createChunkMesh(geometry, isWater, isWorldFlat, worldId); // let newMesh = new Mesh(geometry, materials[meshId]);\n\n        if (this.hasShadowMap() && isWorldFlat && parseInt(worldId, 10) === -1) {\n          newMesh.castShadow = true;\n          newMesh.receiveShadow = true;\n        } // if (Math.random() < 0.25)\n\n\n        newMesh.userData.bloom = true;\n        meshes[meshId] = newMesh;\n        this.addToScene(newMesh, worldId);\n      } // Notify object.\n\n\n      geometry.attributes.position.needsUpdate = true;\n      geometry.attributes.color.needsUpdate = true;\n      geometry.attributes.normal.needsUpdate = true;\n      geometry.attributes.uv.needsUpdate = true;\n      geometry.computeBoundingSphere();\n    }\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/water/water.js\n/**\n * --- ADAPTED FROM ---\n *\n * @author jbouny / https://github.com/jbouny\n *\n * Work based on :\n * @author Slayvin / http://slayvin.net : Flat mirror for three.js\n * @author Stemkoski / http://www.adelphi.edu/~stemkoski : An implementation of water shader based on the flat mirror\n * @author Jonas Wagner / http://29a.ch/ && http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n */\n\n\n\nvar water_Water = function Water(graphics, geometry, options, worldId) {\n  three_module["W" /* Mesh */].call(this, geometry);\n  options = options || {};\n  var alpha = options.alpha !== undefined ? options.alpha : 1.0;\n  var time = options.time !== undefined ? options.time : 0.0;\n  var normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;\n  var sunDirection = options.sunDirection !== undefined ? options.sunDirection : new three_module["Sb" /* Vector3 */](0.70707, 0.70707, 0.0);\n  var sunColor = new three_module["n" /* Color */](options.sunColor !== undefined ? options.sunColor : 0xffffff);\n  var waterColor = new three_module["n" /* Color */](options.waterColor !== undefined ? options.waterColor : 0x7F7F7F);\n  var eye = options.eye !== undefined ? options.eye : new three_module["Sb" /* Vector3 */](0, 0, 0);\n  var size = options.size !== undefined ? options.size : 1.0;\n  var distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;\n  var side = options.side !== undefined ? options.side : three_module["z" /* FrontSide */];\n  var fog = options.fog !== undefined ? options.fog : false;\n  var material;\n  var waterMaterial = graphics.waterMaterials.get(worldId);\n\n  if (!waterMaterial) {\n    var mirrorShader = {\n      uniforms: three_module["Pb" /* UniformsUtils */].merge([three_module["Ob" /* UniformsLib */].fog, three_module["Ob" /* UniformsLib */].lights, {\n        normalSampler: {\n          value: null\n        },\n        mirrorSampler: {\n          value: null\n        },\n        alpha: {\n          value: 1.0\n        },\n        time: {\n          value: 0.0\n        },\n        size: {\n          value: size\n        },\n        distortionScale: {\n          value: 20.0\n        },\n        textureMatrix: {\n          value: new three_module["V" /* Matrix4 */]()\n        },\n        sunColor: {\n          value: new three_module["n" /* Color */](0x7F7F7F)\n        },\n        sunDirection: {\n          value: new three_module["Sb" /* Vector3 */](0.70707, 0.70707, 0)\n        },\n        eye: {\n          value: new three_module["Sb" /* Vector3 */]()\n        },\n        // waterColor: { value: new Color(0x555555) },\n        waterColor: {\n          value: new three_module["n" /* Color */](0x001e0f)\n        }\n      }]),\n      vertexShader: ShadersModule.getWaterVertexShader(),\n      fragmentShader: ShadersModule.getWaterFragmentShader()\n    };\n    material = new three_module["Eb" /* ShaderMaterial */]({\n      fragmentShader: mirrorShader.fragmentShader,\n      vertexShader: mirrorShader.vertexShader,\n      uniforms: three_module["Pb" /* UniformsUtils */].clone(mirrorShader.uniforms),\n      lights: true,\n      transparent: true,\n      side: side,\n      fog: fog // wireframe: true\n\n    });\n    var renderTarget = graphics.cameraManager.waterCamera.waterRenderTarget;\n    var textureMatrix = graphics.cameraManager.waterCamera.textureMatrix;\n    material.uniforms.mirrorSampler.value = renderTarget.texture;\n    material.uniforms.textureMatrix.value = textureMatrix;\n    material.uniforms.alpha.value = alpha;\n    material.uniforms.time.value = time;\n    material.uniforms.normalSampler.value = normalSampler;\n    material.uniforms.sunColor.value = sunColor;\n    material.uniforms.waterColor.value = waterColor;\n    material.uniforms.sunDirection.value = sunDirection;\n    material.uniforms.distortionScale.value = distortionScale;\n    material.uniforms.eye.value = eye;\n    graphics.waterMaterials.set(worldId, material);\n  } else {\n    material = waterMaterial;\n  }\n\n  this.renderOrder = 800;\n  this.material = material;\n};\n\nwater_Water.prototype = Object.create(three_module["W" /* Mesh */].prototype);\nwater_Water.prototype.constructor = water_Water;\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/terrain/chunkmesh.js\n\n\nvar ChunksMeshModule = {\n  createChunkMesh: function createChunkMesh(geometry, isWater, isWorldFlat, worldId) {\n    if (isWater) {\n      // low-res\n      if (!isWorldFlat || !this.rendererManager.waterReflection || worldId !== \'-1\') {\n        var material = this.createMaterial(\'textured-phong-water\', 0xaaaaaa, worldId);\n        material.transparent = true;\n        material.opacity = 0.5;\n        material.side = three_module["t" /* DoubleSide */];\n        return new three_module["W" /* Mesh */](geometry, material);\n      } else {\n        var waterResolution = this.waterRTTResolution;\n        return new water_Water(this, geometry, {\n          textureWidth: waterResolution,\n          textureHeight: waterResolution,\n          waterNormals: this.textureWaterNormals,\n          alpha: 0.5,\n          sunDirection: new three_module["Sb" /* Vector3 */](0.70707, 0.70707, 0.0),\n          sunColor: 0xffffff,\n          waterColor: 0x7b8a99,\n          distortionScale: 0.1,\n          size: 10.0,\n          fog: false\n        }, worldId);\n      }\n    } else {\n      var _material = this.createMaterial(\'textured-phong\', 0xaaaaaa, worldId);\n\n      return new three_module["W" /* Mesh */](geometry, _material);\n    }\n  },\n  createChunkDebugMesh: function createChunkDebugMesh(chunkSizeX, chunkSizeY, chunkSizeZ) {\n    return new three_module["W" /* Mesh */](new three_module["h" /* BoxBufferGeometry */](chunkSizeX, chunkSizeY, chunkSizeZ, 1, 1, 1), new three_module["X" /* MeshBasicMaterial */]({\n      wireframe: true,\n      color: 0x00ff00\n    }));\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/sky/sky.js\n/**\n * Sky object.\n */\n\n\n\n // import extend from \'../../../extend.js\';\n// turbidity, 1.0, 20.0, 0.1\n// rayleigh, 0.0, 4, 0.001\n// mieCoefficient, 0.0, 0.1, 0.001\n// mieDirectionalG, 0.0, 1, 0.001\n// luminance, 0.0, 2\n// inclination, 0, 1, 0.0001\n// azimuth, 0, 1, 0.0001\n\nvar sky_SkyCube = function SkyCube(centerX, centerY, centerZ, radius) {\n  var shader = {\n    uniforms: {\n      luminance: {\n        value: 1\n      },\n      turbidity: {\n        value: 2\n      },\n      rayleigh: {\n        value: 1\n      },\n      mieCoefficient: {\n        value: 0.005\n      },\n      mieDirectionalG: {\n        value: 0.8\n      },\n      sunPosition: {\n        value: new three_module["Sb" /* Vector3 */]()\n      },\n      // viewInverse: { value: new Matrix4() },\n      cameraPos: {\n        value: new three_module["Sb" /* Vector3 */]()\n      },\n      worldCenter: {\n        value: new three_module["Sb" /* Vector3 */](centerX, centerY, centerZ)\n      },\n      cubeRadius: {\n        value: radius - 2\n      }\n    },\n    vertexShader: ShadersModule.getSkyCubeVertexShader(),\n    fragmentShader: ShadersModule.getSkyCubeFragmentShader()\n  };\n  var material = new three_module["Eb" /* ShaderMaterial */]({\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader,\n    uniforms: three_module["Pb" /* UniformsUtils */].clone(shader.uniforms),\n    side: three_module["t" /* DoubleSide */]\n  });\n  var geometry = new three_module["h" /* BoxBufferGeometry */](1, 1, 1);\n  three_module["W" /* Mesh */].call(this, geometry, material // new MeshBasicMaterial({\n  //     side: DoubleSide, color: 0x362c6b})\n  );\n};\n\nvar sky_SkyFlat = function SkyFlat() {\n  var shader = {\n    uniforms: {\n      luminance: {\n        value: 1\n      },\n      turbidity: {\n        value: 10\n      },\n      rayleigh: {\n        value: 1\n      },\n      mieCoefficient: {\n        value: 0.005\n      },\n      mieDirectionalG: {\n        value: 0.8\n      },\n      sunPosition: {\n        value: new three_module["Sb" /* Vector3 */]()\n      },\n      cameraPos: {\n        value: new three_module["Sb" /* Vector3 */]()\n      }\n    },\n    vertexShader: ShadersModule.getSkyFlatVertexShader(),\n    fragmentShader: ShadersModule.getSkyFlatFragmentShader()\n  };\n  var material = new three_module["Eb" /* ShaderMaterial */]({\n    fragmentShader: shader.fragmentShader,\n    vertexShader: shader.vertexShader,\n    uniforms: three_module["Pb" /* UniformsUtils */].clone(shader.uniforms),\n    side: three_module["t" /* DoubleSide */]\n  });\n  var geometry = new three_module["h" /* BoxBufferGeometry */](1, 1, 1);\n  three_module["W" /* Mesh */].call(this, geometry, material);\n};\n\nsky_SkyCube.prototype = Object.create(three_module["W" /* Mesh */].prototype);\nsky_SkyFlat.prototype = Object.create(three_module["W" /* Mesh */].prototype);\n\n// CONCATENATED MODULE: ./client/app/model/server/chunks.js\n/**\n *\n */\n\n/** Model **/\n\nfunction chunks_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { chunks_typeof = function _typeof(obj) { return typeof obj; }; } else { chunks_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return chunks_typeof(obj); }\n\n\nvar WorldType = Object.freeze({\n  FLAT: 0,\n  CUBE: 1,\n  SHRIKE: 2,\n  UNSTRUCTURED: 3,\n  FANTASY: 4\n});\n\nvar ChunkModel = function ChunkModel(app) {\n  this.app = app; // Model component.\n\n  this.worlds = new Map();\n  this.worldProperties = new Map();\n  this.chunkUpdates = []; // Whatever lies between.\n\n  this.skies = new Map(); // Graphical component.\n\n  this.needsUpdate = false;\n  this.debug = false;\n};\n\nextend(ChunkModel.prototype, {\n  hasWorld: function hasWorld(worldId) {\n    return this.worlds.has(worldId);\n  },\n  addWorldIfNotPresent: function addWorldIfNotPresent(worldId, worldInfo, worldInfoMeta) {\n    // console.log(\'This world I don\\\'t know... \' + worldId);\n    var world = new Map();\n    var properties = {\n      chunkSizeX: worldInfo[0],\n      // 16,\n      chunkSizeY: worldInfo[1],\n      // 16,\n      chunkSizeZ: worldInfo[2],\n      // 32\n      type: worldInfoMeta[0],\n      radius: worldInfoMeta[1],\n      center: {\n        x: worldInfoMeta[2],\n        y: worldInfoMeta[3],\n        z: worldInfoMeta[4]\n      }\n    };\n    properties.chunkCapacity = properties.chunkSizeX * properties.chunkSizeY * properties.chunkSizeZ;\n    this.worlds.set(worldId, world);\n    this.worldProperties.set(worldId, properties);\n    return properties;\n  },\n\n  /** Dynamics **/\n  init: function init() {},\n  refresh: function refresh() {\n    if (!this.needsUpdate) return;\n    var graphics = this.app.engine.graphics; // let clientModel = this.app.model.client;\n\n    var chunkUpdates = this.chunkUpdates;\n    var reportedUpdates = [];\n    var mustReport = false;\n\n    for (var cu = 0, l = chunkUpdates.length; cu < l; ++cu) {\n      var updates = chunkUpdates[cu];\n      var rup = {};\n\n      if (\'worlds\' in updates) {\n        //console.log(\'World metadata:\');\n        //console.log(updates[\'worlds\']);\n        var worlds = updates.worlds;\n        var worldsMeta = updates.worldsMeta;\n\n        for (var wid in worlds) {\n          if (!worlds.hasOwnProperty(wid)) continue;\n          var wif = worlds[wid];\n\n          for (var id = 0, wl = wif.length; id < wl; ++id) {\n            wif[id] = parseInt(wif[id], 10);\n          } // Add new world and matching scene.\n\n\n          if (this.hasWorld(wid)) {\n            // console.log(`Update for a world I already have: ${wid}.`);\n            continue;\n          }\n\n          if (!worldsMeta || !worldsMeta.hasOwnProperty(wid)) {\n            console.error("NO METADATA FOR NEW WORLD: ".concat(wid, "."));\n            continue;\n          }\n\n          var wifm = worldsMeta[wid];\n          this.addWorldIfNotPresent(wid, wif, wifm); // 1 world <-> 1 scene, multiple cameras\n\n          graphics.addScene(wid);\n          var newSky = graphics.addSky(wid, this.worldProperties.get(wid));\n          if (newSky) this.skies.set(wid, newSky);\n        }\n      }\n\n      for (var worldId in updates) {\n        if (!updates.hasOwnProperty(worldId) || worldId === \'worlds\' || worldId === \'worldsMeta\') continue;\n        var subdates = updates[worldId];\n        var sup = {};\n\n        for (var chunkId in subdates) {\n          if (!subdates.hasOwnProperty(chunkId)) continue;\n          var update = subdates[chunkId];\n\n          if (!update) {\n            this.unloadChunk(worldId, chunkId);\n          } else if (this.isChunkLoaded(worldId, chunkId) && update.length === 3) {\n            this.updateChunk(worldId, chunkId, update);\n          } else if (this.isChunkLoaded(worldId, chunkId) && update.length !== 3) {\n            console.error("WARN: corrupt update or model @refresh / updateChunk ".concat(chunkId, "."));\n            console.log(update);\n            this.chunkUpdates = [];\n            return;\n          } // Non-loaded chunk.\n          else if (update.length !== 2) {\n              console.error(\'WARN: corrupt update or model @refresh / initChunk.\');\n              console.log(update);\n              return; // One per iteration...\n            } else if (!mustReport) {\n              //console.log(\'[Server/Chunk] One more time\');\n              //console.log(\'[Server/Chunk] Initing\');\n              this.initializeChunk(worldId, chunkId, update);\n              mustReport = true;\n            } else {\n              //console.log(\'[Server/Chunk] Reporting\');\n              sup[chunkId] = update;\n            }\n        }\n\n        if (Object.keys(sup).length > 0) {\n          rup[worldId] = sup;\n        }\n      }\n\n      if (Object.keys(rup).length > 0) {\n        reportedUpdates.push(rup);\n      }\n    }\n\n    this.chunkUpdates = reportedUpdates;\n    if (reportedUpdates.length < 1) this.needsUpdate = false;\n  },\n  updateChunks: function updateChunks(updates) {\n    if (!updates) return;\n\n    if (this.debug) {\n      console.log(updates);\n      var nbcc = 0;\n\n      for (var cid in updates) {\n        if (updates[cid][1][1]) nbcc += updates[cid][1][1].length;\n      }\n\n      console.log(nbcc);\n    } // Stack updates, waiting for collector to refresh model.\n\n\n    this.chunkUpdates.push(updates);\n    this.needsUpdate = true;\n  },\n  isChunkLoaded: function isChunkLoaded(worldId, chunkId) {\n    var world = this.worlds.get(worldId);\n    return world && world.has(chunkId);\n  },\n  initializeChunk: function initializeChunk(worldId, chunkId, all) {\n    var graphics = this.app.engine.graphics; // Initialize model if a new world is transmitted.\n\n    var world = this.worlds.get(worldId);\n\n    if (!world) {\n      console.error("Got chunk ".concat(chunkId, " (").concat(chunks_typeof(worldId), ") from an unknown world: ").concat(worldId));\n      return;\n    }\n\n    var property = this.worldProperties.get(worldId);\n    var sizeX = property.chunkSizeX;\n    var sizeY = property.chunkSizeY;\n    var sizeZ = property.chunkSizeZ;\n    var worldMeta = this.worldProperties.get(worldId);\n\n    if (!worldMeta) {\n      console.error("World \\"".concat(worldId, "\\" type unknown."));\n      return;\n    }\n\n    var isWorldFlat = worldMeta.type === WorldType.FLAT; // || worldMeta.type === WorldType.FANTASY;\n    // Water cameras not yet supported with fantasy generation\n\n    var chunk = graphics.createChunk(chunkId, all, sizeX, sizeY, sizeZ, isWorldFlat, worldId);\n    world.set(chunkId, chunk); // Add to scene.\n\n    if (!chunk || !chunk.hasOwnProperty(\'meshes\')) {\n      console.error("WARN. Update miss @ initializeChunk: ".concat(chunkId));\n      console.log(all);\n      return;\n    }\n\n    var meshes = chunk.meshes;\n\n    for (var m = 0, l = meshes.length; m < l; ++m) {\n      graphics.addToScene(meshes[m], worldId);\n    }\n\n    if (chunk.shadow) {\n      graphics.addToShadows(chunk.shadow); // graphics.addToScene(chunk.shadow);\n      // const m = chunk.meshes[0];\n      // graphics.addToScene(m, worldId);\n      // let helper = new VertexNormalsHelper(m, 2, 0x00ff00, 1);\n      // graphics.addToScene(helper, worldId);\n    }\n\n    if (graphics._debugChunkBoundingBoxes) {\n      if (!chunk.debugMesh) console.error(\'[Server/Chunk] Missing debug mesh.\');\n      graphics.addToScene(chunk.debugMesh, worldId);\n    }\n  },\n  updateChunk: function updateChunk(worldId, chunkId, components) {\n    var graphics = this.app.engine.graphics;\n    var world = this.worlds.get(worldId);\n\n    if (!world) {\n      console.log(\'Error: updateChunk trying to access unloaded world.\');\n      return;\n    }\n\n    var property = this.worldProperties.get(worldId);\n    var chunk = world.get(chunkId);\n\n    if (!chunk) {\n      console.log(\'Error: updateChunk trying to update unloaded chunk.\');\n      return;\n    }\n\n    var sizeX = property.chunkSizeX;\n    var sizeY = property.chunkSizeY;\n    var sizeZ = property.chunkSizeZ;\n    var worldMeta = this.worldProperties.get(worldId);\n\n    if (!worldMeta) {\n      console.error("World \\"".concat(worldId, "\\" type unknown."));\n      return;\n    }\n\n    var isWorldFlat = worldMeta.type === WorldType.FLAT; // || worldMeta.type === WorldType.FANTASY;\n    // Water cameras not yet supported with fantasy generation\n\n    graphics.updateChunk(worldId, chunk, chunkId, components, sizeX, sizeY, sizeZ, isWorldFlat);\n  },\n  unloadChunk: function unloadChunk(worldId, chunkId) {\n    var graphics = this.app.engine.graphics;\n    var world = this.worlds.get(worldId);\n    if (!world) return;\n    var chunk = world.get(chunkId);\n\n    if (!chunk) {\n      console.log("WARN. Update miss @unloadChunk ".concat(chunkId));\n      return;\n    }\n\n    var meshes = chunk.meshes;\n\n    for (var m = 0, l = meshes.length; m < l; ++m) {\n      graphics.removeFromScene(meshes[m], worldId);\n    }\n\n    if (graphics._debugChunkBoundingBoxes) {\n      if (!chunk.debugMesh) console.error(\'[Server/Chunk] Missing debug mesh.\');\n      graphics.removeFromScene(chunk.debugMesh, worldId);\n    }\n\n    world["delete"](chunkId);\n  },\n  getCloseTerrain: function getCloseTerrain(worldId, position) {\n    // Only chunks within current world.\n    // Get overworld by default. WARN security.\n    if (!worldId) worldId = \'-1\';\n    var world = this.worlds.get(worldId);\n    if (!world) return;\n\n    if (!position) {\n      console.warn(\'[Raycaster] Player position undefined.\');\n      return;\n    }\n\n    var property = this.worldProperties.get(worldId);\n    if (!property) return;\n    var sizeX = property.chunkSizeX;\n    var sizeY = property.chunkSizeY;\n    var sizeZ = property.chunkSizeZ;\n    var cx = Math.floor(position.x / sizeX);\n    var cy = Math.floor(position.y / sizeY);\n    var cz = Math.floor(position.z / sizeZ);\n\n    var fmod = function fmod(b, n) {\n      return (Math.floor(b) % n + n) % n;\n    };\n\n    var fx = fmod(position.x, sizeX);\n    var sx2 = sizeX / 2;\n    var fy = fmod(position.y, sizeY);\n    var sy2 = sizeY / 2;\n    var fz = fmod(position.z, sizeZ);\n    var sz2 = sizeZ / 2;\n    var closestEight = [// this\n    "".concat(cx, ",").concat(cy, ",").concat(cz), // corner\n    "".concat(fx > sx2 ? cx + 1 : cx - 1, ",").concat(fy > sy2 ? cy + 1 : cy - 1, ",").concat(fz > sz2 ? cz + 1 : cz - 1), // edges\n    "".concat(fx > sx2 ? cx + 1 : cx - 1, ",").concat(fy > sy2 ? cy + 1 : cy - 1, ",").concat(cz), "".concat(fx > sx2 ? cx + 1 : cx - 1, ",").concat(cy, ",").concat(fz > sz2 ? cz + 1 : cz - 1), "".concat(cx, ",").concat(fy > sy2 ? cy + 1 : cy - 1, ",").concat(fz > sz2 ? cz + 1 : cz - 1), // faces\n    "".concat(fx > sx2 ? cx + 1 : cx - 1, ",").concat(cy, ",").concat(cz), "".concat(cx, ",").concat(cy, ",").concat(fz > sz2 ? cz + 1 : cz - 1), "".concat(cx, ",").concat(fy > sy2 ? cy + 1 : cy - 1, ",").concat(cz)];\n    var meshes = [];\n    world.forEach(function (currentChunk, cid) {\n      // XXX [GAMEPLAY] extract on 8 closest chunks.\n      if (!currentChunk || !currentChunk.hasOwnProperty(\'meshes\')) {\n        console.log("Warn: corrupted chunk inside client model ".concat(cid));\n        console.log(world);\n        return;\n      }\n\n      if (!cid) return;\n      var chunkCoords = cid.split(\',\');\n      if (!chunkCoords || chunkCoords.length !== 3) return;\n      var x = parseInt(chunkCoords[0], 10);\n      var y = parseInt(chunkCoords[1], 10);\n      var z = parseInt(chunkCoords[2], 10);\n      var nid = "".concat(x, ",").concat(y, ",").concat(z);\n      if (closestEight.indexOf(nid) < 0) return;\n      currentChunk.meshes.forEach(function (mesh) {\n        if (!!mesh && !!mesh.geometry) {\n          // empty chunk or geometry\n          meshes.push(mesh);\n        }\n      });\n    });\n    return meshes;\n  },\n  cleanup: function cleanup() {\n    this.worlds.forEach(function (w) {\n      w.forEach(function (currentChunk) {\n        if (!!currentChunk && currentChunk.hasOwnProperty(\'meshes\')) {\n          currentChunk.meshes.forEach(function (mesh) {\n            mesh.geometry.dispose();\n            mesh.material.dispose();\n          });\n        }\n      });\n      w.clear();\n    });\n    this.worlds.clear();\n    this.worldProperties.clear();\n    this.chunkUpdates = []; // Sky collection.\n\n    this.skies.forEach(function (s) {\n      if (s.mesh) {\n        s.mesh.geometry.dispose();\n        s.mesh.material.dispose();\n      }\n\n      if (s.helper && s.helper.mesh) {\n        s.helper.mesh.geometry.dispose();\n        s.helper.mesh.material.dispose();\n      }\n    });\n    this.skies.clear(); // Graphical component.\n\n    this.needsUpdate = false;\n    this.debug = false; // XXX [CLEANUP] all meshes\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/sky/skies.js\n/**\n * Sky management functions.\n */\n\n\n\n\n\n\nvar SkyModule = {\n  createFlatSky: function createFlatSky(worldId) {\n    // Mesh\n    var sky = new sky_SkyFlat();\n    sky.scale.setScalar(450000); // Light\n\n    var lights = this.createSkyLight(new three_module["Sb" /* Vector3 */](-1, -2, -1), \'flat\', worldId);\n    return {\n      mesh: sky,\n      lights: lights\n    };\n  },\n  createCubeSky: function createCubeSky(center, radius) {\n    // Mesh\n    var sky = new sky_SkyCube(center.x, center.y, center.z, radius);\n    sky.scale.setScalar(450000); // Colored cube helper\n\n    var g = new three_module["h" /* BoxBufferGeometry */](2 * radius, 2 * radius, 2 * radius);\n    var m = new three_module["ab" /* MeshNormalMaterial */]({\n      wireframe: true\n    });\n    var helper = new three_module["W" /* Mesh */](g, m);\n    helper.position.y = center.y;\n    helper.position.z = center.z;\n    helper.position.x = center.x; // Light\n\n    var lights = this.createSkyLight(new three_module["Sb" /* Vector3 */](-1, -2, -1), \'cube\');\n    return {\n      mesh: sky,\n      helper: helper,\n      lights: lights\n    };\n  },\n  createSkyLight: function createSkyLight(sunPosition, lightType, worldId) {\n    // Dir\n    var light1 = this.createLight(\'sun\', worldId, lightType); // light1.position.set(-1, -2, -1);\n\n    var np = new three_module["Sb" /* Vector3 */]();\n    np.copy(sunPosition).normalize();\n    light1.position.set(np.x, np.y, np.z);\n    light1.position.set(0, 0, 0); // light1.updateMatrixWorld();\n    // Hemisphere\n\n    var light2 = this.createLight(\'hemisphere\'); // light2.position.set(-1, -2, -10);\n\n    light2.position.set(np.x, np.y, np.z); // light2.updateMatrixWorld();\n    // Ambient\n\n    var light3 = this.createLight(); // light3.position.set(-1, -2, -10);\n\n    light3.position.set(np.x, np.y, np.z); // light3.updateMatrixWorld();\n\n    return {\n      directionalLight: light1,\n      hemisphereLight: light2,\n      ambientLight: light3,\n      type: lightType\n    };\n  },\n  createSunSphere: function createSunSphere() {\n    var sunSphere = new three_module["W" /* Mesh */](new three_module["Ib" /* SphereBufferGeometry */](20000, 16, 8), new three_module["X" /* MeshBasicMaterial */]({\n      color: 0xffffff\n    }));\n    sunSphere.position.y = -700000;\n    sunSphere.visible = false;\n    return sunSphere;\n  },\n  addSky: function addSky(worldId, worldMeta) {\n    if (!worldMeta) console.log(\'[Chunks] Default sky creation.\');\n    var sunPosition = new three_module["Sb" /* Vector3 */](0, -700000, 0);\n    var sky;\n    var skyType = worldMeta.type;\n\n    if (skyType === WorldType.CUBE) {\n      if (!worldMeta.center || !worldMeta.radius) {\n        console.error(\'[Chunks/NewSky]: No center and radius specified.\');\n        return;\n      }\n\n      if (worldMeta.chunkSizeX !== worldMeta.chunkSizeY || worldMeta.chunkSizeX !== worldMeta.chunkSizeZ) {\n        console.error(\'[Chunks/NewSky]: Cube world must have cube chunks.\');\n        return;\n      }\n\n      var chunkSize = worldMeta.chunkSizeX;\n      var center = new three_module["Sb" /* Vector3 */]((worldMeta.center.x + 0.5) * chunkSize, (worldMeta.center.y + 0.5) * chunkSize, (worldMeta.center.z + 0.5) * chunkSize - 1);\n      var radius = Math.max(worldMeta.radius, 1) * chunkSize - 1;\n      sky = this.createCubeSky(center, radius);\n      this.addToScene(sky.mesh, worldId);\n      this.addToScene(sky.lights.hemisphereLight, worldId);\n      this.addToScene(sky.lights.directionalLight, worldId); // this.addToScene(sky.helper, worldId);\n      // let sunSphere = this.createSunSphere();\n      // this.addToScene(sunSphere, worldId);\n      // turbidity = 1\n      // rayleigh = 0.25   or 0.5 and mieCoeff = 0.0\n      // mieDirectionalG = 0.0\n\n      this.updateSky(sky.mesh, sunPosition, 10, 2, 0.005, 0.8, 1.0, -0.15, // 0.49; // elevation / inclination\n      0.0, // Facing front\n      true // isSunSphereVisible\n      );\n    } else if (skyType === WorldType.FLAT || skyType === WorldType.FANTASY) {\n      sky = this.createFlatSky(worldId);\n      this.addToScene(sky.mesh, worldId);\n      this.addToScene(sky.lights.hemisphereLight, worldId);\n      this.addToScene(sky.lights.directionalLight, worldId); // this.addToScene(sky.lights.ambientLight, worldId);\n\n      this.updateSky(sky.mesh, sunPosition, 10, 2, 0.005, 0.8, 1.0, -0.15, // 0.49; // elevation / inclination\n      0.0, // Facing front\n      true // isSunSphereVisible\n      );\n    } else {\n      console.error(\'Unsupported sky type.\');\n      return;\n    }\n\n    return sky;\n  },\n  getSunDirection: function getSunDirection(skyObject) {\n    var distance = this.distance;\n    var phi = skyObject.phi || 0;\n    var theta = this.theta;\n    var x = distance * Math.cos(phi);\n    var y = distance * Math.sin(phi) * Math.sin(theta);\n    var z = distance * Math.sin(phi) * Math.cos(theta);\n    var sunDirection = new three_module["Sb" /* Vector3 */](-x, y, z);\n    sunDirection.normalize().negate();\n    return sunDirection;\n  },\n  // XXX [SKY] sync (or seed?) sun position from server\n  updateSunPosition: function updateSunPosition(camera, skyObject, worldId) {\n    var sky = skyObject.mesh;\n    if (!sky || !this.distance) return;\n    var s = sky;\n    var cos = Math.cos;\n    var sin = Math.sin;\n    var distance = this.distance;\n    var phi = skyObject.phi || 0;\n    var theta = this.theta;\n    phi %= 2 * Math.PI; // let dist = Math.max(0.1,\n    // Math.min(Math.abs(Math.PI - phi),\n    // Math.abs(phi)) / Math.PI); // in (0,1)\n\n    phi += 0.000101; // * dist;\n    // phi = Math.PI / 2; // * dist;\n\n    skyObject.phi = phi;\n    var x = distance * cos(phi);\n    var y = distance * sin(phi) * sin(theta);\n    var z = distance * sin(phi) * cos(theta);\n    var sunPosition = new three_module["Sb" /* Vector3 */](x, y, z);\n    var camPosition;\n\n    if (camera.projectionMatrix) {\n      // let mat4 = new THREE.Matrix4();\n      // mat4.set(\n      //     camera.fov, camera.aspect, camera.far, camera.near,\n      //     0, 0, 0, 0,\n      //     0, 0, 0, 0,\n      //     0, 0, 0, 0);\n      // mat4.getInverse(camera.projectionMatrix);\n      // s.material.uniforms.viewInverse.value.copy(mat4);\n      camPosition = new three_module["Sb" /* Vector3 */]();\n      camera.getWorldPosition(camPosition);\n      s.material.uniforms.cameraPos.value.copy(camPosition);\n    }\n\n    s.material.uniforms.sunPosition.value.copy(sunPosition); // Better not touch this!\n    // This accounts for skybox translations in sky shaders.\n\n    var model = this.app.model.server;\n    var p = model.selfModel.position;\n    if (!p) return;\n    sky.position.copy(p);\n    sky.updateMatrix();\n    var worldMeta = model.chunkModel.worldProperties.get(worldId);\n    var isWorldFlat = worldMeta.type === WorldType.FLAT; // Update lights\n\n    var normSunPosition = new three_module["Sb" /* Vector3 */]();\n    normSunPosition.copy(sunPosition).normalize();\n    var hl = skyObject.lights.hemisphereLight;\n    var dl = skyObject.lights.directionalLight;\n    hl.position.copy(normSunPosition);\n    dl.position.copy(normSunPosition).multiplyScalar(60);\n\n    if (isWorldFlat && camPosition && this.hasShadowMap()) {\n      var dp = dl.position;\n      dp.set(dp.x + camPosition.x, dp.y + camPosition.y, dp.z);\n      dl.target.position.set(camPosition.x, camPosition.y, 0);\n      dl.target.updateMatrixWorld();\n    } // Sunset and sunrise\n\n\n    if (skyObject.lights.type === \'flat\') {\n      var nz = Math.max(normSunPosition.z, 0);\n      var intensityFactor = Math.pow(nz, 0.1);\n      hl.intensity = LightDefaultIntensities.HEMISPHERE * intensityFactor;\n      dl.intensity = LightDefaultIntensities.DIRECTIONAL * intensityFactor;\n\n      if (nz === 0) {\n        var onz = Math.max(-normSunPosition.z, 0);\n        intensityFactor = Math.pow(onz, 0.1);\n        hl.position.copy(new three_module["Sb" /* Vector3 */](0, 0, -1));\n        hl.intensity = intensityFactor * 0.3;\n        dl.intensity = 0;\n        hl.groundColor = new three_module["n" /* Color */](0x0000ff);\n        hl.skyColor = new three_module["n" /* Color */](0x0000ff);\n      } else {\n        hl.skyColor = new three_module["n" /* Color */](LightDefaultColors.HEMISPHERE_SKY);\n        hl.groundColor = new three_module["n" /* Color */](LightDefaultColors.HEMISPHERE_GROUND);\n      }\n    }\n  },\n  updateSky: function updateSky(sky, sunPosition, turbidity, //: 10,\n  rayleigh, //: 2,\n  mieCoefficient, //: 0.005,\n  mieDirectionalG, //: 0.8,\n  luminance, //: 1,\n  inclination, // 0.49, elevation / inclination\n  azimuth) //: 0.25, Facing front\n  {\n    var sin = Math.sin;\n    var cos = Math.cos;\n    var uniforms = sky.material.uniforms;\n    if (!uniforms) return;\n    uniforms.turbidity.value = turbidity;\n    uniforms.rayleigh.value = rayleigh;\n    uniforms.luminance.value = luminance;\n    uniforms.mieCoefficient.value = mieCoefficient;\n    uniforms.mieDirectionalG.value = mieDirectionalG;\n    var theta = 0; // 2 * Math.PI * (inclination - 0.5);\n\n    var phi = 4 * Math.PI * (azimuth - 0.5);\n    var distance = 400000;\n    this.distance = distance;\n    this.phi = phi;\n    this.theta = theta;\n    sunPosition.x = distance * cos(phi);\n    sunPosition.y = distance * sin(phi) * sin(theta);\n    sunPosition.z = distance * sin(phi) * cos(theta);\n    uniforms.sunPosition.value.copy(sunPosition);\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/graphics/graphics.js\n/**\n * Front-end graphics.\n */\n\n\n // Base dependencies.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Graphics = function Graphics(app) {\n  // App and access to models.\n  this.app = app; // User customizable settings.\n\n  this.debug = false; // Properties.\n\n  this.windowHalfX = window.innerWidth / 2;\n  this.windowHalfY = window.innerHeight / 2;\n  this.defaultGeometrySize = 64; // This could be customized\n\n  this._defaultEmptyChunkSize = 16; // Rendering.\n\n  this.requestId = null;\n  this.sceneManager = this.createSceneManager();\n  this.rendererManager = this.createRendererManager();\n  this.cameraManager = this.createCameraManager(); // Interaction.\n\n  this.controls = null; // Textures\n\n  this.textureAtlas = null;\n  this.textureWaterNormals = null;\n  this.textureCoordinates = null;\n  this._nbTexturesLoaded = 0;\n  this._nbTexturesToLoad = 0; // Water\n\n  this.oneWater = false; // Meshes\n\n  this.referenceMeshes = null;\n  this._nbMeshesToLoad = 0;\n  this._nbMeshesLoadedOrError = 0;\n  this._debugChunkBoundingBoxes = false; // Materials\n\n  this.instancedMaterials = new Map(); // Chunks\n\n  this.waterMaterials = new Map(); // Waters\n\n  this.waterRTTResolution = 512; // Animations\n\n  this.mixers = null; // Optimizations\n\n  this.portalUpdates = [];\n  this.lastRenderPaths = new Set();\n  this.lastRenderGates = new Set();\n  this.previousFrameWorld = null;\n  this.currentFrameWorld = null; // Firefox setInterval issue\n\n  var isFirefox = navigator.userAgent.toLowerCase().indexOf(\'firefox\') > -1;\n  this._bindStandalone = isFirefox;\n};\n\nextend(Graphics.prototype, CoreModule);\nextend(Graphics.prototype, ControlsModule);\nextend(Graphics.prototype, LightModule);\nextend(Graphics.prototype, MaterialsModule);\nextend(Graphics.prototype, MeshesModule);\nextend(Graphics.prototype, TexturesModule);\nextend(Graphics.prototype, EntitiesModule);\nextend(Graphics.prototype, ItemsGraphicsModule);\nextend(Graphics.prototype, AnimationsModule);\nextend(Graphics.prototype, PortalsModule);\nextend(Graphics.prototype, CamerasModule);\nextend(Graphics.prototype, RenderersModule);\nextend(Graphics.prototype, ScenesModule);\nextend(Graphics.prototype, FacesModule);\nextend(Graphics.prototype, ChunksModule);\nextend(Graphics.prototype, ChunksMeshModule);\nextend(Graphics.prototype, ShadersModule);\nextend(Graphics.prototype, SkyModule);\n\n// CONCATENATED MODULE: ./client/app/engine/audio/sound.js\n/**\n *\n */\n\n\nvar Sound = function Sound(name, buffer) {\n  this.name = name;\n  this.buffer = buffer;\n  this.playing = false;\n\n  this.play = function () {\n    this.stopAllSounds();\n    this.source = this.audioContext.createBufferSource();\n    this.source.buffer = buffer;\n    this.source.connect(this.audioContext.destination);\n    this.playing = true;\n    this.source.start();\n  }.bind(this);\n};\n\n\n// CONCATENATED MODULE: ./client/app/engine/audio/audio.js\n/**\n * Audio.\n */\n\n\n\n\n\nvar Audio = function Audio(app) {\n  this.app = app; // User customizable settings.\n\n  this.settings = {};\n  this.audioContext = null;\n  this.source = null;\n  this.sounds = {\n    all: [//\'sound01\',\n      //\'sound02\'\n    ]\n  };\n};\n\nextend(Audio.prototype, {\n  run: function run() {\n    var audioContext;\n\n    function loadSound(name, callback) {\n      var xObj = new XMLHttpRequest();\n      xObj.open(\'GET\', "audio/".concat(name, ".mp3"), true);\n      xObj.responseType = \'arraybuffer\';\n\n      xObj.onreadystatechange = function () {\n        if (parseInt(xObj.readyState, 10) === 4 && parseInt(xObj.status, 10) === 200) {\n          audioContext.decodeAudioData(xObj.response, function (buffer) {\n            callback(buffer);\n          });\n        }\n      };\n\n      xObj.send(null);\n    }\n\n    try {\n      window.AudioContext = window.AudioContext || window.webkitAudioContext;\n      this.audioContext = new AudioContext();\n      var sounds = this.sounds;\n      sounds.all.forEach(function (sound) {\n        loadSound(sound, function (buffer) {\n          sounds[sound] = new Sound(sound, buffer);\n        });\n      });\n    } catch (e) {\n      /*\n       $("#content").fadeOut(function() {\n       $(this).html($("#contentNoAudio").html(),\'fast\').fadeIn(\'fast\');\n       });\n       */\n    }\n  },\n  stop: function stop() {\n    this.stopAllSounds();\n  },\n  stopAllSounds: function stopAllSounds() {\n    var sounds = this.sounds;\n    sounds.all.forEach(function (sound) {\n      if (sounds[sound].source !== null && sounds[sound].playing) {\n        sounds[sound].source.stop();\n        sounds[sound].playing = false;\n      }\n    });\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/engine/controls/keyboard/listeners.js\n/**\n *\n */\n\n\n\nvar ListenerModule = {\n  /**\n   * Keyboard behaviour when a key is pressed.\n   */\n  registerKeyDown: function registerKeyDown() {\n    var app = this.app;\n    jquery_default()(window).keydown(function (event) {\n      event.preventDefault();\n\n      if (!event.keyCode) {\n        return;\n      }\n\n      if (app.getState() !== \'ingame\') return;\n      var k = this.keyControls;\n      var clientModel = app.model.client;\n      var graphics = app.engine.graphics; // XXX [GAMEPLAY] numpad / num shortcuts\n\n      switch (event.keyCode) {\n        case k.arrowUp:\n        case k.leftHandUp:\n          clientModel.triggerEvent(\'m\', \'f\');\n          break;\n\n        case k.arrowRight:\n        case k.leftHandRight:\n          clientModel.triggerEvent(\'m\', \'r\');\n          break;\n\n        case k.arrowLeft:\n        case k.leftHandLeft:\n          clientModel.triggerEvent(\'m\', \'l\');\n          break;\n\n        case k.arrowDown:\n        case k.leftHandDown:\n          clientModel.triggerEvent(\'m\', \'b\');\n          break;\n\n        case k.shift:\n          clientModel.triggerEvent(\'m\', \'run\');\n          break;\n\n        case k.control:\n          clientModel.triggerEvent(\'m\', \'d\');\n          break;\n\n        case k.space:\n          clientModel.triggerEvent(\'m\', \'u\');\n          break;\n\n        case k.leftHandEast2:\n          // F, toggle third-person\n          clientModel.triggerChange(\'camera\', [\'toggle\']);\n          break;\n\n        case k.leftHandNorthEast2:\n          // R\n          break;\n\n        case k.pageUp:\n          // Trackpad users without a mousewheel\n          clientModel.triggerChange(\'interaction\', [\'itemSelect\', 1]);\n          break;\n\n        case k.pageDown:\n          clientModel.triggerChange(\'interaction\', [\'itemSelect\', -1]);\n          break;\n\n        case k.leftHandEast3:\n          // (G)ravity.\n          clientModel.triggerEvent(\'a\', \'g\');\n          break;\n\n        case k.leftHandNorthWest:\n          // A\n          break;\n        // This is for camera wrapper testing, should be disabled server-wise.\n\n        case k.padFour:\n          // Left\n          graphics.cameraManager.addCameraRotationEvent(0, 0, 0.1 * Math.PI / 2, 0);\n          break;\n\n        case k.padSix:\n          // Right\n          graphics.cameraManager.addCameraRotationEvent(0, 0, 0.1 * -Math.PI / 2, 0);\n          break;\n\n        case k.padFive:\n          // Down\n          graphics.cameraManager.addCameraRotationEvent(0, 0, 0, 0.1 * -Math.PI / 2);\n          break;\n\n        case k.padEight:\n          // Up\n          graphics.cameraManager.addCameraRotationEvent(0, 0, 0, 0.1 * Math.PI / 2);\n          break;\n\n        case k.enter:\n          // Implementation instructions [CHAT]:\n          // 1. remove keyboard and mouse listeners until the user has finished typing.\n          // 2. show AOE-like dialog for chat messages\n          // 3. on validate, send message to server via chat module\n          // Maybe a better option: create a new \'chatting\' state using stateManager, that takes care of\n          // key, mouse (and other like touch) listeners.\n          break;\n\n        default: // this.stopKeyboardInteraction();\n\n      }\n    }.bind(this));\n  },\n  // Manage alt-tab like border effects\n  stopKeyboardInteraction: function stopKeyboardInteraction() {\n    var clientModel = this.app.model.client;\n    clientModel.triggerEvent(\'m\', \'xx\');\n  },\n\n  /**\n   * Keyboard behaviour when a key is released.\n   */\n  registerKeyUp: function registerKeyUp() {\n    var app = this.app;\n    jquery_default()(window).keyup(function (event) {\n      event.preventDefault();\n      if (!event.keyCode) return;\n      if (app.getState() !== \'ingame\') return;\n      var k = this.keyControls;\n      var clientModel = app.model.client;\n\n      switch (event.keyCode) {\n        case k.arrowUp:\n        case k.leftHandUp:\n          clientModel.triggerEvent(\'m\', \'fx\');\n          break;\n\n        case k.arrowRight:\n        case k.leftHandRight:\n          clientModel.triggerEvent(\'m\', \'rx\');\n          break;\n\n        case k.arrowLeft:\n        case k.leftHandLeft:\n          clientModel.triggerEvent(\'m\', \'lx\');\n          break;\n\n        case k.arrowDown:\n        case k.leftHandDown:\n          clientModel.triggerEvent(\'m\', \'bx\');\n          break;\n\n        case k.control:\n          clientModel.triggerEvent(\'m\', \'dx\');\n          break;\n\n        case k.shift:\n          clientModel.triggerEvent(\'m\', \'runx\');\n          break;\n\n        case k.space:\n          clientModel.triggerEvent(\'m\', \'ux\');\n          break;\n\n        default:\n      }\n    }.bind(this));\n  },\n  unregisterKeyDown: function unregisterKeyDown() {\n    jquery_default()(window).off(\'keydown\');\n  },\n  unregisterKeyUp: function unregisterKeyUp() {\n    jquery_default()(window).off(\'keyup\');\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/controls/keyboard/keys.js\n/**\n *\n */\n\n\nvar KeysModule = {\n  /**\n   * Get key codes (internationalization required).\n   * @param layout\n   */\n  getKeyControls: function getKeyControls(layout) {\n    var keyControls;\n\n    switch (layout) {\n      case \'en\':\n      case \'en-US\':\n      case \'en-GB\':\n        keyControls = this.getQWERTY();\n        break;\n\n      case \'fr\':\n        keyControls = this.getAZERTY();\n        break;\n\n      default:\n        console.log(\'Invalid keyboard layout. Switching to English as default.\');\n        keyControls = this.getQWERTY();\n        return;\n    }\n\n    return keyControls;\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/controls/keyboard/layout.azerty.js\n/**\n *\n */\n\n\nvar LayoutAZERTY = {\n  getAZERTY: function getAZERTY() {\n    return Object.freeze({\n      // Arrow directional controls.\n      arrowUp: 38,\n      arrowDown: 40,\n      arrowRight: 39,\n      arrowLeft: 37,\n      // Left hand directional controls.\n      leftHandUp: 90,\n      // Z\n      leftHandLeft: 81,\n      // Q\n      leftHandDown: 83,\n      // S\n      leftHandRight: 68,\n      // D\n      // Left hand advanced controls.\n      leftHandNorthWest: 65,\n      // A\n      leftHandNorthEast: 69,\n      // E\n      leftHandNorthEast2: 82,\n      // R\n      leftHandEast2: 70,\n      // F\n      leftHandSouthWest: 87,\n      // W\n      leftHandSouth: 88,\n      // X\n      leftHandSouthEast: 67,\n      // C\n      // Modifiers.\n      alt: 18,\n      shift: 16,\n      control: 17,\n      tab: 9,\n      // Misc.\n      escape: 27,\n      space: 32,\n      backspace: 8,\n      enter: 13,\n      pageUp: 33,\n      pageDown: 34,\n      // Number line.\n      one: 49,\n      two: 50,\n      three: 51,\n      four: 52,\n      five: 53,\n      six: 54,\n      seven: 55,\n      eight: 56,\n      nine: 57,\n      // Number pad.\n      // 1. if verr.num is activated.\n      padOne: 97,\n      padTwo: 98,\n      padThree: 99,\n      padFour: 100,\n      padFive: 101,\n      padSix: 102,\n      padSeven: 103,\n      padEight: 104,\n      padNine: 105,\n      // 2. if verr.num is not activated\n      padOneAlt: 35,\n      padTwoAlt: 40,\n      padThreeAlt: 34,\n      padFourAlt: 37,\n      padFiveAlt: 12,\n      padSixAlt: 39,\n      padSevenAlt: 36,\n      padEightAlt: 38,\n      padNineAlt: 33,\n      // All other letters\n      leftHandNorthEast3: 84,\n      // T\n      leftHandEast3: 71,\n      // G\n      leftHandSouthEast3: 86,\n      // V\n      rightHandUp: 73,\n      // I\n      rightHandDown: 75,\n      // K\n      rightHandLeft: 74,\n      // J\n      rightHandLeft2: 72,\n      // H\n      rightHandRight: 76,\n      // L\n      rightHandRight2: 77,\n      // M\n      rightHandSouth: 190,\n      // .\n      rightHandNorthWest: 85,\n      // U\n      rightHandNorthWest2: 89,\n      // Y\n      rightHandNorthEast: 79,\n      // O\n      rightHandNorthEast2: 80,\n      // P\n      rightHandSouthWest: 188,\n      // ,\n      rightHandSouthWest2: 78,\n      // N\n      rightHandSouthWest3: 66,\n      // B\n      rightHandSouthEast: 191,\n      // /\n      rightHandSouthEast2: 223 // \n\n    });\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/controls/keyboard/layout.qwerty.js\n/**\n *\n */\n\n\nvar LayoutQWERTY = {\n  getQWERTY: function getQWERTY() {\n    return Object.freeze({\n      // Arrow directional controls.\n      arrowUp: 38,\n      arrowDown: 40,\n      arrowRight: 39,\n      arrowLeft: 37,\n      // Left hand directional controls.\n      leftHandUp: 87,\n      // W\n      leftHandLeft: 65,\n      // A\n      leftHandDown: 83,\n      // S\n      leftHandRight: 68,\n      // D\n      // Left hand advanced controls.\n      leftHandNorthWest: 81,\n      // Q\n      leftHandNorthEast: 69,\n      // E\n      leftHandNorthEast2: 82,\n      // R\n      leftHandEast2: 70,\n      // F\n      leftHandSouthWest: 90,\n      // Z\n      leftHandSouth: 88,\n      // X\n      leftHandSouthEast: 67,\n      // C\n      // Modifiers.\n      alt: 18,\n      shift: 16,\n      control: 17,\n      tab: 9,\n      // Misc.\n      escape: 27,\n      space: 32,\n      backspace: 8,\n      enter: 13,\n      pageUp: 33,\n      pageDown: 34,\n      // Number line.\n      one: 49,\n      two: 50,\n      three: 51,\n      four: 52,\n      five: 53,\n      six: 54,\n      seven: 55,\n      eight: 56,\n      nine: 57,\n      // Number pad.\n      // 1. if verr.num is activated.\n      padOne: 97,\n      padTwo: 98,\n      padThree: 99,\n      padFour: 100,\n      padFive: 101,\n      padSix: 102,\n      padSeven: 103,\n      padEight: 104,\n      padNine: 105,\n      // 2. if verr.num is not activated\n      padOneAlt: 35,\n      padTwoAlt: 40,\n      padThreeAlt: 34,\n      padFourAlt: 37,\n      padFiveAlt: 12,\n      padSixAlt: 39,\n      padSevenAlt: 36,\n      padEightAlt: 38,\n      padNineAlt: 33,\n      // All other letters\n      leftHandNorthEast3: 84,\n      // T\n      leftHandEast3: 71,\n      // G\n      leftHandSouthEast3: 86,\n      // V\n      rightHandUp: 73,\n      // I\n      rightHandDown: 75,\n      // K\n      rightHandLeft: 74,\n      // J\n      rightHandLeft2: 72,\n      // H\n      rightHandRight: 76,\n      // L\n      rightHandRight2: 186,\n      // ;\n      rightHandSouth: 188,\n      // ,\n      rightHandNorthWest: 85,\n      // U\n      rightHandNorthWest2: 89,\n      // Y\n      rightHandNorthEast: 79,\n      // O\n      rightHandNorthEast2: 80,\n      // P\n      rightHandSouthWest: 77,\n      // M\n      rightHandSouthWest2: 78,\n      // N\n      rightHandSouthWest3: 66,\n      // B\n      rightHandSouthEast: 190,\n      // .\n      rightHandSouthEast2: 191 // /\n\n    });\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/controls/keyboard/layout.custom.js\n/**\n *\n */\n\n\nvar LayoutCustom = {\n  setupCustomLayout: function setupCustomLayout(newBinding) {\n    if (!newBinding || newBinding.length !== 2) {\n      console.log("Binding ".concat(newBinding, " not supported."));\n      return;\n    }\n\n    var k = this.keyControls;\n    var action = newBinding[0];\n    var keyCode = newBinding[1];\n\n    if (k.hasOwnProperty(action)) {\n      // Determine whether key is already used.\n      for (var _action in k) {\n        if (_action === action) continue;\n\n        if (k[_action] === keyCode) {\n          // Switch.\n          k[_action] = k[action];\n          k[action] = keyCode;\n          return;\n        }\n      } // New keycode.\n\n\n      k[action] = keyCode;\n    } else {\n      console.log("Binding ".concat(newBinding, " not supported."));\n    }\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/controls/keyboard/keyboard.js\n/**\n *\n */\n\n\n\n\n\n\n\n\nvar KeyboardModule = {\n  setupKeyboard: function setupKeyboard() {\n    // Try to detect user language\n    this.settings.language = window.navigator.userLanguage || window.navigator.language || \'en-US\';\n    this.settings.language = \'en\';\n    if (navigator.language === \'fr-FR\' || navigator.language === \'fr\') this.settings.language = \'fr\'; // Controls\n\n    this.keyControls = this.getKeyControls(this.settings.language); // Tweak for filtering some events...\n    // this.tweak = 0;\n  },\n  startKeyboardListeners: function startKeyboardListeners() {\n    if (this.isTouch) console.warn(\'[Keyboard] requested keyboard listeners on a touch device.\');\n    this.registerKeyDown();\n    this.registerKeyUp();\n  },\n  stopKeyboardListeners: function stopKeyboardListeners() {\n    this.stopKeyboardInteraction();\n    this.unregisterKeyDown();\n    this.unregisterKeyUp();\n  },\n\n  /**\n   * @param newLayout\n   *      Layout language (en or fr) to use from now on.\n   * @param dontRestartListeners\n   *      If the method should keep listeners silent.\n   * @param newBinding\n   *      Optional. For custom layouts, a new [action, key] binding.\n   */\n  changeLayout: function changeLayout(newLayout, dontRestartListeners, newBinding) {\n    // Prevent keys from being fired when configuring.\n    this.stopKeyboardListeners();\n\n    switch (newLayout) {\n      case \'fr\':\n      case \'en\':\n      case \'en-US\':\n      case \'en-GB\':\n        this.keyControls = this.getKeyControls(newLayout);\n        break;\n\n      case \'custom\':\n      default:\n        this.setupCustomLayout(newBinding);\n    } // Restore event listeners.\n\n\n    if (!dontRestartListeners) this.startKeyboardListeners();\n  }\n}; // Pack module.\n\nextend(KeyboardModule, ListenerModule);\nextend(KeyboardModule, KeysModule);\nextend(KeyboardModule, LayoutAZERTY);\nextend(KeyboardModule, LayoutQWERTY);\nextend(KeyboardModule, LayoutCustom);\n\n// CONCATENATED MODULE: ./client/app/engine/controls/mouse/first-person.js\n/**\n *\n */\n\n\nvar FirstPersonModule = {\n  onMouseMove: function onMouseMove(event) {\n    if (!this.threeControlsEnabled) return;\n    var movementX = event.movementX; // ||\n    //     event.mozMovementX ||\n    //     event.webkitMovementX || 0;\n\n    var movementY = event.movementY; // ||\n    //     event.mozMovementY ||\n    //     event.webkitMovementY || 0;\n    // console.log(movementX);\n    //let rotation = graphics.cameraManager.moveCameraFromMouse(movementX, movementY);\n\n    var cameraManager = this.app.engine.graphics.cameraManager;\n    cameraManager.addCameraRotationEvent(movementX, movementY, 0, 0);\n  },\n  unregisterMouseMove: function unregisterMouseMove() {\n    if (!this.omm) {\n      console.error(\'[FPS] Failed to get listener.\');\n      return;\n    }\n\n    document.removeEventListener(\'mousemove\', this.omm, false);\n  },\n  registerMouseMove: function registerMouseMove() {\n    if (!this.omm) {\n      this.omm = this.onMouseMove.bind(this);\n    }\n\n    document.addEventListener(\'mousemove\', this.omm, true);\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/controls/mouse/listeners.js\n/**\n *\n */\n\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || listeners_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction listeners_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return listeners_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return listeners_arrayLikeToArray(o, minLen); }\n\nfunction listeners_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\nvar listeners_ListenerModule = {\n  registerMouseDown: function registerMouseDown() {\n    var scope = this;\n    var app = this.app;\n    jquery_default()(window).mousedown(function (event) {\n      if (app.getState() !== \'ingame\') return;\n\n      switch (event.which) {\n        case scope.buttons.left:\n          /*\n           There is a bug with some laptop touch pads that prevents the browser from triggering\n           the LEFT click when a \'keydown\' event was fired in the near past (~200ms?).\n           In this case, it will be impossible to move and add a block at the same time with basic controls.\n           Everything works OK with the right and middle click (i.e. both on touch pads), so just\n           make the user reassign the \'left click\' control key if they are in such a case.\n           */\n          scope.onLeftMouseDown();\n          break;\n\n        case scope.buttons.middle:\n          scope.onMiddleMouseDown();\n          break;\n\n        case scope.buttons.right:\n          scope.onRightMouseDown();\n          break;\n\n        default:\n      }\n    });\n  },\n  registerMouseUp: function registerMouseUp() {\n    var scope = this;\n    var app = this.app;\n    jquery_default()(window).mouseup(function (event) {\n      if (app.getState() !== \'ingame\') return;\n\n      switch (event.which) {\n        case scope.buttons.left:\n          scope.onLeftMouseUp();\n          break;\n\n        case scope.buttons.middle:\n          scope.onMiddleMouseUp();\n          break;\n\n        case scope.buttons.right:\n          scope.onRightMouseUp();\n          break;\n\n        default:\n      }\n    });\n  },\n  getRaycastCoordinates: function getRaycastCoordinates() {\n    var graphicsEngine = this.app.engine.graphics; // Perform intersection.\n\n    var intersects = graphicsEngine.cameraManager.performRaycast();\n\n    if (intersects.length <= 0) {\n      console.log(\'[Listeners] Nothing intersected.\');\n      return;\n    } // Get closest intersection point.\n\n\n    var min = intersects[0];\n\n    for (var i = 1; i < intersects.length; ++i) {\n      var ii = intersects[i];\n      if (ii.distance < min.distance) min = ii;\n    }\n\n    var point = min.point; // Compute blocks.\n\n    var flo = Math.round;\n    var abs = Math.abs;\n    var rx = point.x;\n    var ry = point.y;\n    var rz = point.z;\n    var dx = abs(abs(flo(rx)) - abs(rx));\n    var dy = abs(abs(flo(ry)) - abs(ry));\n    var dz = abs(abs(flo(rz)) - abs(rz));\n    var ex = dx < 0.0000001;\n    if (ex) rx = flo(rx);\n    var ey = dy < 0.0000001;\n    if (ey) ry = flo(ry);\n    var ez = dz < 0.0000001;\n    if (ez) rz = flo(rz);\n\n    if (ex + ey + ez !== 1) {\n      console.log("".concat(ex, ",").concat(ey, ",").concat(ez));\n      console.warn(\'[OnLeftMouse] Error: precision on intersection @addBlock.\');\n      return;\n    }\n\n    return [ex, ey, ez, rx, ry, rz];\n  },\n  requestAddBlock: function requestAddBlock(isMainButton) {\n    var clientModel = this.app.model.client;\n    var graphicsEngine = this.app.engine.graphics;\n    var r = this.getRaycastCoordinates();\n    if (!r) return;\n\n    var _r = _slicedToArray(r, 6),\n        ex = _r[0],\n        ey = _r[1],\n        ez = _r[2],\n        rx = _r[3],\n        ry = _r[4],\n        rz = _r[5];\n\n    var flo = Math.floor;\n    var p = graphicsEngine.getCameraCoordinates();\n    var px = p.x;\n    var py = p.y;\n    var pz = p.z;\n    var fx1;\n    var fy1;\n    var fz1;\n    var positiveIsFree = true; // direct + axis is empty\n\n    if (ex) {\n      positiveIsFree = px > rx;\n\n      if (positiveIsFree) {\n        fx1 = rx;\n        fy1 = flo(ry);\n        fz1 = flo(rz);\n      } else if (px < rx) {\n        fx1 = rx - 1;\n        fy1 = flo(ry);\n        fz1 = flo(rz);\n      }\n    } else if (ey) {\n      positiveIsFree = py > ry;\n\n      if (positiveIsFree) {\n        fx1 = flo(rx);\n        fy1 = ry;\n        fz1 = flo(rz);\n      } else if (py < ry) {\n        fx1 = flo(rx);\n        fy1 = ry - 1;\n        fz1 = flo(rz);\n      }\n    } else if (ez) {\n      positiveIsFree = pz > rz;\n\n      if (positiveIsFree) {\n        fx1 = flo(rx);\n        fy1 = flo(ry);\n        fz1 = rz;\n      } else if (pz < rz) {\n        fx1 = flo(rx);\n        fy1 = flo(ry);\n        fz1 = rz - 1;\n      }\n    }\n\n    var fx2;\n    var fy2;\n    var fz2;\n    var angle = 0;\n\n    if (ex) {\n      fx2 = positiveIsFree ? fx1 + 1 : fx1 - 1;\n      fy2 = fy1;\n      fz2 = fz1;\n      angle = Math.atan2(fz2 + 0.5 - pz, fy2 + 0.5 - py);\n    } else if (ey) {\n      fx2 = fx1;\n      fy2 = positiveIsFree ? fy1 + 1 : fy1 - 1;\n      fz2 = fz1;\n      angle = Math.atan2(fz2 + 0.5 - pz, fx2 + 0.5 - px);\n    } else if (ez) {\n      fx2 = fx1;\n      fy2 = fy1;\n      fz2 = positiveIsFree ? fz1 + 1 : fz1 - 1;\n      angle = Math.atan2(fy2 + 0.5 - py, fx2 + 0.5 - px);\n    }\n\n    clientModel.selfComponent.setAngleFromIntersectionPoint(angle.toFixed(4));\n    clientModel.triggerEvent(\'ray\', [\'add\', fx1, fy1, fz1, fx2, fy2, fz2, isMainButton]);\n  },\n  requestDelBlock: function requestDelBlock() {\n    var clientModel = this.app.model.client;\n    var graphicsEngine = this.app.engine.graphics;\n    var r = this.getRaycastCoordinates();\n    if (!r) return;\n\n    var _r2 = _slicedToArray(r, 6),\n        ex = _r2[0],\n        ey = _r2[1],\n        ez = _r2[2],\n        rx = _r2[3],\n        ry = _r2[4],\n        rz = _r2[5];\n\n    var flo = Math.floor;\n    var p = graphicsEngine.getCameraCoordinates();\n    var px = p.x;\n    var py = p.y;\n    var pz = p.z;\n    var fx;\n    var fy;\n    var fz;\n\n    if (ex) {\n      if (px < rx) {\n        fx = rx;\n        fy = flo(ry);\n        fz = flo(rz);\n      } else if (px > rx) {\n        fx = rx - 1;\n        fy = flo(ry);\n        fz = flo(rz);\n      }\n    } else if (ey) {\n      if (py < ry) {\n        fx = flo(rx);\n        fy = ry;\n        fz = flo(rz);\n      } else if (py > ry) {\n        fx = flo(rx);\n        fy = ry - 1;\n        fz = flo(rz);\n      }\n    } else if (ez) {\n      if (pz < rz) {\n        fx = flo(rx);\n        fy = flo(ry);\n        fz = rz;\n      } else if (pz > rz) {\n        fx = flo(rx);\n        fy = flo(ry);\n        fz = rz - 1;\n      }\n    }\n\n    clientModel.triggerEvent(\'ray\', [\'del\', fx, fy, fz]);\n  },\n  requestItemUse: function requestItemUse(isButtonUp, isSecondaryItem) {\n    var clientModel = this.app.model.client;\n    var graphicsEngine = this.app.engine.graphics;\n    var p = graphicsEngine.getCameraCoordinates();\n    var f = graphicsEngine.getModelForwardVector();\n    clientModel.triggerEvent(\'u\', [p.x, p.y, p.z, f.x, f.y, f.z, isButtonUp, isSecondaryItem]);\n  },\n  requestMainHandItemAction: function requestMainHandItemAction(isButtonUp) {\n    var clientSelfModel = this.app.model.client.selfComponent;\n    var activeItemID = clientSelfModel.getCurrentItemID();\n    if (!isButtonUp && ItemsModelModule.isItemX(activeItemID)) this.requestAddBlock(false);else if (!isButtonUp && (ItemsModelModule.isItemNaught(activeItemID) || ItemsModelModule.isItemBlock(activeItemID))) {\n      this.requestDelBlock();\n    } else if (!ItemsModelModule.isItemIDSupported(activeItemID)) console.warn(\'[Mouse/Listener] Item ID unsupported.\');else if (ItemsModelModule.isItemUseable(activeItemID)) this.requestItemUse(isButtonUp, false);\n  },\n  requestSecondaryHandItemAction: function requestSecondaryHandItemAction(isButtonUp) {\n    var clientSelfModel = this.app.model.client.selfComponent;\n    var activeItemID = clientSelfModel.getCurrentItemID();\n    if (!ItemsModelModule.isItemIDSupported(activeItemID)) console.warn(\'[Mouse/Listener] Item ID unsupported.\');else if (ItemsModelModule.isItemPlaceable(activeItemID) && !isButtonUp) this.requestAddBlock(true);else if (ItemsModelModule.isItemUseable(activeItemID)) this.requestItemUse(isButtonUp, true);\n  },\n  onLeftMouseUp: function onLeftMouseUp() {\n    this.requestMainHandItemAction(true);\n  },\n  onRightMouseUp: function onRightMouseUp() {\n    this.requestSecondaryHandItemAction(true);\n  },\n  onMiddleMouseUp: function onMiddleMouseUp() {},\n  onLeftMouseDown: function onLeftMouseDown() {\n    this.requestMainHandItemAction(false);\n  },\n  onRightMouseDown: function onRightMouseDown() {\n    this.requestSecondaryHandItemAction(false);\n  },\n  onMiddleMouseDown: function onMiddleMouseDown() {},\n  mouseWheelCallback: function mouseWheelCallback(event) {\n    var clientModel = this.app.model.client;\n    var ey = -event.deltaY; // let df = event.deltaFactor;\n\n    clientModel.triggerChange(\'interaction\', [\'itemSelect\', ey]);\n  },\n  registerMouseWheel: function registerMouseWheel() {\n    if (!this.omwh) this.omwh = this.mouseWheelCallback.bind(this);\n    document.addEventListener(\'wheel\', this.omwh);\n  },\n  unregisterMouseDown: function unregisterMouseDown() {\n    jquery_default()(window).off(\'mousedown\');\n  },\n  unregisterMouseUp: function unregisterMouseUp() {\n    jquery_default()(window).off(\'mouseup\');\n  },\n  unregisterMouseWheel: function unregisterMouseWheel() {\n    document.removeEventListener(\'wheel\', this.omwh);\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/controls/mouse/pointerlockcontrols.js\n/**\n *\n */\n\n\n\nvar PointerLockModule = {\n  setupPointerLock: function setupPointerLock() {\n    var app = this.app;\n    if (!(\'webkitPointerLockElement\' in document) && !(\'mozPointerLockElement\' in document) && !(\'pointerLockElement\' in document)) return;\n    var scope = this;\n    var d = document;\n    var b = document.body;\n\n    if (\'webkitPointerLockElement\' in d) {\n      if (!this.pointerLockFunction) this.pointerLockFunction = function () {\n        scope.pointerLockChanged(d.webkitRequestPointerLock === b);\n      };\n      b.requestPointerLock = b.webkitRequestPointerLock;\n      d.removeEventListener(\'webkitpointerlockchange\', this.pointerLockFunction);\n      d.addEventListener(\'webkitpointerlockchange\', this.pointerLockFunction, false);\n    } else if (\'mozPointerLockElement\' in d) {\n      if (!this.pointerLockFunction) this.pointerLockFunction = function () {\n        scope.pointerLockChanged(d.mozPointerLockElement === b);\n      };\n      b.requestPointerLock = b.mozRequestPointerLock;\n      d.removeEventListener(\'mozpointerlockchange\', this.pointerLockFunction);\n      d.addEventListener(\'mozpointerlockchange\', this.pointerLockFunction, false);\n    } else if (\'pointerLockElement\' in d) {\n      if (!this.pointerLockFunction) this.pointerLockFunction = function () {\n        scope.pointerLockChanged(d.pointerLockElement === b);\n      };\n      d.removeEventListener(\'pointerlockchange\', this.pointerLockFunction);\n      d.addEventListener(\'pointerlockchange\', this.pointerLockFunction, false);\n    } else {\n      console.log(\'ERROR: POINTER LOCK NOT SUPPORTED.\');\n    }\n\n    jquery_default()(document).mousedown(function (event) {\n      if (app.getState() !== \'ingame\' || app.isFocused()) return;\n\n      switch (event.which) {\n        case 1: // Left\n        // break;\n\n        case 2: // Middle\n\n        case 3: // Right\n\n        default: // return;\n\n      } // Ask the browser to lock the pointer.\n      // event.preventDefault();\n      // event.stopPropagation();\n      // scope.requestPointerLock();\n      // app.setFocused(true);\n\n    });\n  },\n  requestPointerLock: function requestPointerLock() {\n    var controlsEngine = this.app.engine.controls;\n    var b = document.body;\n    b.requestPointerLock();\n    controlsEngine.startKeyboardListeners();\n    controlsEngine.startMouseListeners();\n    controlsEngine.startWindowListeners();\n  },\n  pointerLockChanged: function pointerLockChanged(isPointerLocked) {\n    var app = this.app;\n    app.engine.controls.threeControlsEnabled = isPointerLocked;\n\n    if (!isPointerLocked) {\n      app.setState(\'settings\');\n      app.setFocused(false);\n    }\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/controls/mouse/mouse.js\n/**\n *\n */\n\n\n\n\n\n\nvar MouseModule = {\n  setupMouse: function setupMouse() {\n    this.buttons = Object.freeze({\n      left: 1,\n      middle: 2,\n      right: 3\n    }); // Click / move handlers.\n\n    this.setupPointerLock();\n  },\n  startMouseListeners: function startMouseListeners() {\n    if (this.isTouch) console.warn(\'[Keyboard] requested keyboard listeners on a touch device.\');\n    this.registerMouseMove();\n    this.registerMouseDown();\n    this.registerMouseUp();\n    this.registerMouseWheel();\n  },\n  stopMouseListeners: function stopMouseListeners() {\n    this.unregisterMouseMove();\n    this.unregisterMouseDown();\n    this.unregisterMouseUp();\n    this.unregisterMouseWheel();\n  }\n}; // Pack module.\n\nextend(MouseModule, listeners_ListenerModule);\nextend(MouseModule, FirstPersonModule);\nextend(MouseModule, PointerLockModule);\n\n// CONCATENATED MODULE: ./client/app/engine/controls/touch/listeners.js\n/**\n *\n */\n\n\nvar touch_listeners_ListenerModule = {\n  onLeftStickMove: function onLeftStickMove(x, y) {\n    this.touch.leftX = x;\n    this.touch.leftY = y;\n  },\n  onRightStickMove: function onRightStickMove(x, y) {\n    this.touch.rightX = x;\n    this.touch.rightY = y;\n  },\n  onButtonChange: function onButtonChange(which, isHeld) {\n    // console.log(`Button ${which} ${isHeld ? \'pressed\' : \'released\'}.`);\n    var clientModel = this.app.model.client;\n\n    switch (which) {\n      case \'triangle\':\n        break;\n\n      case \'cross\':\n        this.requestMainHandItemAction(!isHeld);\n        break;\n\n      case \'circle\':\n        // jump\n        if (isHeld) clientModel.triggerEvent(\'m\', \'u\');else if (!isHeld) clientModel.triggerEvent(\'m\', \'ux\');\n        break;\n\n      case \'square\':\n        this.requestSecondaryHandItemAction(!isHeld);\n        break;\n\n      case \'dpadLeft\':\n        if (isHeld) clientModel.triggerChange(\'interaction\', [\'itemSelect\', 1]);\n        break;\n\n      case \'dpadRight\':\n        if (isHeld) clientModel.triggerChange(\'interaction\', [\'itemSelect\', -1]);\n        break;\n\n      case \'dpadDown\':\n        clientModel.triggerChange(\'camera\', [\'toggle\']);\n        break;\n\n      case \'dpadUp\':\n        if (isHeld) clientModel.triggerChange(\'camera\', [\'toggle\']);\n        break;\n\n      case \'home\':\n        // Only on press\n        if (isHeld) this.touchLockChanged(false);\n        break;\n    }\n  },\n  rotateCameraFromRightStick: function rotateCameraFromRightStick() {\n    var graphics = this.app.engine.graphics;\n    var movementX = this.touch.rightX * 12;\n    var movementY = this.touch.rightY * 16;\n    if (Math.abs(movementX) > 0 || Math.abs(movementY) > 0) graphics.cameraManager.addCameraRotationEvent(movementX, movementY, 0, 0);\n  },\n  movePlayerFromLeftStick: function movePlayerFromLeftStick() {\n    var clientModel = this.app.model.client;\n    var lx = this.touch.leftX;\n    var ly = this.touch.leftY;\n    var lastLeft = this.touch.leftLast;\n    var newLeft = [];\n\n    if (ly !== 0 && lx !== 0) {\n      var angle = Math.atan2(ly, lx);\n      var pi8 = Math.PI / 8;\n\n      switch (true) {\n        case angle < -7 * pi8 || angle > 7 * pi8:\n          newLeft.push(\'l\');\n          break;\n\n        case angle < -5 * pi8:\n          newLeft.push(\'f\', \'l\');\n          break;\n\n        case angle < -3 * pi8:\n          newLeft.push(\'f\');\n          break;\n\n        case angle < -pi8:\n          newLeft.push(\'f\', \'r\');\n          break;\n\n        case angle > 5 * pi8:\n          newLeft.push(\'b\');\n          break;\n\n        case angle > 3 * pi8:\n          newLeft.push(\'b\', \'l\');\n          break;\n\n        case angle > pi8:\n          newLeft.push(\'b\', \'r\');\n          break;\n\n        default:\n          newLeft.push(\'r\');\n          break;\n      }\n    }\n\n    if (newLeft.length > 2) console.error(\'[Touch] too many events detected.\');\n\n    for (var i = 0; i < newLeft.length; ++i) {\n      var t = newLeft[i];\n      if (lastLeft.indexOf(t) < 0) clientModel.triggerEvent(\'m\', "".concat(t));\n    }\n\n    for (var _i = 0; _i < lastLeft.length; ++_i) {\n      var _t = lastLeft[_i];\n      if (newLeft.indexOf(_t) < 0) clientModel.triggerEvent(\'m\', "".concat(_t, "x"));\n    }\n\n    this.touch.leftLast = newLeft;\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/controls/touch/MobileWidgetControls.js\n/**\n * (c) madblade 2020\n * https://creativecommons.org/licenses/by/3.0/\n * -- please consider giving credit --\n */\n\n/**\n * Mobile Widget Controller\n * @param element HTMLElement used to get touch events and to draw the widget.\n * @param onLeftStickMove function(X, Y) from the stick center.\n * @param onRightStickMove function(X, Y) from the stick center.\n * @param onButtonPress function(whichButton) for additional buttons.\n * @param controllerType \'playstation,\' \'xbox,\' \'default\'\n * @constructor\n */\nvar MobileWidgetControls = function MobileWidgetControls(element, onLeftStickMove, onRightStickMove, onButtonPress, controllerType) {\n  var _this = this;\n\n  if (!(element instanceof HTMLElement)) throw Error(\'[MobileWidgetControls] Expected element to be an HTMLElement.\');\n  var w = window.innerWidth;\n  var h = window.innerHeight;\n  var dpr = window.devicePixelRatio; // Overflow causes an ugly y shift (the size of the bar).\n  // document.body.style.overflowX = \'hidden\';\n  // document.body.style.overflowY = \'hidden\';\n  // Main objects.\n\n  this.element = element;\n  this.leftStickMoveCallback = onLeftStickMove;\n  this.rightStickMoveCallback = onRightStickMove;\n  this.buttonPressCallback = onButtonPress;\n  this.controllerType = controllerType ? controllerType : \'default\'; // Device pixel ratio trick to correctly initialize the model on mobile\n  // (where zooming is disabled)\n  // and to keep the model the right size when zooming on desktop.\n\n  this.currentDPR = dpr;\n  this.initialDPR = dpr;\n  this.CANVAS_ID = \'widget-drawing-canvas\';\n  this.TIME_MS_TO_GET_TO_ORIGINAL_POSITION = 60; // 60ms to relax\n\n  this.minOpacity = 0.1; // Model\n\n  this.leftStick = {};\n  this.rightStick = {};\n  this.buttons = [];\n  this.fingers = []; // Graphics.\n\n  var c = document.getElementById(this.CANVAS_ID);\n\n  if (!c) {\n    this.canvas = document.createElement(\'canvas\');\n    this.canvas.setAttribute(\'id\', this.CANVAS_ID);\n    this.canvas.setAttribute(\'width\', "".concat(w));\n    this.canvas.setAttribute(\'height\', "".concat(h));\n    this.canvas.setAttribute(\'style\', \'position: absolute; width: 100%; bottom: 0px; z-index: 999;\');\n    this.element.appendChild(this.canvas);\n  } else {\n    this.canvas = c;\n  } // Main listener.\n\n\n  var touchListener = function touchListener(k) {\n    return function (e) {\n      if (k === \'start\') e.preventDefault();\n\n      if (k === \'move\') {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n\n      _this.fingers = [];\n\n      if (k === \'cancel\') {\n        console.error(\'[MobileWidgetControls] Too many fingers or unsupported action.\');\n        return;\n      } // Update finger model.\n\n\n      var touches = e.touches;\n\n      for (var i = 0; i < touches.length; ++i) {\n        var touch = touches[i];\n        var x = touch.clientX;\n        var y = touch.clientY;\n\n        _this.fingers.push({\n          x: x,\n          y: y\n        });\n      } // Update controller model.\n\n\n      var changedTouches = e.changedTouches;\n\n      for (var _i = 0; _i < changedTouches.length; ++_i) {\n        var _touch = changedTouches[_i];\n        if (k === \'end\') _this.updateUp(_touch);else if (k === \'move\') _this.updateMove(_touch);else if (k === \'start\') _this.updateDown(_touch);\n      }\n    };\n  };\n\n  this.touchStart = touchListener(\'start\');\n  this.touchMove = touchListener(\'move\');\n  this.touchEnd = touchListener(\'end\');\n  this.touchCancel = touchListener(\'cancel\'); // Internal.\n\n  this._resizeRequest = null; // Model init.\n\n  this.init();\n};\n\nMobileWidgetControls.prototype.stopWidgetListeners = function () {\n  window.removeEventListener(\'resize\', this.resize);\n  window.removeEventListener(\'orientationchange\', this.resize);\n  this.canvas.removeEventListener(\'touchstart\', this.touchStart);\n  this.canvas.removeEventListener(\'touchmove\', this.touchMove);\n  this.canvas.removeEventListener(\'touchend\', this.touchEnd);\n  this.canvas.removeEventListener(\'touchcancel\', this.touchCancel);\n};\n\nMobileWidgetControls.prototype.startWidgetListeners = function () {\n  // Rescale canvas and event/drawable coordinates with devicePixelRatio.\n  window.addEventListener(\'resize\', this.resize);\n  window.addEventListener(\'orientationchange\', this.resize); // Bindings to the actual events.\n\n  this.canvas.addEventListener(\'touchstart\', this.touchStart, false);\n  this.canvas.addEventListener(\'touchmove\', this.touchMove, false);\n  this.canvas.addEventListener(\'touchend\', this.touchEnd, false);\n  this.canvas.addEventListener(\'touchcancel\', this.touchCancel, false);\n};\n\nMobileWidgetControls.prototype.init = function () {\n  var h = window.innerHeight;\n  var w = window.innerWidth; // Resize canvas style.\n\n  this.canvas.style.width = "".concat(w, "px");\n  this.canvas.style.height = "".concat(h, "px"); // Resize model for css.\n\n  var dpr = window.devicePixelRatio;\n\n  if (dpr !== this.currentDPR) {\n    // Update (because of zoom)\n    console.log(\'[MobileWidgetControls] Zoom triggered: updating DPR.\');\n    this.currentDPR = dpr;\n  }\n\n  var dw = dpr * w;\n  var dh = dpr * h;\n  this.canvas.width = dw;\n  this.canvas.height = dh; // No need to resize the model of whatever is gonna be drawn inside the canvas.\n  // Event X and Y are going to be rescaled.\n  // .\n\n  var controllerType = this.controllerType;\n  this.initButtons(controllerType, dw, dh);\n  this.initSticks(controllerType, dw, dh); // Refresh graphics.\n\n  this.draw();\n};\n/* BUTTONS */\n// button order: see https://www.w3.org/TR/gamepad/\n// https://patents.google.com/patent/US20130215024A1/en\n\n\nMobileWidgetControls.PlaystationControllerButtons = [{\n  name: \'cross\',\n  from: \'r\',\n  x: 85,\n  y: 75,\n  label: String.fromCharCode(10761),\n  labelSize: 30,\n  diameter: 30,\n  labelOffset: 2,\n  theme: \'gradient\'\n}, {\n  name: \'circle\',\n  from: \'r\',\n  x: 40,\n  y: 120,\n  labelSize: 23,\n  diameter: 30,\n  label: String.fromCharCode(9711),\n  labelOffset: 2,\n  theme: \'gradient\'\n}, {\n  name: \'square\',\n  from: \'r\',\n  x: 130,\n  y: 120,\n  labelSize: 36,\n  diameter: 30,\n  label: String.fromCharCode(9723),\n  labelOffset: 2,\n  theme: \'gradient\'\n}, {\n  name: \'triangle\',\n  from: \'r\',\n  x: 85,\n  y: 165,\n  labelSize: 35,\n  diameter: 30,\n  label: String.fromCharCode(9651),\n  labelOffset: 0,\n  theme: \'gradient\'\n}, {\n  name: \'L1\',\n  from: \'l\',\n  x: 110,\n  y: 260,\n  labelSize: 30,\n  diameter: 30,\n  label: \'L1\',\n  labelOffset: 3,\n  theme: \'gradient\'\n}, {\n  name: \'R1\',\n  from: \'r\',\n  x: 110,\n  y: 260,\n  labelSize: 30,\n  diameter: 30,\n  label: \'R1\',\n  labelOffset: 3,\n  theme: \'gradient\'\n}, {\n  name: \'L2\',\n  from: \'l\',\n  x: 50,\n  y: 280,\n  labelSize: 30,\n  diameter: 30,\n  label: \'L2\',\n  labelOffset: 3,\n  theme: \'gradient\'\n}, {\n  name: \'R2\',\n  from: \'r\',\n  x: 50,\n  y: 280,\n  labelSize: 30,\n  diameter: 30,\n  label: \'R2\',\n  labelOffset: 3,\n  theme: \'gradient\'\n}, {\n  name: \'back\'\n}, // select\n{\n  name: \'forward\'\n}, // start\n{\n  name: \'stickLB\'\n}, // click on stick\n{\n  name: \'stickRB\'\n}, // click on stick\n{\n  name: \'dpadUp\',\n  from: \'l\',\n  x: 65,\n  y: 205,\n  label: String.fromCharCode(8593),\n  labelSize: 20,\n  diameter: 23,\n  labelOffset: 0,\n  theme: \'gradient\'\n}, {\n  name: \'dpadDown\',\n  from: \'l\',\n  x: 65,\n  y: 135,\n  label: String.fromCharCode(8595),\n  labelSize: 20,\n  diameter: 23,\n  labelOffset: 0,\n  theme: \'gradient\'\n}, {\n  name: \'dpadLeft\',\n  from: \'l\',\n  x: 30,\n  y: 170,\n  label: String.fromCharCode(8592),\n  labelSize: 20,\n  diameter: 23,\n  labelOffset: 0,\n  theme: \'gradient\'\n}, {\n  name: \'dpadRight\',\n  from: \'l\',\n  x: 100,\n  y: 170,\n  label: String.fromCharCode(8594),\n  labelSize: 20,\n  diameter: 23,\n  labelOffset: 0,\n  theme: \'gradient\'\n}, {\n  name: \'home\',\n  from: \'l\',\n  x: 25,\n  y: 25,\n  // label: \'PS\',\n  label: String.fromCharCode(8617),\n  labelSize: 20,\n  diameter: 23,\n  labelOffset: 2,\n  theme: \'gradient\'\n}]; // https://patents.google.com/patent/US8641525B2/en\n\nMobileWidgetControls.XBoxControllerButtons = [{\n  name: \'A\',\n  from: \'r\',\n  diameter: 25,\n  x: 80,\n  y: 35,\n  label: \'A\',\n  labelSize: 20,\n  labelOffset: 2\n}, {\n  name: \'B\',\n  from: \'r\',\n  diameter: 25,\n  x: 45,\n  y: 75,\n  label: \'B\',\n  labelSize: 20,\n  labelOffset: 2\n}, {\n  name: \'X\',\n  from: \'r\',\n  diameter: 25,\n  x: 115,\n  y: 75,\n  label: \'X\',\n  labelSize: 20,\n  labelOffset: 2\n}, {\n  name: \'Y\',\n  from: \'r\',\n  diameter: 25,\n  x: 80,\n  y: 115,\n  label: \'Y\',\n  labelSize: 20,\n  labelOffset: 2\n}, {\n  name: \'LB\',\n  from: \'l\',\n  diameter: 35,\n  x: 135,\n  y: 205,\n  label: \'LB\',\n  labelSize: 20,\n  labelOffset: 2\n}, {\n  name: \'RB\',\n  from: \'r\',\n  diameter: 35,\n  x: 130,\n  y: 180,\n  label: \'RB\',\n  labelSize: 20,\n  labelOffset: 2\n}, {\n  name: \'LT\',\n  from: \'l\',\n  diameter: 35,\n  x: 45,\n  y: 210,\n  label: \'LT\',\n  labelSize: 20,\n  labelOffset: 2\n}, {\n  name: \'RT\',\n  from: \'r\',\n  diameter: 35,\n  x: 45,\n  y: 200,\n  label: \'RT\',\n  labelSize: 20,\n  labelOffset: 2\n}, {\n  name: \'back\'\n}, // select\n{\n  name: \'forward\'\n}, // start\n{\n  name: \'stickLB\'\n}, {\n  name: \'stickRB\'\n}, {\n  name: \'dpadUp\',\n  from: \'l\',\n  diameter: 15,\n  x: 220,\n  y: 73,\n  label: String.fromCharCode(8593),\n  labelSize: 20,\n  labelOffset: 0\n}, {\n  name: \'dpadDown\',\n  from: \'l\',\n  diameter: 15,\n  x: 220,\n  y: 27,\n  label: String.fromCharCode(8595),\n  labelSize: 20,\n  labelOffset: 0\n}, {\n  name: \'dpadLeft\',\n  from: \'l\',\n  diameter: 15,\n  x: 197,\n  y: 50,\n  label: String.fromCharCode(8592),\n  labelSize: 20,\n  labelOffset: 0\n}, {\n  name: \'dpadRight\',\n  x: 243,\n  y: 50,\n  from: \'l\',\n  diameter: 15,\n  label: String.fromCharCode(8594),\n  labelSize: 20,\n  labelOffset: 0\n}, {\n  name: \'home\'\n}];\n\nMobileWidgetControls.prototype.initButtons = function (controllerType, dw, dh) {\n  var buttons;\n\n  switch (controllerType) {\n    case \'playstation\':\n      buttons = MobileWidgetControls.PlaystationControllerButtons;\n      break;\n\n    case \'xbox\':\n      buttons = MobileWidgetControls.XBoxControllerButtons;\n      break;\n\n    default:\n      // No buttons.\n      return;\n  }\n\n  var dpr = this.initialDPR;\n  var modelButtons = [];\n\n  for (var bid in buttons) {\n    if (!buttons.hasOwnProperty(bid)) continue;\n    var reference = buttons[bid];\n    if (!reference.x || !reference.y || !reference.diameter) continue;\n\n    if (!reference.name) {\n      console.error(\'[MobileWidgetControls] A button must have a name property.\');\n    }\n\n    var button = {}; // model\n\n    button.held = false;\n    button.id = reference.name; // mandatory graphics\n\n    button.modelOriginX = reference.from === \'l\' ? dpr * reference.x : dw - dpr * reference.x;\n    button.modelOriginY = dh - dpr * reference.y;\n    button.BUTTON_DIAMETER = dpr * reference.diameter;\n    button.style = reference.theme; // optional\n\n    button.BUTTON_LABEL = reference.label;\n    button.BUTTON_LABEL_SIZE = dpr * reference.labelSize;\n    button.BUTTON_LABEL_OFFSET = dpr * reference.labelOffset;\n    modelButtons.push(button);\n  }\n\n  this.buttons = modelButtons;\n};\n\nMobileWidgetControls.prototype.notifyButtonChanged = function (button, isHolding) {\n  if (this.buttonPressCallback) this.buttonPressCallback(button.id, isHolding);\n};\n\nMobileWidgetControls.prototype.updateButtonModelHold = function (cx, cy, buttons, isHolding) {\n  var hasHitButton = false;\n\n  for (var i = 0, n = buttons.length; i < n; ++i) {\n    // Get first hit button.\n    var b = buttons[i];\n    var d = this.distanceToObjectCenter(cx, cy, b);\n    if (d > b.BUTTON_DIAMETER) continue; // Button hit.\n\n    hasHitButton = true;\n\n    if (b.held !== isHolding) {\n      // console.log(`Button ${b.id} ${isHolding ? \'touched\' : \'released\'}.`);\n      b.held = isHolding; // Propagate event.\n\n      this.notifyButtonChanged(b, isHolding);\n    }\n\n    break;\n  }\n\n  return hasHitButton;\n};\n\nMobileWidgetControls.prototype.updateButtonModelMove = function (cx, cy, buttons) {\n  var hasReleasedButton = false;\n\n  for (var i = 0, n = buttons.length; i < n; ++i) {\n    // Get all buttons that are not touched.\n    var b = buttons[i];\n    if (!b.held) continue; // b wasnt held.\n\n    var d = this.distanceToObjectCenter(cx, cy, b);\n    if (d < b.BUTTON_DIAMETER) continue; // b wasnt under finger.\n    // Test b against every finger.\n\n    var isUnderAnotherFinger = false;\n    var fs = this.fingers;\n    var dpr = this.currentDPR;\n\n    for (var j = 0; j < fs.length; ++j) {\n      var f = fs[j];\n      var d2 = this.distanceToObjectCenter(dpr * f.x, dpr * f.y, b);\n\n      if (d2 < b.BUTTON_DIAMETER) {\n        isUnderAnotherFinger = true;\n        break;\n      }\n    }\n\n    if (isUnderAnotherFinger) continue; // b is under finger, but another one.\n\n    hasReleasedButton = true; // console.log(`Button ${b.id} released.`);\n\n    b.held = false; // Propagate.\n\n    this.notifyButtonChanged(b, false);\n  }\n\n  return hasReleasedButton;\n};\n\nMobileWidgetControls.prototype.drawButton = function (ctx, button) {\n  // Background\n  ctx.beginPath();\n  ctx.globalAlpha = this.minOpacity + 0.2;\n  var originXLeft = button.modelOriginX;\n  var originYLeft = button.modelOriginY;\n  ctx.arc(originXLeft, originYLeft, button.BUTTON_DIAMETER, 0, 2 * Math.PI); // ctx.fillStyle = button.held ? \'#222222\' : \'black\';\n\n  if (button.style === \'gradient\') {\n    var gradient = ctx.createRadialGradient(originXLeft, originYLeft, 2, // inner\n    originXLeft, originYLeft, button.BUTTON_DIAMETER // outer\n    );\n    gradient.addColorStop(0, button.held ? \'silver\' : \'black\');\n    gradient.addColorStop(0.7, button.held ? \'silver\' : \'black\');\n    gradient.addColorStop(0.9, \'silver\');\n    gradient.addColorStop(1, \'silver\');\n    ctx.fillStyle = gradient;\n  } else {\n    ctx.fillStyle = button.held ? \'#222222\' : \'black\';\n  }\n\n  ctx.fill();\n\n  if (button.style !== \'gradient\') {\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = \'white\';\n    ctx.stroke();\n  }\n\n  ctx.closePath(); // Label\n\n  ctx.beginPath();\n  ctx.font = "".concat(button.BUTTON_LABEL_SIZE, "px Arial");\n  ctx.fillStyle = \'white\';\n  ctx.textAlign = \'center\';\n  ctx.textBaseline = \'middle\';\n  ctx.globalAlpha = this.minOpacity + 0.3;\n  ctx.fillText(button.BUTTON_LABEL, originXLeft, originYLeft + (button.BUTTON_LABEL_OFFSET || 0)); // ctx.fill();\n  // ctx.lineWidth = 2;\n  // ctx.strokeStyle = \'white\';\n  // ctx.stroke();\n\n  ctx.closePath();\n};\n/* STICKS */\n\n\nMobileWidgetControls.DefaultSticks = [{\n  name: \'left\',\n  from: \'l\',\n  x: 100,\n  y: 120,\n  head: 25,\n  base: 70,\n  grab: 150,\n  reach: 55,\n  label: String.fromCharCode(10021),\n  // multi-directional cross\n  labelSize: 30,\n  labelOffset: 2,\n  // offset i.e. for caps letters\n  theme: \'gradient\'\n}, {\n  name: \'right\',\n  from: \'r\',\n  x: 100,\n  y: 120,\n  head: 25,\n  base: 70,\n  grab: 150,\n  reach: 55,\n  label: String.fromCharCode(10021),\n  // multi-directional cross\n  labelSize: 30,\n  labelOffset: 2,\n  // offset i.e. for caps letters\n  theme: \'gradient\'\n}];\nMobileWidgetControls.PlaystationSticks = [{\n  name: \'left\',\n  from: \'l\',\n  x: 155,\n  y: 80,\n  head: 25,\n  base: 70,\n  grab: 140,\n  reach: 55,\n  theme: \'gradient\'\n}, {\n  name: \'right\',\n  from: \'r\',\n  x: 240,\n  y: 100,\n  head: 25,\n  base: 70,\n  grab: 140,\n  reach: 55,\n  // label: String.fromCharCode(10021), // multi-directional cross\n  // labelSize: 30,\n  // labelOffset: 2, // offset i.e. for caps letters\n  theme: \'gradient\'\n}];\nMobileWidgetControls.XBoxSticks = [{\n  name: \'left\',\n  from: \'l\',\n  x: 90,\n  y: 90,\n  head: 35,\n  base: 80,\n  grab: 150,\n  reach: 65,\n  theme: \'dark\'\n}, {\n  name: \'right\',\n  from: \'r\',\n  x: 240,\n  y: 80,\n  head: 30,\n  base: 70,\n  grab: 130,\n  reach: 55,\n  theme: \'dark\'\n}];\n\nMobileWidgetControls.prototype.initStick = function (dw, dh, stick, reference) {\n  var dpr = this.initialDPR;\n  stick.x = stick.y = stick.lastHeldX = stick.lastHeldY = stick.timeStampReleased = 0;\n  stick.modelOriginX = reference.from === \'l\' ? dpr * reference.x : dw - dpr * reference.x;\n  stick.modelOriginY = dh - dpr * reference.y;\n  stick.held = !1;\n  stick.needsUpdate = !0; // graphics constants\n\n  stick.STICK_HEAD_DIAMETER = dpr * reference.head;\n  stick.STICK_BASE_DIAMETER = dpr * reference.base;\n  stick.STICK_GRAB_DISTANCE = dpr * reference.grab;\n  stick.STICK_REACH_DISTANCE = dpr * reference.reach; // optional\n\n  stick.STICK_LABEL = reference.label;\n  stick.STICK_LABEL_SIZE = dpr * reference.labelSize;\n  stick.STICK_LABEL_OFFSET = dpr * reference.labelOffset;\n  stick.style = reference.theme;\n};\n\nMobileWidgetControls.prototype.initSticks = function (controllerType, dw, dh) {\n  var sticksReference;\n\n  switch (controllerType) {\n    case \'playstation\':\n      sticksReference = MobileWidgetControls.PlaystationSticks;\n      break;\n\n    case \'xbox\':\n      sticksReference = MobileWidgetControls.XBoxSticks;\n      break;\n\n    default:\n      sticksReference = MobileWidgetControls.DefaultSticks;\n      break;\n  }\n\n  this.initStick(dw, dh, this.leftStick, sticksReference[0]);\n  this.initStick(dw, dh, this.rightStick, sticksReference[1]);\n};\n\nMobileWidgetControls.prototype.notifyStickMoved = function (vx, vy, stick) {\n  var normX = vx / stick.STICK_REACH_DISTANCE;\n  var normY = vy / stick.STICK_REACH_DISTANCE;\n\n  if (stick === this.leftStick) {\n    if (this.leftStickMoveCallback) this.leftStickMoveCallback(normX, normY);\n  } else if (stick === this.rightStick) {\n    if (this.rightStickMoveCallback) this.rightStickMoveCallback(normX, normY);\n  }\n};\n\nMobileWidgetControls.prototype.updateStickModelFromMove = function (cx, cy, d, stick) {\n  var vx = cx - stick.modelOriginX;\n  var vy = cy - stick.modelOriginY;\n\n  if (d > stick.STICK_REACH_DISTANCE) {\n    vx *= stick.STICK_REACH_DISTANCE / d;\n    vy *= stick.STICK_REACH_DISTANCE / d;\n  }\n\n  stick.x = vx;\n  stick.y = vy;\n  stick.lastHeldX = vx;\n  stick.lastHeldY = vy;\n  this.notifyStickMoved(vx, vy, stick);\n};\n\nMobileWidgetControls.prototype.updateStickModelMove = function (cx, cy, stick) {\n  var d = this.distanceToObjectCenter(cx, cy, stick);\n\n  if (d < stick.STICK_GRAB_DISTANCE) {\n    // stick grab\n    stick.needsUpdate = true;\n    if (stick.held) this.updateStickModelFromMove(cx, cy, d, stick);\n  } else if (stick.held) {\n    // test against every other finger\n    var stickIsHeldByAnotherFinger = false;\n    var fs = this.fingers;\n    var dpr = this.currentDPR;\n\n    for (var i = 0; i < fs.length; ++i) {\n      var f = fs[i];\n      var d2 = this.distanceToObjectCenter(dpr * f.x, dpr * f.y, stick);\n\n      if (d2 < stick.STICK_GRAB_DISTANCE) {\n        stickIsHeldByAnotherFinger = true;\n        break;\n      }\n    }\n\n    if (!stickIsHeldByAnotherFinger) {\n      // stick release\n      stick.held = false;\n      stick.needsUpdate = true;\n      this.updateStickModelFromMove(cx, cy, d, stick);\n      stick.timeStampReleased = this.getTimeInMilliseconds();\n    }\n  }\n};\n\nMobileWidgetControls.prototype.updateStickModelHold = function (cx, cy, stick, isHolding) {\n  var d = this.distanceToObjectCenter(cx, cy, stick);\n\n  if (d < stick.STICK_GRAB_DISTANCE) {\n    var wasHolding = stick.held;\n    stick.held = isHolding;\n    if (wasHolding && !isHolding) stick.timeStampReleased = this.getTimeInMilliseconds();\n    stick.needsUpdate = true;\n  }\n};\n\nMobileWidgetControls.prototype.updateMove = function (event) {\n  var dpr = this.currentDPR;\n  var cx = event.clientX * dpr;\n  var cy = event.clientY * dpr;\n  this.updateButtonModelMove(cx, cy, this.buttons);\n  this.updateStickModelMove(cx, cy, this.leftStick);\n  this.updateStickModelMove(cx, cy, this.rightStick);\n};\n\nMobileWidgetControls.prototype.getClosestStick = function (cx, cy) {\n  var dl = this.distanceToObjectCenter(cx, cy, this.leftStick);\n  var dr = this.distanceToObjectCenter(cx, cy, this.rightStick);\n  return dl <= dr ? this.leftStick : this.rightStick;\n};\n\nMobileWidgetControls.prototype.updateDown = function (event) {\n  var dpr = this.currentDPR;\n  var cx = event.clientX * dpr;\n  var cy = event.clientY * dpr;\n  var hasHitButton = this.updateButtonModelHold(cx, cy, this.buttons, true);\n  if (hasHitButton) return;\n  var stick = this.getClosestStick(cx, cy);\n  this.updateStickModelHold(cx, cy, stick, true);\n  this.updateStickModelMove(cx, cy, stick);\n};\n\nMobileWidgetControls.prototype.updateUp = function (event) {\n  var dpr = this.currentDPR;\n  var cx = dpr * event.clientX;\n  var cy = dpr * event.clientY;\n  this.updateButtonModelHold(cx, cy, this.buttons, false);\n  this.updateStickModelHold(cx, cy, this.leftStick, false);\n  this.updateStickModelHold(cx, cy, this.rightStick, false);\n};\n\nMobileWidgetControls.prototype.drawStick = function (ctx, stick) {\n  var originXLeft = stick.modelOriginX;\n  var originYLeft = stick.modelOriginY; // Base\n\n  ctx.beginPath();\n  ctx.globalAlpha = this.minOpacity;\n  ctx.arc(originXLeft, originYLeft, stick.STICK_BASE_DIAMETER, 0, 2 * Math.PI);\n\n  if (stick.style === \'gradient\') {\n    var gradient = ctx.createRadialGradient(originXLeft, originYLeft, 2, // inner\n    originXLeft, originYLeft, stick.STICK_BASE_DIAMETER // outer\n    );\n    gradient.addColorStop(0, \'gray\');\n    gradient.addColorStop(0.7, \'gray\');\n    gradient.addColorStop(0.9, \'silver\');\n    gradient.addColorStop(1, \'white\');\n    ctx.fillStyle = gradient;\n  } else {\n    ctx.fillStyle = \'black\';\n  }\n\n  ctx.fill();\n\n  if (stick.style !== \'gradient\') {\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = \'white\';\n    ctx.stroke();\n  }\n\n  ctx.closePath(); // Head\n\n  var stickXLeft = stick.x;\n  var stickYLeft = stick.y;\n  ctx.beginPath();\n  ctx.globalAlpha = this.minOpacity;\n  ctx.arc(originXLeft + stickXLeft, originYLeft + stickYLeft, stick.STICK_HEAD_DIAMETER, 0, 2 * Math.PI);\n\n  if (stick.style === \'gradient\') {\n    ctx.globalAlpha = this.minOpacity + 0.05;\n\n    var _gradient = ctx.createRadialGradient(originXLeft + stickXLeft, originYLeft + stickYLeft, 2, // inner\n    originXLeft + stickXLeft, originYLeft + stickYLeft, stick.STICK_HEAD_DIAMETER // outer\n    );\n\n    _gradient.addColorStop(0, \'darkgray\');\n\n    _gradient.addColorStop(0.7, \'darkgray\');\n\n    _gradient.addColorStop(0.9, \'whitesmoke\');\n\n    _gradient.addColorStop(1, \'white\');\n\n    ctx.fillStyle = _gradient;\n  } else {\n    ctx.fillStyle = \'black\';\n  }\n\n  ctx.fill();\n\n  if (stick.style !== \'gradient\') {\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = \'white\';\n    ctx.stroke();\n  }\n\n  ctx.closePath(); // Optional label\n\n  if (stick.STICK_LABEL && stick.STICK_LABEL_SIZE) {\n    ctx.beginPath();\n    ctx.font = "".concat(stick.STICK_LABEL_SIZE, "px Arial");\n    ctx.fillStyle = \'white\';\n    ctx.textAlign = \'center\';\n    ctx.textBaseline = \'middle\';\n    ctx.globalAlpha = this.minOpacity;\n    ctx.fillText(stick.STICK_LABEL, originXLeft + stickXLeft, originYLeft + stickYLeft + (stick.STICK_LABEL_OFFSET || 0));\n    ctx.closePath();\n  }\n};\n\nMobileWidgetControls.prototype.draw = function () {\n  var canvas = this.canvas;\n  var ctx = canvas.getContext(\'2d\');\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  this.drawStick(ctx, this.leftStick);\n  this.drawStick(ctx, this.rightStick);\n  var buttons = this.buttons;\n\n  for (var i = 0, n = buttons.length; i < n; ++i) {\n    this.drawButton(ctx, buttons[i]);\n  }\n};\n\nMobileWidgetControls.prototype.interpolateStick = function (stick, newTime) {\n  var deltaT = newTime - stick.timeStampReleased;\n  var maxDeltaT = this.TIME_MS_TO_GET_TO_ORIGINAL_POSITION;\n  var t = this.smootherstep(0, maxDeltaT, deltaT);\n  var ox = stick.modelOriginX;\n  var oy = stick.modelOriginY;\n  var newX = (ox + stick.lastHeldX) * (1 - t) + ox * t - ox;\n  var newY = (oy + stick.lastHeldY) * (1 - t) + oy * t - oy;\n  if (stick.x === stick.y && stick.x === stick.y) stick.needsUpdate = false;\n  stick.x = newX;\n  stick.y = newY; // Propagate event.\n\n  if (stick.needsUpdate) this.notifyStickMoved(newX, newY, stick);\n};\n\nMobileWidgetControls.prototype.animate = function () {\n  var newTime = this.getTimeInMilliseconds();\n  var leftStick = this.leftStick;\n  if (!leftStick.held && leftStick.needsUpdate) this.interpolateStick(leftStick, newTime);\n  var rightStick = this.rightStick;\n  if (!rightStick.held && rightStick.needsUpdate) this.interpolateStick(rightStick, newTime);\n  this.draw();\n};\n\nMobileWidgetControls.prototype.resize = function () {\n  var _this2 = this;\n\n  if (this._resizeRequest) clearTimeout(this._resizeRequest);\n  this._resizeRequest = setTimeout(function () {\n    //\n    // On recent iOS Safari, open tabs create an offset\n    window.scrollTo(0, document.body.scrollHeight); // Recompute everything.\n\n    _this2.init();\n  }, 100 // Dont resize every frame.\n  );\n};\n/* UTIL */\n\n\nMobileWidgetControls.prototype.getTimeInMilliseconds = function () {\n  return performance.now();\n};\n\nMobileWidgetControls.prototype.distanceToObjectCenter = function (cx, cy, object) {\n  return Math.sqrt(Math.pow(cx - object.modelOriginX, 2) + Math.pow(cy - object.modelOriginY, 2));\n};\n\nMobileWidgetControls.prototype.clamp = function (t, low, high) {\n  return Math.min(high, Math.max(low, t));\n}; // MobileWidgetControls.prototype.smoothstep = function(end1, end2, t)\n// {\n//     let x = this.clamp((t - end1) / (end2 - end1), 0.0, 1.0);\n//     return x * x * (3 - 2 * x);\n// };\n\n\nMobileWidgetControls.prototype.smootherstep = function (end1, end2, t) {\n  var x = this.clamp((t - end1) / (end2 - end1), 0.0, 1.0);\n  return x * x * x * (x * (x * 6 - 15) + 10);\n};\n\nMobileWidgetControls.prototype.makeDocumentUnselectable = function () {\n  var styleId = \'mobile-widget-controls-style\';\n\n  if (!document.getElementById(styleId)) {\n    var head = document.getElementsByTagName(\'head\')[0];\n    var style = document.createElement(\'style\');\n    style.id = styleId;\n    style.innerText = "\\n            *.noselect {\\n               -webkit-touch-callout: none; /* iOS Safari */\\n                 -webkit-user-select: none; /* Safari */\\n                  -khtml-user-select: none; /* Konqueror HTML */\\n                    -moz-user-select: none; /* Firefox */\\n                     -ms-user-select: none; /* Internet Explorer/Edge */\\n                         user-select: none; /* Non-prefixed version, currently\\n                                               supported by Chrome and Opera */\\n            }\\n        ";\n    head.appendChild(style);\n  }\n\n  document.body.className += \' noselect\';\n};\n\n\n// CONCATENATED MODULE: ./client/app/engine/controls/touch/touch.js\n/**\n *\n */\n\n\n\n\n\nvar TouchModule = {\n  setupTouchWidget: function setupTouchWidget() {\n    var widget = document.getElementById(\'widget\');\n    var widgetControls = new MobileWidgetControls(widget, this.onLeftStickMove.bind(this), this.onRightStickMove.bind(this), this.onButtonChange.bind(this), \'playstation\');\n    widgetControls.element.style.visibility = \'hidden\';\n    return widgetControls;\n  },\n  // Setup listener\n  setupTouch: function setupTouch() {},\n  // Activate listeners\n  startTouchListeners: function startTouchListeners() {\n    if (!this.isTouch) {\n      console.error(\'[Touch] Trying to initialize touch on non-touch device.\');\n      return;\n    } // Reset sticks\n\n\n    var touch = this.touch;\n    touch.leftX = touch.leftY = 0;\n    touch.rightX = touch.rightY = 0;\n    touch.rx = touch.ry = 0;\n    touch.leftLast = [];\n    var widget = this.touchWidgetControls;\n    widget.init();\n    widget.element.style.visibility = \'visible\';\n    widget.startWidgetListeners();\n  },\n  stopTouchListeners: function stopTouchListeners() {\n    var widget = this.touchWidgetControls;\n    widget.stopWidgetListeners();\n    widget.element.style.visibility = \'hidden\';\n  },\n  requestTouchLock: function requestTouchLock() {\n    this.touchControlsEnabled = true;\n    var controlsEngine = this.app.engine.controls;\n    controlsEngine.startTouchListeners();\n    controlsEngine.startWindowListeners();\n  },\n  touchLockChanged: function touchLockChanged(isTouchLocked) {\n    // Exits from lock status.\n    var app = this.app;\n    app.engine.controls.touchControlsEnabled = isTouchLocked;\n\n    if (!isTouchLocked) {\n      app.setState(\'settings\');\n      app.setFocused(false);\n    }\n  },\n  updateControlsDevice: function updateControlsDevice() {\n    if (!this.isTouch) return;\n    if (!this.touchControlsEnabled) return; // Update widget model and visual.\n\n    this.touchWidgetControls.animate(); // Right stick: camera movement\n\n    this.rotateCameraFromRightStick(); // Left stick: player movement\n\n    this.movePlayerFromLeftStick();\n  }\n};\nextend(TouchModule, touch_listeners_ListenerModule);\n\n// CONCATENATED MODULE: ./client/app/engine/controls/window/window.js\n/**\n *\n */\n // Legacy\n\nvar WindowModule = {\n  setupWindowListeners: function setupWindowListeners() {\n    var visibilityChange;\n    var hidden;\n\n    if (typeof document.hidden !== \'undefined\') {\n      // Opera 12.10 and Firefox 18 and later support\n      hidden = \'hidden\';\n      visibilityChange = \'visibilitychange\';\n    } else if (typeof document.msHidden !== \'undefined\') {\n      hidden = \'msHidden\';\n      visibilityChange = \'msvisibilitychange\';\n    } else if (typeof document.webkitHidden !== \'undefined\') {\n      hidden = \'webkitHidden\';\n      visibilityChange = \'webkitvisibilitychange\';\n    } else {\n      console.log(\'Visibility change API not supported!\');\n      console.log(\'Rolling back - using Alt-Tab, Ctrl-Tab or the likes may \' + \'result in focus-state bugs (rejoin to cancel if any).\');\n      return;\n    }\n\n    var handlerVisibilityChange = function () {\n      if (document[hidden]) {\n        if (this.isTouch) this.stopTouchListeners();else this.stopKeyboardListeners();\n      } else if (!document[hidden]) {\n        // eslint if\n        if (this.isTouch) this.stopTouchListeners();else this.startKeyboardListeners();\n      }\n    }.bind(this);\n\n    this.windowListeners = {\n      start: function start() {\n        document.addEventListener(visibilityChange, handlerVisibilityChange, false);\n      },\n      stop: function stop() {\n        document.removeEventListener(visibilityChange, handlerVisibilityChange);\n      }\n    };\n  },\n  startWindowListeners: function startWindowListeners() {\n    this.windowListeners.start();\n  },\n  stopWindowListeners: function stopWindowListeners() {\n    this.windowListeners.stop();\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/controls/controls.js\n/**\n * User interaction.\n */\n\n\n\n\n\n\n\n\n\nvar UI = function UI(app) {\n  this.app = app; // User customizable settings.\n\n  this.settings = {}; // Mouse on desktop.\n\n  this.threeControlsEnabled = false;\n  this.mouse = {}; // Keyboard needs a list of possible keystrokes;\n  // and a list of keys actually pressed.\n\n  this.keyControls = {}; // Other input methods.\n\n  this.touchControlsEnabled = false;\n  this.isTouch = \'ontouchstart\' in window || navigator.msMaxTouchPoints > 0;\n\n  if (this.isTouch) {\n    this.touch = {\n      // Stick states\n      leftX: 0,\n      leftY: 0,\n      rightX: 0,\n      rightY: 0,\n      // Euler-type controls\n      rx: 0,\n      ry: 0,\n      leftLast: \'\'\n    };\n    this.touchWidgetControls = this.setupTouchWidget();\n  }\n\n  if (!this.isTouch) {\n    this.settings.language = \'\'; // expose keyboard layout settings\n  }\n};\n\nextend(UI.prototype, {\n  run: function run() {\n    var graphicsEngine = this.app.engine.graphics; // XXX [ACCESSIBILITY] gamepad\n\n    if (this.isTouch) {\n      this.setupTouch();\n    } else {\n      this.setupKeyboard();\n      this.setupMouse();\n    }\n\n    this.setupWindowListeners(); // Should this be put somewhere else?\n\n    jquery_default()(window).resize(graphicsEngine.resize.bind(graphicsEngine));\n  },\n  stop: function stop() {\n    this.stopListeners();\n  },\n  stopListeners: function stopListeners() {\n    if (this.isTouch) {\n      this.stopTouchListeners();\n    } else {\n      this.stopKeyboardListeners();\n      this.stopMouseListeners();\n    }\n\n    this.stopWindowListeners();\n  },\n  requestLock: function requestLock() {\n    if (this.isTouch) this.requestTouchLock();else this.requestPointerLock();\n  }\n});\nextend(UI.prototype, KeyboardModule);\nextend(UI.prototype, MouseModule);\nextend(UI.prototype, TouchModule);\nextend(UI.prototype, WindowModule);\n\n// CONCATENATED MODULE: ./client/app/engine/settings/settings.audio.js\n/**\n *\n */\n\n\n\nvar AudioModule = {\n  getAudioHTML: function getAudioHTML(audioSettings) {\n    var content = "\\n            <div class=\\"container\\">\\n            <table class=\\"table table-bordered noselect\\" style=\\"width:100%\\">\\n                <tr id=\\"return\\"><td>Return</td></tr>\\n        ";\n\n    for (var s in audioSettings) {\n      content += "<tr><td>".concat(audioSettings[s], "</td></tr>");\n    }\n\n    content += "\\n            </table>\\n            </div>";\n    return content;\n  },\n  goAudio: function goAudio() {\n    this.unlistenSettingsMenu();\n    jquery_default()(\'#announce\').empty().append(this.getAudioHTML(this.audioSettings));\n    this.listenReturn();\n  },\n  listenAudio: function listenAudio() {}\n};\n\n// CONCATENATED MODULE: ./client/app/engine/settings/settings.controls.js\n/**\n *\n */\n\n\n\nvar settings_controls_ControlsModule = {\n  getControlsHTML: function getControlsHTML(controlsSettings) {\n    var content = "\\n            <div class=\\"container\\">\\n            <table class=\\"table table-bordered noselect\\" style=\\"width:100%\\">\\n        ";\n\n    if (controlsSettings.hasOwnProperty(\'language\')) {\n      var language = "\\n                <select id=\\"language\\" class=\\"form-control\\">\\n                    <option value=\\"default\\">Choose your layout:</option>\\n                    <option value=\\"en\\">en</option>\\n                    <option value=\\"fr\\">fr</option>\\n                </select>";\n      content += "<tr><td>Keyboard layout</td><td>".concat(language, "</td></tr>");\n    }\n\n    content += "\\n            <tr id=\\"return\\"><td colspan=\\"2\\">Return</td></tr>\\n            </table>\\n            </div>";\n    return content;\n  },\n  goControls: function goControls() {\n    this.unlistenSettingsMenu();\n    jquery_default()(\'#announce\').empty().append(this.getControlsHTML(this.controlsSettings));\n    this.listenReturn();\n    this.listenControls();\n  },\n  listenControls: function listenControls() {\n    var controlsEngine = this.app.engine.controls;\n\n    if (this.controlsSettings.hasOwnProperty(\'language\')) {\n      var l = jquery_default()(\'#language\');\n      l.change(function () {\n        var selected = l.find(\'option:selected\').val();\n        controlsEngine.changeLayout(selected, true); // Don\'t restart listeners.\n      });\n    }\n  },\n  unlistenControls: function unlistenControls() {\n    if (this.controlsSettings.hasOwnProperty(\'language\')) {\n      jquery_default()(\'#language\').off(\'change\');\n    }\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/settings/settings.graphics.js\n/**\n *\n */\n\n\n\nvar GraphicsModule = {\n  getGraphicsHTML: function getGraphicsHTML(graphicsSettings) {\n    var content = "\\n            <div class=\\"container\\">\\n            <table class=\\"table table-bordered noselect\\" style=\\"width:100%\\"\\n            ";\n\n    for (var s in graphicsSettings) {\n      content += "<tr><td>".concat(graphicsSettings[s], "</td></tr>");\n    }\n\n    content += "\\n            <tr id=\\"return\\"><td>Return</td></tr>\\n            </table>\\n            </div>";\n    return content;\n  },\n  goGraphics: function goGraphics() {\n    this.unlistenSettingsMenu();\n    jquery_default()(\'#announce\').empty().append(this.getGraphicsHTML(this.graphicsSettings));\n    this.listenReturn();\n  },\n  listenGraphics: function listenGraphics() {}\n};\n\n// CONCATENATED MODULE: ./client/app/engine/settings/settings.home.js\n/**\n *\n */\n\n\n\nvar HomeModule = {\n  getHomeHTML: function getHomeHTML() {\n    return "\\n            <div class=\\"container\\">\\n                <table class=\\"table table-bordered noselect\\" style=\\"width:100%\\">\\n                <tr id=\\"graphics\\"><td>Graphics</td></tr>\\n                <tr id=\\"gameplay\\"><td>Gameplay</td></tr>\\n                <tr id=\\"audio\\"><td>Audio</td></tr>\\n                <tr id=\\"return\\"><td>Return</td></tr>\\n                <tr id=\\"home\\"><td>Exit</td></tr>\\n                </table>\\n            </div>\\n        ";\n  },\n  goHome: function goHome() {\n    var app = this.app;\n    this.unlistenSettingsMenu(); // $(window).off(\'keydown\');\n    // this.app.setState(\'loading\');\n\n    app.engine.connection.send(\'leave\');\n    app.stopGame();\n\n    if (app.model.server.isDirty) {\n      app.engine.connection.disconnect();\n      app.setState(\'main\');\n      app.model.server.isDirty = false;\n    } else {\n      var hub = this.app.model.hub;\n      hub.enterHub();\n    }\n  },\n  listenHome: function listenHome() {\n    jquery_default()(\'#graphics\').click(function () {\n      this.goGraphics();\n    }.bind(this));\n    jquery_default()(\'#gameplay\').click(function () {\n      this.goControls();\n    }.bind(this));\n    jquery_default()(\'#audio\').click(function () {\n      this.goAudio();\n    }.bind(this));\n    jquery_default()(\'#home\').click(function () {\n      this.goHome();\n    }.bind(this));\n    jquery_default()(\'#return\').click(function () {\n      // $(window).off(\'keydown\');\n      this.unlistenSettingsMenu();\n      this.stateManager.setState(\'ingame\');\n      this.controlsEngine.requestLock();\n      this.app.setFocused(true);\n    }.bind(this)); // $(window).keydown(function(event) {\n    //     if (!event.keyCode) { return; }\n    //     if (event.keyCode === this.controlsEngine.keyControls.escape) {\n    // Remove listeners and get away from the bike.\n    // this.unlistenSettingsMenu();\n    // this.stateManager.setState(\'ingame\');\n    // }\n    // }.bind(this));\n    // this.listeners.push(\'graphics\', \'gameplay\', \'audio\', \'home\', \'return\');\n  },\n  unlistenSettingsMenu: function unlistenSettingsMenu() {\n    jquery_default()(window).off(\'keydown\');\n    jquery_default()(\'#graphics\').off(\'click\');\n    jquery_default()(\'#gameplay\').off(\'click\');\n    jquery_default()(\'#audio\').off(\'click\');\n    jquery_default()(\'#home\').off(\'click\');\n    jquery_default()(\'#return\').off(\'click\');\n  },\n  listenReturn: function listenReturn() {\n    jquery_default()(\'#return\').click(function () {\n      jquery_default()(\'#return\').off(\'click\');\n      jquery_default()(\'#announce\').empty().append(this.getHomeHTML());\n      this.listenHome();\n    }.bind(this));\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/engine/settings/settings.js\n/**\n *\n */\n\n\n\n\n\n\n\n\n\nvar Settings = function Settings(app) {\n  this.app = app;\n  this.listeners = [];\n};\n\nextend(Settings.prototype, {\n  run: function run() {\n    var app = this.app;\n    this.controlsEngine = app.engine.controls;\n    this.stateManager = app.state;\n    this.graphicsSettings = app.engine.graphics.settings;\n    this.controlsSettings = app.engine.controls.settings;\n    this.audioSettings = app.engine.audio.settings; // Add content, then fade in and add listeners.\n\n    jquery_default()(\'#announce\').empty().removeClass().addClass(\'settings\').append(this.getHomeHTML()).center().fadeIn();\n    this.listenHome();\n  },\n  stop: function stop() {\n    // Fade out settings menu.\n    this.unlistenSettingsMenu();\n    return new Promise(function (resolve) {\n      var settings = jquery_default()(\'#announce\');\n      settings.fadeOut(200, function () {\n        settings.empty().removeClass(\'settings\');\n        resolve();\n      });\n    });\n  },\n  unlisten: function unlisten() {\n    this.listeners.forEach(function (listener) {\n      var element = jquery_default()("#".concat(listener));\n      element.off(\'click\');\n      element.off(\'keydown\');\n    });\n    this.listeners = [];\n  }\n});\nextend(Settings.prototype, AudioModule);\nextend(Settings.prototype, settings_controls_ControlsModule);\nextend(Settings.prototype, GraphicsModule);\nextend(Settings.prototype, HomeModule);\n\n// CONCATENATED MODULE: ./client/app/model/hub/hub.js\n/**\n * Keeps track of active server games.\n */\n\n\n\n\nvar hub_Hub = function Hub(app) {\n  this.app = app;\n  this.games = new Map();\n};\n\nextend(hub_Hub.prototype, {\n  update: function update(data) {\n    data = JSON.parse(data);\n    var map = this.games;\n    map.clear(); // For all kinds.\n\n    for (var property in data) {\n      if (!data.hasOwnProperty(property)) continue;\n      var games = data[property];\n      map.set(property, games);\n    }\n\n    this.enterHub();\n  },\n  enterHub: function enterHub() {\n    var app = this.app;\n    var map = this.games;\n    app.setState(\'hub\', map);\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/model/server/entities/entity.js\n\n\n\n\n\nvar entity_Entity = function Entity(id, graphicalComponent, worldId) {\n  this.id = id;\n  this.graphicalComponent = graphicalComponent;\n  this.worldId = worldId; // Interpolation routines\n\n  this.position = new three_module["Sb" /* Vector3 */](0, 0, 0);\n  this.rotation = new three_module["Sb" /* Vector3 */](0, 0, 0);\n  this.lastUpdateTime = this.getTime();\n  this.averageDeltaT = this.lastUpdateTime;\n  this.lastServerUpdateTime = this.lastUpdateTime;\n  this.lastPFromServer = new three_module["Sb" /* Vector3 */](0, 0, 0);\n  this.currentPFromServer = new three_module["Sb" /* Vector3 */](0, 0, 0);\n  this.interpolatingP = new three_module["Sb" /* Vector3 */](0, 0, 0);\n  this.lastRFromServer = new three_module["Sb" /* Vector3 */](0, 0, 0);\n  this.currentRFromServer = new three_module["Sb" /* Vector3 */](0, 0, 0);\n  this.interpolatingR = new three_module["Sb" /* Vector3 */](0, 0, 0);\n  this.needsUpdate = true;\n  this.isProjectile = false;\n  this.inScene = false;\n  this.helper = null;\n};\n\nextend(entity_Entity.prototype, {\n  getHelper: function getHelper() {\n    return this.helper;\n  },\n  setHelper: function setHelper(object3D) {\n    this.helper = object3D;\n  },\n  getObject3D: function getObject3D() {\n    return this.graphicalComponent;\n  },\n  getWorldId: function getWorldId() {\n    return this.worldId;\n  },\n  setWorldId: function setWorldId(worldId) {\n    this.worldId = worldId;\n  },\n  getTime: function getTime() {\n    return window.performance.now();\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/model/server/entities/player.js\n/**\n *\n */\n\n\n\n\n\n\nvar PlayerModule = {\n  createMeleeMesh: function createMeleeMesh() {\n    var innerRadius = 0.5;\n    var outerRadius = 1.3;\n    var ringGeometry = new three_module["Cb" /* RingBufferGeometry */](innerRadius, outerRadius, 20, 1, 0, Math.PI);\n    var params = {\n      uniforms: {\n        time: {\n          value: 0.0\n        },\n        outerRadius: {\n          value: outerRadius\n        },\n        innerRadius: {\n          value: innerRadius\n        }\n      },\n      vertexShader: ShadersModule.getSwordTrailVertexShader(),\n      fragmentShader: ShadersModule.getSwordTrailFragmentShader(),\n      side: three_module["t" /* DoubleSide */],\n      transparent: true,\n      depthTest: false\n    };\n    var material = new three_module["Eb" /* ShaderMaterial */](params);\n    var meleeEffectMesh = new three_module["W" /* Mesh */](ringGeometry, material);\n    meleeEffectMesh.userData.bloom = true;\n    var wrapper = new three_module["kb" /* Object3D */]();\n    wrapper.position.set(0, 0, 0);\n    wrapper.rotation.x = Math.PI / 2;\n    wrapper.rotation.y = Math.PI;\n    wrapper.add(meleeEffectMesh);\n    meleeEffectMesh.rotation.set(0, Math.PI / 2 + Math.PI / 4, 0);\n    meleeEffectMesh.position.set(1, 1, -0.5);\n    meleeEffectMesh.renderOrder = 999;\n    var up = new three_module["kb" /* Object3D */]();\n    wrapper.rotation.reorder(\'ZYX\');\n    meleeEffectMesh.rotation.reorder(\'ZYX\');\n    up.add(wrapper);\n\n    up.getWrapper = function () {\n      return wrapper;\n    };\n\n    up.getMesh = function () {\n      return meleeEffectMesh;\n    };\n\n    return up;\n  },\n  createArrowTrail: function createArrowTrail(p) {\n    var MAX_POINTS = 250;\n    var geometry = new three_module["k" /* BufferGeometry */]();\n    var positions = new Float32Array(MAX_POINTS * 3); // 3 vertices per point\n\n    geometry.setAttribute(\'position\', new three_module["j" /* BufferAttribute */](positions, 3));\n    var index = 0;\n    positions[index++] = p.x;\n    positions[index++] = p.y;\n    positions[index++] = p.z;\n    var drawCount = 1; // draw the first x points, only\n\n    geometry.setDrawRange(0, drawCount);\n    geometry.attributes.position.needsUpdate = true;\n    geometry.computeBoundingSphere(); // let material = new LineBasicMaterial({ color: 0xff0000, linewidth: 3 });\n\n    var material = new three_module["K" /* LineDashedMaterial */]({\n      color: 0xffff00,\n      linewidth: 2,\n      scale: 1,\n      dashSize: 3,\n      gapSize: 1\n    });\n    var line = new three_module["I" /* Line */](geometry, material);\n    line.computeLineDistances();\n    return line;\n  },\n  loadArrow: function loadArrow(id, updatedEntity, graphics, entities) {\n    var wrapper = new three_module["kb" /* Object3D */]();\n    var cube = graphics.getItemMesh(ItemType.YA, false, true);\n    cube.userData.bloom = true;\n    wrapper.add(cube);\n    wrapper.rotation.x = Math.PI / 2;\n    wrapper.rotation.y = Math.PI;\n    wrapper._id = id;\n    var up = new three_module["kb" /* Object3D */]();\n    up.rotation.reorder(\'ZYX\');\n    up.add(wrapper);\n    wrapper.rotation.x = Math.PI / 2;\n    wrapper.rotation.y = Math.PI;\n    up._id = id; //delete createdEntity._id;\n\n    up.getWrapper = function () {\n      return wrapper;\n    };\n\n    var entity = new entity_Entity(id, up, parseInt(updatedEntity.w, 10));\n    entity.isProjectile = true;\n    this.updateEntity(id, entity, updatedEntity, graphics, entities);\n    entity.inScene = true;\n    graphics.addToScene(entity.getObject3D(), entity.getWorldId());\n    var p = entity.position;\n    var helper = this.createArrowTrail(entity.position);\n    entity.setHelper(helper);\n    graphics.addToScene(entity.getHelper(), entity.getWorldId());\n    up.position.set(p.x, p.y, p.z);\n    entity.lastPFromServer.set(p.x, p.y, p.z);\n    entity.currentPFromServer.set(p.x, p.y, p.z);\n    var rr = this.app.model.server.selfModel.rotation;\n    var r = entity.rotation;\n    r.set(rr[1], rr[2], rr[3]);\n    var object3D = entity.getObject3D();\n    object3D.rotation.x = r.z; // ur[3];\n\n    object3D.rotation.z = r.y; // ur[2];\n\n    object3D.getWrapper().rotation.y = Math.PI + r.x;\n    entity.lastRFromServer.set(r.x, r.y, r.z);\n    entity.currentRFromServer.set(r.x, r.y, r.z);\n    this.entitiesLoading["delete"](id);\n  },\n  loadCube: function loadCube(id, updatedEntity, graphics, entities) {\n    // This should be done in graphics\n    var wrapper = new three_module["kb" /* Object3D */]();\n    var cube = graphics.createMesh(graphics.createGeometry(\'box\'), graphics.createMaterial(\'flat-phong\', 0x5e2c04));\n    wrapper.add(cube);\n    wrapper.rotation.x = Math.PI / 2;\n    wrapper.rotation.y = Math.PI;\n    wrapper._id = id;\n    var up = new three_module["kb" /* Object3D */]();\n    up.rotation.reorder(\'ZYX\');\n    up.add(wrapper);\n    wrapper.rotation.x = Math.PI / 2;\n    wrapper.rotation.y = Math.PI;\n    up._id = id; //delete createdEntity._id;\n\n    up.getWrapper = function () {\n      return wrapper;\n    };\n\n    var entity = new entity_Entity(id, up, parseInt(updatedEntity.w, 10));\n    graphics.addToScene(entity.getObject3D(), entity.getWorldId());\n    this.updateEntity(id, entity, updatedEntity, graphics, entities);\n    this.entitiesLoading["delete"](id);\n  },\n  loadPlayer: function loadPlayer(id, updatedEntity, graphics, entities) {\n    var color = updatedEntity.a ? 0x00ff00 : 0xff0000;\n    var createdEntity = graphics.initializeEntity(id, \'steve\', color);\n    var object3D = graphics.finalizeEntity(id, createdEntity, color);\n    var entity = new entity_Entity(id, object3D, parseInt(updatedEntity.w, 10));\n    graphics.addToScene(entity.getObject3D(), entity.getWorldId());\n    this.updateEntity(id, entity, updatedEntity, graphics, entities);\n    this.entitiesLoading["delete"](id);\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/model/server/entities/entities.js\n/**\n *\n */\n\n\n\n\n\n\nvar entities_EntityModel = function EntityModel(app) {\n  this.app = app; // Model component\n\n  this.entitiesIngame = new Map();\n  this.entitiesOutdated = new Map();\n  this.entitiesLoading = new Set(); // Graphical component\n\n  this.needsUpdate = false; // Interpolation-prediction\n  // -> Moved per-entity.\n  // this.lastServerUpdateTime = this.getTime();\n  // this.averageDeltaT = -1;\n};\n\nextend(entities_EntityModel.prototype, PlayerModule);\nextend(entities_EntityModel.prototype, {\n  init: function init() {},\n  interpolatePredictEntities: function interpolatePredictEntities() {\n    var _this = this;\n\n    var updateTime = this.getTime();\n    var entities = this.entitiesIngame;\n    entities.forEach(function (entity) {\n      if (!entity.needsUpdate) return;\n\n      _this.interpolatePredictEntity(entity, updateTime);\n    });\n  },\n  interpolatePredictEntity: function interpolatePredictEntity(entity, updateTime) {\n    var upToDatePosition = entity.position;\n    var upToDateRotation = entity.rotation;\n    var currentP = entity.currentPFromServer;\n    var currentR = entity.currentRFromServer;\n    var lastP = entity.lastPFromServer;\n    var lastR = entity.lastRFromServer;\n\n    if (currentP.distanceTo(upToDatePosition) > 0 || currentR.distanceTo(upToDateRotation) > 0) {\n      lastP.copy(currentP);\n      currentP.copy(upToDatePosition);\n      lastR.copy(currentR);\n      currentR.copy(upToDateRotation);\n      entity.lastUpdateTime = updateTime; // if (this.averageDeltaT < 16 || this.averageDeltaT > 100) {\n\n      entity.averageDeltaT = updateTime - entity.lastServerUpdateTime; // }\n\n      entity.lastServerUpdateTime = updateTime;\n    }\n\n    var deltaServer = entity.averageDeltaT;\n    var t = updateTime - entity.lastUpdateTime;\n\n    if (t < deltaServer) {\n      // interpolate\n      var tdt = t / deltaServer;\n      var dpx = currentP.x - lastP.x;\n      var drx = currentR.x - lastR.x;\n      if (drx > Math.PI) drx = 2 * Math.PI - drx;\n      if (drx < -Math.PI) drx += 2 * Math.PI;\n      var dpy = currentP.y - lastP.y;\n      var dry = currentR.y - lastR.y;\n      var dpz = currentP.z - lastP.z;\n      var drz = currentR.z - lastR.z;\n      this.setLerp(entity, lastP.x + tdt * dpx, lastP.y + tdt * dpy, lastP.z + tdt * dpz, lastR.x + tdt * drx, lastR.y + tdt * dry, lastR.z + tdt * drz);\n    } else if (entity.interpolatingP.distanceTo(currentP) > 0 || entity.interpolatingR.distanceTo(currentR) > 0) {\n      this.setLerp(entity, currentP.x, currentP.y, currentP.z, currentR.x, currentR.y, currentR.z);\n      entity.needsUpdate = false;\n    }\n  },\n  setLerp: function setLerp(entity, px, py, pz, rx, ry, rz) {\n    var v = new three_module["Sb" /* Vector3 */]();\n    entity.interpolatingP.set(px, py, pz);\n    entity.interpolatingR.set(rx, ry, rz);\n    this.updateGraphicalEntity(entity, entity.interpolatingP, entity.interpolatingR, v);\n  },\n  updateGraphicalEntity: function updateGraphicalEntity(currentEntity, newP, newR) //, oldP)\n  {\n    // Update positions and rotation\n    var object3D = currentEntity.getObject3D();\n    var graphics = this.app.engine.graphics;\n    var p = object3D.position;\n    var animate = p.x !== newP.x || p.y !== newP.y; // XXX [ANIMATION] link animation in 3D case\n\n    if (currentEntity.isProjectile) {\n      var dx = newP.x - p.x;\n      var dy = newP.y - p.y;\n      var dz = newP.z - p.z;\n      var v1;\n      var v2;\n      var pi = Math.PI;\n      var dxxdyy = dx * dx + dy * dy;\n\n      if (dxxdyy + dz * dz < 1e-12) {\n        var selfRotation = this.app.model.server.selfModel.rotation;\n        v1 = selfRotation[2];\n        v2 = selfRotation[3];\n        var rr = currentEntity.currentRFromServer;\n        object3D.rotation.x = Math.PI + rr[3]; // newR.z; // ur[3];\n\n        object3D.rotation.z = rr[2]; // newR.y; // ur[2];\n        // object3D.getWrapper().rotation.y = selfRotation[0];\n      } else {\n        if (dy > 0) {\n          v1 = Math.atan(-dx / dy);\n        } else if (dy < 0) {\n          v1 = dx < 0 ? pi - Math.atan(dx / dy) : dx > 0 ? -pi + Math.atan(-dx / dy) :\n          /*x === 0 ?*/\n          pi;\n        } else\n          /*if (y === 0)*/\n          {\n            v1 = dx < 0 ? pi / 2 : dx > 0 ? -pi / 2 :\n            /*x === 0*/\n            0;\n          }\n\n        if (dz < 0) {\n          v2 = -Math.atan(Math.sqrt(dxxdyy) / dz);\n        } else if (dz > 0) {\n          v2 = pi - Math.atan(Math.sqrt(dxxdyy) / dz);\n        } else\n          /*if (z === 0)*/\n          {\n            v2 = pi / 2;\n          } // this.newRot = Date.now();\n        // this.elapsed  = this.newRot - (this.lastRot || 0);\n        // this.lastRot = this.newRot;\n        // console.log(this.elapsed);\n\n\n        object3D.rotation.x = Math.PI + v2; // newR.z; // ur[3];\n\n        object3D.rotation.z = v1; // newR.y; // ur[2];\n        //object3D.getWrapper().rotation.y = Math.PI + newR.x; // + ur[0];\n\n        if (!currentEntity.inScene) {\n          currentEntity.inScene = true;\n          graphics.addToScene(object3D, currentEntity.getWorldId());\n        }\n\n        var helper = currentEntity.getHelper();\n\n        if (helper && helper.geometry) {\n          var positions = helper.geometry.attributes.position.array;\n          var MAX_POINTS = positions.length / 3;\n          var drawRange = helper.geometry.drawRange.count;\n          var index = 3 * drawRange;\n\n          if (drawRange < MAX_POINTS) {\n            positions[index++] = newP.x;\n            positions[index++] = newP.y;\n            positions[index++] = newP.z;\n            helper.computeLineDistances();\n            helper.geometry.setDrawRange(0, drawRange + 1);\n            helper.geometry.attributes.position.needsUpdate = true;\n            helper.geometry.computeBoundingSphere(); // console.log(helper.geometry.attributes.position.array);\n          } else {\n            index = 0;\n\n            for (var i = 0; i < MAX_POINTS - 1; ++i) {\n              positions[index] = positions[index + 3];\n              positions[index + 1] = positions[index + 4];\n              positions[index + 2] = positions[index + 5];\n              index += 3;\n            }\n\n            positions[index] = newP.x;\n            positions[index + 1] = newP.y;\n            positions[index + 2] = newP.z;\n            helper.computeLineDistances();\n            helper.geometry.setDrawRange(0, drawRange + 1);\n            helper.geometry.attributes.position.needsUpdate = true;\n            helper.geometry.computeBoundingSphere();\n          }\n        }\n      }\n\n      object3D.updateMatrixWorld();\n    } else {\n      object3D.rotation.x = newR.z; // ur[3];\n\n      object3D.rotation.z = newR.y; // ur[2];\n\n      object3D.getWrapper().rotation.y = Math.PI + newR.x; // + ur[0];\n\n      object3D.updateMatrixWorld();\n    }\n\n    p.copy(newP); // Update animation\n\n    var id = currentEntity.id;\n    if (animate) graphics.updateAnimation(id);\n  },\n  addEntity: function addEntity(id, updatedEntity, graphics, entities) {\n    this.entitiesLoading.add(id);\n\n    switch (updatedEntity.k) {\n      case \'ia\':\n      case \'player\':\n        this.loadPlayer(id, updatedEntity, graphics, entities);\n        break;\n\n      case \'projectile\':\n        this.loadArrow(id, updatedEntity, graphics, entities);\n        break;\n\n      case \'cube\':\n        this.loadCube(id, updatedEntity, graphics, entities);\n        break;\n\n      default:\n        console.log("\\n                    ServerModel::addEntity: Unknown entity type \'".concat(updatedEntity.k, "\'.\\n                "));\n    }\n  },\n  removeEntity: function removeEntity(id, graphics, entities) {\n    var entity = entities.get(id);\n\n    if (entity) {\n      var wid = entity.getWorldId();\n      graphics.removeFromScene(entity.getObject3D(), wid);\n\n      if (entity.helper) {\n        graphics.removeFromScene(entity.getHelper(), wid);\n      }\n    }\n\n    entities["delete"](id);\n  },\n  updateEntity: function updateEntity(id, currentEntity, updatedEntity, graphics, entities) {\n    var pos = currentEntity.position;\n    var rot = currentEntity.rotation;\n    var up = updatedEntity.p;\n    var ur = updatedEntity.r;\n\n    if (!pos || !rot || pos[0] !== up[0] || pos[1] !== up[1] || pos[2] !== up[2] || rot[0] !== ur[0] || rot[1] !== ur[2] || rot[2] !== ur[3]) // shifted\n      {\n        currentEntity.position.set(up[0], up[1], up[2]);\n        currentEntity.rotation.set(ur[0], ur[2], ur[3]);\n        currentEntity.needsUpdate = true;\n      } // Switch worlds.\n\n\n    var worldId = parseInt(updatedEntity.w, 10);\n    var oldWorldId = currentEntity.getWorldId();\n\n    if (oldWorldId !== worldId) {\n      graphics.removeFromScene(currentEntity.getObject3D(), oldWorldId, true);\n      currentEntity.setWorldId(worldId);\n      graphics.addToScene(currentEntity.getObject3D(), worldId);\n      var helper = currentEntity.getHelper();\n\n      if (helper) {\n        graphics.removeFromScene(helper, oldWorldId, true);\n        graphics.addToScene(helper, worldId);\n        console.log(helper);\n      }\n    } // Update current "live" entities.\n\n\n    entities.set(id, currentEntity);\n\n    if (updatedEntity.d) {\n      var hasJustMeleed = updatedEntity.d[1];\n\n      if (hasJustMeleed) {\n        console.log(\'Someone meleed.\');\n      } // console.log(updatedEntity.d);\n\n    }\n  },\n  refresh: function refresh() {\n    var _this2 = this;\n\n    if (!this.needsUpdate) {\n      this.interpolatePredictEntities();\n      return;\n    }\n\n    var graphics = this.app.engine.graphics;\n    var entities = this.entitiesIngame;\n    var pushes = this.entitiesOutdated;\n    pushes.forEach(function (updatedEntity, id) {\n      if (_this2.entitiesLoading.has(id)) return;\n      var currentEntity = entities.get(id);\n      if (!updatedEntity) _this2.removeEntity(id, graphics, entities);else if (!currentEntity) _this2.addEntity(id, updatedEntity, graphics, entities);else _this2.updateEntity(id, currentEntity, updatedEntity, graphics, entities);\n    });\n    this.interpolatePredictEntities(); // Flush buffer.\n\n    this.entitiesOutdated = new Map(); // Unset dirty flag.\n\n    this.needsUpdate = false;\n  },\n  updateEntities: function updateEntities(entities) {\n    if (!entities) {\n      console.log(\'Empty update @ server.sub.entities.js\');\n      return;\n    }\n\n    var pushes = this.entitiesOutdated;\n\n    for (var eid in entities) {\n      if (!entities.hasOwnProperty(eid)) continue;\n      pushes.set(eid, entities[eid]);\n    } // Set dirty flag.\n\n\n    this.needsUpdate = true;\n  },\n  // Catmull interpolation, could come in handy\n  cerp: function cerp(a, b, c, d, t) {\n    var m0 = a ? [c[0] - a[0], c[1] - a[1], c[2] - a[2]] : [c[0] - b[0], c[1] - b[1], c[2] - b[2]];\n    var m1 = d ? [d[0] - b[0], d[1] - b[1], d[2] - b[2]] : [c[0] - b[0], c[1] - b[1], c[2] - b[2]];\n    return this.catmull(b, c, m0, m1, t);\n  },\n  catmull: function catmull(p0, p1, m0, m1, t) {\n    var t2 = t * t;\n    var a = 1 + t2 * (2 * t - 3);\n    var b = t * (1 + t2 * (t - 2));\n    var c = t2 * (3 - 2 * t);\n    var d = t2 * (t - 1);\n    return [a * p0[0] + b * m0[0] + c * p1[0] + d * m1[0], a * p0[1] + b * m0[1] + c * p1[1] + d * m1[1], a * p0[2] + b * m0[2] + c * p1[2] + d * m1[2]];\n  },\n  getTime: function getTime() {\n    return window.performance.now();\n  },\n  cleanup: function cleanup() {\n    this.entitiesIngame.clear();\n    this.entitiesOutdated.clear();\n    this.entitiesLoading.clear();\n    this.needsUpdate = false; // XXX [CLEANUP] graphical component and all meshes\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/model/server/self/inventory.js\n/**\n * Player inventory (current player only).\n */\n\n\n\n\n\nvar InventoryModel = function InventoryModel() {\n  this.activeItemId = 0;\n  this.inventorySize = 256; // Gameplay items\n\n  this.items = new Uint16Array(this.inventorySize); // Clothes and armor\n\n  this.outfit = new Uint8Array(0);\n  this.reset();\n};\n\nextend(InventoryModel.prototype, {\n  reset: function reset() {// this.setItem(0, ItemType.BLOCK_PLANKS);\n    // this.setItem(1, ItemType.KATANA);\n    // this.setItem(2, ItemType.YUMI);\n    // this.setItem(3, ItemType.PORTAL_GUN_SINGLE);\n    // this.setItem(4, ItemType.PORTAL_GUN_DOUBLE);\n  },\n  // These would be client methods.\n  // getActiveItem()\n  // {\n  //     return this.items[this.activeItemId];\n  // },\n  // setActiveItem(id)\n  // {\n  //     if (id !== parseInt(id, 10) || id < 0 || id > this.inventorySize)\n  //         console.error(\'[Model/Inventory] Invalid inventory slot.\');\n  //     this.activeItemId = id;\n  //     return this.items[id];\n  // },\n  getItem: function getItem(id) {\n    if (id !== parseInt(id, 10) || id < 0 || id > this.inventorySize) console.error(\'[Model/Inventory] Invalid inventory slot.\');\n    return this.items[id];\n  },\n  setItem: function setItem(id, item) {\n    if (id !== parseInt(id, 10) || id < 0 || id > this.inventorySize) console.warn(\'[Model/Inventory] Invalid inventory slot.\');\n    if (!this.isItemIDSupported(item)) console.warn(\'[Model/Inventory] Invalid item ID.\');\n    this.items[id] = item;\n  }\n});\nextend(InventoryModel.prototype, ItemsModelModule);\n\n// CONCATENATED MODULE: ./client/app/model/server/self/self.interpolate.js\n/**\n * Handles avatar position and rotation interpolation.\n */\n\n\n\nvar SelfInterpolationModule = {\n  _d42: function _d42(v41, v42) {\n    var dx = v41.x - v42.x;\n    var dy = v41.y - v42.y;\n    var dz = v41.z - v42.z;\n    var dw = v41.w - v42.w;\n    return dx * dx + dy * dy + dz * dz + dw * dw;\n  },\n  interpolatePredictSelfPosition: function interpolatePredictSelfPosition() {\n    var lastP = this.lastPositionFromServer;\n    var currentP = this.currentPositionFromServer;\n    var lastR = this.lastRotationFromServer;\n    var currentR = this.currentRotationFromServer;\n    var p = this.position;\n    var r = this.rotation;\n    var upToDatePosition = new three_module["Sb" /* Vector3 */](p.x, p.y, p.z); // "up-to-date" server position\n\n    var upToDateRotation = new three_module["Tb" /* Vector4 */](r[0], r[1], r[2], r[3]); // "up-to-date" rotation\n\n    var updateTime = this.getTime(); // const deltaClient = updateTime - this.lastClientUpdateTime;\n    // this.lastClientUpdateTime = updateTime;\n\n    if (currentP.distanceTo(upToDatePosition) > 0 || this._d42(currentR, upToDateRotation) > 0) {\n      // changed!\n      lastP.copy(currentP);\n      currentP.copy(upToDatePosition);\n      lastR.copy(currentR);\n      currentR.copy(upToDateRotation); // compute average delta.\n\n      var _deltaServer = updateTime - this.lastServerUpdateTime; // if (this.averageDeltaT < 16 || this.averageDeltaT > 100) {\n\n\n      this.averageDeltaT = _deltaServer; // }\n\n      this.lastServerUpdateTime = updateTime;\n    }\n\n    var t = updateTime - this.lastServerUpdateTime;\n    var deltaServer = this.averageDeltaT;\n\n    if (t < deltaServer) {\n      // interpolate\n      var tdt = t / deltaServer;\n      var dxp = currentP.x - lastP.x;\n      var dxr = currentR.x - lastR.x;\n      var dyp = currentP.y - lastP.y;\n      var dyr = currentR.y - lastR.y;\n      var dzp = currentP.z - lastP.z;\n      var dzr = currentR.z - lastR.z;\n      var dwr = currentR.w - lastR.w; // let pv = this.predictedVelocity;\n      // let ip = this.interpolatingPosition;\n      // pv.copy(ip);\n\n      this.setLerp(lastP.x + tdt * dxp, lastP.y + tdt * dyp, lastP.z + tdt * dzp, lastR.x + tdt * dxr, lastR.y + tdt * dyr, lastR.z + tdt * dzr, lastR.w + tdt * dwr); // pv.set(ip.x - pv.x, ip.y - pv.y, ip.z - pv.z);\n    } // Prediction goes there (but must be queried for every game update,\n    // this pass here is already filtered)\n    // } else if (t < 2 * deltaServer) {\n    //     let pv = this.predictedVelocity;\n    //     let ip = this.interpolatingPosition;\n    //     this.setLerp(ip.x + pv.x, ip.y + pv.y, ip.z + pv.z);\n    //     this.lastInterpolatingPosition.copy(this.interpolatingPosition);\n    else if (this.interpolatingPosition.distanceTo(currentP) > 0 || this._d42(this.interpolatingRotation, currentR) > 0) {\n        this.interpolationUpToDate = true;\n        this.setLerp(currentP.x, currentP.y, currentP.z, currentR.x, currentR.y, currentR.z, currentR.w); // }\n        // Correction goes there (go back to the last updated)\n        // const tdt = (t - 2 * deltaServer) / deltaServer;\n        // if (tdt < 1) {\n        //     const cp = this.lastInterpolatingPosition;\n        //     const dx = last.x - cp.x;\n        //     const dy = last.x - cp.y;\n        //     const dz = last.x - cp.z;\n        //     this.setLerp(last.x + tdt * dx, last.y + tdt * dy, last.z + tdt * dz);\n        // } else\n      }\n\n    if (this.needsWorldSwitchRetry) this.interpolateSwitchWorld();\n  },\n  setLerp: function setLerp(xp, yp, zp, xr, yr, zr, wr) {\n    // Rotation\n    this.interpolatingRotation.set(xr, yr, zr, wr);\n    this.updateRotation(this.avatar, this.interpolatingRotation); // Update interpolating position before world cross check\n\n    this.interpolatingPosition.set(xp, yp, zp); // World switch\n\n    if (this.worldNeedsUpdate && this.oldWorldId) {\n      if (this.interpolationUpToDate) {\n        // failed to collide earlier, or the player is moving really fast\n        this.interpolateSwitchWorld();\n      } else {\n        this.intersectPortals(this.avatar.position, this.interpolatingPosition);\n      }\n    } // Update avatar position after world cross check\n\n\n    this.updatePosition(this.avatar, this.interpolatingPosition);\n  },\n  interpolateSwitchWorld: function interpolateSwitchWorld() {\n    var graphics = this.app.engine.graphics;\n\n    if (!graphics.sceneManager.hasScene(this.newWorldId)) {\n      console.warn(\'[UpdateWorld] New world not loaded yet, retrying to switch later.\');\n      this.interpolationUpToDate = false;\n      this.needsWorldSwitchRetry = true;\n      return;\n    }\n\n    this.worldId = this.newWorldId;\n    this.updateWorld();\n    var p = this.position;\n    var last = this.lastPositionFromServer;\n    var current = this.currentPositionFromServer;\n    last.copy(current);\n    current.copy(p);\n    this.interpolatingPosition.copy(p);\n    this.updatePosition(this.avatar, this.interpolatingPosition);\n    this.interpolationUpToDate = true;\n    this.worldNeedsUpdate = false;\n    this.needsWorldSwitchRetry = false;\n  },\n  intersectPortals: function intersectPortals(oldPosition, newPosition) {\n    var _this = this;\n\n    var portals = this.xModel.portals;\n    var worldsToPortals = this.xModel.worldToPortals;\n    var oldWorldId = parseInt(this.oldWorldId, 10); // I just crossed a portal from the old world.\n\n    var potentiallyCrossed = worldsToPortals.get(oldWorldId);\n\n    if (!potentiallyCrossed) {\n      console.warn("[Self/Interpolate] Didn\\u2019t find any portal in world ".concat(oldWorldId, "."));\n      return;\n    }\n\n    var opx = oldPosition.x;\n    var opy = oldPosition.y;\n    var opz = oldPosition.z;\n    var npx = newPosition.x;\n    var npy = newPosition.y;\n    var npz = newPosition.z;\n    var found = false;\n    potentiallyCrossed.forEach(function (id) {\n      if (found) return; // how does one short-circuit a forEach again?\n\n      if (!id) return;\n      var portal = portals.get(id);\n\n      if (!portal) {\n        console.warn("[Self/Intersection] Portal not found: ".concat(id, "."));\n      }\n\n      if (!portal.tempPosition || !portal.tempOtherPosition || !portal.tempPosition.length) {\n        console.warn("[Self/Intersection] Corrupt portal found: ".concat(id, "."));\n        return;\n      }\n\n      var x0 = parseFloat(portal.tempPosition[0]);\n      var y0 = parseFloat(portal.tempPosition[1]);\n      var z0 = parseFloat(portal.tempPosition[2]);\n      var x1 = parseFloat(portal.tempOtherPosition[0]);\n      var y1 = parseFloat(portal.tempOtherPosition[1]);\n      var z1 = parseFloat(portal.tempOtherPosition[2]); // let p = state[6]; // Ratio towards +\n\n      var o = parseFloat(portal.tempOrientation); // Orientation if ambiguous.\n\n      var pid = portal.portalId;\n      var sum = 0 + (x1 === x0) + (y1 === y0) + (z1 === z0);\n\n      if (sum !== 2) {\n        console.warn("[Self/Intersection] Invalid portal found: ".concat(pid, "."));\n        return;\n      } // | This is the same collision routine as in the server.\n      // V\n\n\n      var axis = x1 !== x0 ? \'x\' : y1 !== y0 ? \'y\' : z1 !== z0 ? \'z\' : \'?\';\n      var beta = -parseFloat(o);\n      if (axis === \'x\') beta += Math.PI / 2;\n      if (axis === \'y\') beta = -beta + Math.PI / 2;\n      var cosBeta = Math.cos(beta);\n      var sinBeta = Math.sin(beta);\n\n      var transform = function transform(inputX, inputY, inputZ) {\n        return [inputX * cosBeta - inputY * sinBeta, inputY * cosBeta + inputX * sinBeta, inputZ];\n      };\n\n      var fx0;\n      var fx1;\n      var fy0;\n      var fy1;\n      var fz0;\n      var fz1;\n      var cosAlphaO;\n      var sinAlphaO;\n      var cosAlphaN;\n      var sinAlphaN;\n      var oT;\n      var nT;\n\n      switch (axis) {\n        case \'x\':\n          // Warn! for \'x\', \'first\' is z.\n          cosAlphaO = opz - (z0 + 0.5);\n          sinAlphaO = opy - (y0 + 0.5);\n          cosAlphaN = npz - (z0 + 0.5);\n          sinAlphaN = npy - (y0 + 0.5);\n          oT = transform(cosAlphaO, sinAlphaO, opx);\n          nT = transform(cosAlphaN, sinAlphaN, npx);\n          oT[0] += z0 + 0.5;\n          nT[0] += z0 + 0.5;\n          oT[1] += y0 + 0.5;\n          nT[1] += y0 + 0.5;\n          fx0 = z0 + 0.5;\n          fx1 = fx0;\n          fy0 = Math.min(y0, y1);\n          fy1 = Math.max(y0, y1) + 1;\n          fz0 = Math.min(x0, x1) + 0.5;\n          fz1 = Math.max(x0, x1) + 1.5;\n          break;\n\n        case \'y\':\n          cosAlphaO = opx - (x0 + 0.5);\n          sinAlphaO = opz - (z0 + 0.5);\n          cosAlphaN = npx - (x0 + 0.5);\n          sinAlphaN = npz - (z0 + 0.5);\n          oT = transform(cosAlphaO, sinAlphaO, opy);\n          nT = transform(cosAlphaN, sinAlphaN, npy);\n          oT[0] += x0 + 0.5;\n          nT[0] += x0 + 0.5;\n          oT[1] += z0 + 0.5;\n          nT[1] += z0 + 0.5;\n          fx0 = x0 + 0.5;\n          fx1 = fx0;\n          fy0 = Math.min(z0, z1);\n          fy1 = Math.max(z0, z1) + 1;\n          fz0 = Math.min(y0, y1) + 0.5;\n          fz1 = Math.max(y0, y1) + 1.5;\n          break;\n\n        case \'z\':\n          cosAlphaO = opx - (x0 + 0.5);\n          sinAlphaO = opy - (y0 + 0.5);\n          cosAlphaN = npx - (x0 + 0.5);\n          sinAlphaN = npy - (y0 + 0.5);\n          oT = transform(cosAlphaO, sinAlphaO, opz);\n          nT = transform(cosAlphaN, sinAlphaN, npz);\n          oT[0] += x0 + 0.5;\n          nT[0] += x0 + 0.5;\n          oT[1] += y0 + 0.5;\n          nT[1] += y0 + 0.5;\n          fx0 = x0 + 0.5;\n          fx1 = fx0;\n          fy0 = Math.min(y0, y1);\n          fy1 = Math.max(y0, y1) + 1;\n          fz0 = Math.min(z0, z1) + 0.5;\n          fz1 = Math.max(z0, z1) + 1.5;\n          break;\n\n        default:\n          console.log(\'[XCollide] Unmanaged portal orientation.\');\n          return;\n      } // Perform collision\n\n\n      var crossedX = oT[0] > fx0 && nT[0] < fx1 || oT[0] < fx0 && nT[0] > fx1;\n      var inY = oT[1] > fy0 && oT[1] < fy1 && nT[1] > fy0 && nT[1] < fy1;\n      var inZ = oT[2] + .5 > fz0 && oT[2] + .5 < fz1 && nT[2] + .5 > fz0 && nT[2] + .5 < fz1;\n\n      if (crossedX && inY && inZ) {\n        // Perform world switch here!\n        found = true;\n\n        _this.interpolateSwitchWorld();\n      }\n    });\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/model/server/self/self.update.js\n/**\n * Handles avatar updates.\n */\n\n\nvar SelfUpdateModule = {\n  updatePosition: function updatePosition(avatar, newP) {\n    var register = this.app.register;\n    var graphics = this.app.engine.graphics;\n    var clientModel = this.app.model.client;\n    var handItemWrapper = this.handItemWrapper;\n    var id = this.entityId;\n    var p = avatar.position; // Notify modules.\n\n    register.updateSelfState({\n      position: [p.x, p.y, p.z]\n    }); // Update animation.\n\n    var animate = p.x !== newP.x || p.y !== newP.y; // XXX [ANIMATION] manage 3D.\n\n    if (animate) {\n      graphics.updateAnimation(id); // TODO [ANIMATION] activate hand-held animation\n      // graphics.updateAnimation(\'yumi\');\n    }\n\n    p.copy(newP); // Update camera.\n\n    clientModel.pushForLaterUpdate(\'camera-position\', p);\n    graphics.cameraManager.updateCameraPosition(p);\n    var handItem = this.handItem;\n\n    if (handItem && handItemWrapper) {\n      var mc = graphics.cameraManager.mainCamera;\n      handItemWrapper.position.copy(mc.up.position);\n    }\n  },\n  updateRotation: function updateRotation(avatar, r) {\n    var graphics = this.app.engine.graphics;\n    var handItemWrapper = this.handItemWrapper;\n    avatar.rotation.z = r.z;\n    avatar.rotation.x = r.w;\n    avatar.getWrapper().rotation.y = Math.PI + r.x;\n    var theta0 = r.z;\n    var theta1 = r.w;\n    var cam = graphics.cameraManager.mainCamera;\n    var rotationX = cam.getXRotation();\n    var changed = graphics.cameraManager.setAbsRotationFromServer(theta0, theta1); // OPT compute delta transmitted from last time;\n    // only works when interpolation is switched off.\n    // let rotationZ = cam.getZRotation();\n    // if (changed) graphics.cameraManager.setRelRotation(rotationZ + r.x - r.y, rotationX);\n\n    if (changed) graphics.cameraManager.setRelRotation(r.x, rotationX); // mainCamera.setUpRotation(theta1, 0, theta0);\n    // moveCameraFromMouse(0, 0, newX, newY);\n\n    var handItem = this.handItem;\n\n    if (handItem && handItemWrapper) {\n      var mc = graphics.cameraManager.mainCamera;\n      handItemWrapper.rotation.copy(mc.up.rotation);\n      handItem.rotation.x = mc.pitch.rotation.x;\n      handItem.rotation.z = mc.yaw.rotation.z;\n    }\n  },\n  updateWorld: function updateWorld() {\n    var graphics = this.app.engine.graphics;\n    var avatar = this.avatar;\n    var handItemWrapper = this.handItemWrapper;\n    var xModel = this.xModel;\n    var worldId = this.worldId;\n    var oldWorldId = this.oldWorldId;\n    var displayAvatar = this.displayAvatar;\n    var displayHandItem = this.displayHandItem;\n    if (displayAvatar) graphics.removeFromScene(avatar, oldWorldId); // TODO [GAMEPLAY] differentiate 3d person and 1st person\n\n    if (displayHandItem) graphics.removeFromScene(handItemWrapper, oldWorldId);\n    graphics.switchToScene(oldWorldId, worldId);\n    xModel.switchAvatarToWorld(oldWorldId, worldId);\n    if (displayAvatar) graphics.addToScene(avatar, worldId);\n    if (displayHandItem) graphics.addToScene(handItemWrapper, worldId);\n    xModel.forceUpdate = true;\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/model/server/self/self.objects.js\n/**\n * Handles loading and updates for objects attached to avatar.\n */\n\n\n\nvar SelfObjectsModule = {\n  loadSelf: function loadSelf() {\n    var selfModel = this;\n    var graphics = this.app.engine.graphics; // Player id \'-1\' never used by any other entity.\n\n    var entityId = this.entityId;\n    var worldId = this.worldId;\n    var createdEntity = graphics.initializeEntity(entityId, \'steve\', 0xffff00);\n    var object3d = graphics.finalizeEntity(entityId, createdEntity, 0xffff00);\n    selfModel.avatar = object3d;\n    if (selfModel.displayAvatar) graphics.addToScene(object3d, worldId);\n    this.updateHandItem();\n  },\n  initMelee: function initMelee() {\n    var graphics = this.app.engine.graphics;\n\n    if (!this.meleeEffectMesh) {\n      var em = this.app.model.server.entityModel;\n      this.meleeEffectMesh = em.createMeleeMesh();\n    }\n\n    var worldId = this.worldId;\n    var mesh = this.meleeEffectMesh;\n\n    if (this.meleeWorld !== null && this.meleeWorld !== worldId) {\n      graphics.removeFromScene(mesh, this.meleeWorld, true);\n    }\n\n    this.meleeWorld = worldId;\n    this.isHittingMelee = true;\n    var us = mesh.getMesh().material.uniforms;\n    us.time.value = 0;\n    var p = // this.currentPositionFromServer;\n    // graphics.cameraManager.mainCamera.up.position;\n    this.avatar.position;\n    mesh.position.copy(p);\n    graphics.addToScene(mesh, worldId);\n  },\n  updateMelee: function updateMelee() {\n    var graphics = this.app.engine.graphics;\n    var mesh = this.meleeEffectMesh;\n    var us = mesh.getMesh().material.uniforms;\n    us.time.value += 0.1;\n\n    if (us.time.value < 2.0) {\n      this.isHittingMelee = true;\n      var mc = graphics.cameraManager.mainCamera;\n      var p = // this.currentPositionFromServer;\n      // this.avatar.position;\n      graphics.cameraManager.mainCamera.up.position;\n      mesh.position.copy(p);\n      mesh.rotation.copy(mc.up.rotation);\n      mesh.getWrapper().rotation.x = -Math.PI / 2 + 0.2 + mc.pitch.rotation.x;\n      mesh.getWrapper().rotation.z = mc.yaw.rotation.z;\n    } else {\n      this.isHittingMelee = false;\n      this.meleeWorld = null;\n      graphics.removeFromScene(mesh, this.meleeWorld, true);\n    }\n  },\n  updateBow: function updateBow() {\n    var graphics = this.app.engine.graphics;\n    var times = graphics.times;\n    var mixers = graphics.mixers;\n    var mixer = mixers.get(\'yumi\');\n    if (!mixer) return;\n\n    if (this.needsStartLoadingBow) {\n      mixer.setTime(0);\n      mixer.update(0);\n      var yumiClip = graphics.clips.get(\'yumi\');\n      yumiClip.reset();\n      yumiClip.play();\n      times.set(\'yumi\', Date.now());\n      this.needsStartLoadingBow = false;\n      this.needsStopLoadingBow = false;\n      this.loadingBow = true;\n    } else if (this.needsStopLoadingBow) {\n      this.needsStartLoadingBow = false;\n      this.needsStopLoadingBow = false;\n      mixer.setTime(0);\n      mixer.update(0);\n      this.isLoadingBow = false;\n    } else if (this.isLoadingBow) {\n      // console.log(mixer._root.morphTargetInfluences);\n      var prevTime = times.get(\'yumi\') || Date.now();\n      var time = Date.now();\n      var delta = (time - prevTime) * 0.001;\n      mixer.update(delta);\n      times.set(\'yumi\', time);\n    }\n  },\n  updateHandItem: function updateHandItem() {\n    var selfModel = this;\n    var graphics = this.app.engine.graphics;\n    var worldId = this.worldId;\n    var handItemID = this.app.model.client.selfComponent.getCurrentItemID();\n    var handItem;\n    if (ItemsModelModule.isItemNaught(handItemID)) handItem = null;else if (ItemsModelModule.isItemRanged(handItemID) || ItemsModelModule.isItemMelee(handItemID) || ItemsModelModule.isItemX(handItemID) || ItemsModelModule.isItemBlock(handItemID)) {\n      handItem = graphics.getItemMesh(handItemID, true, false);\n    } else {\n      console.warn(\'[ServerSelf] Handheld item unrecognized.\');\n      handItem = null;\n    } // TODO [GAMEPLAY] link hand item and mesh when camera is third person.\n\n    if (selfModel.handItem !== handItem) {\n      var handItemWrapper = selfModel.handItemWrapper;\n      if (selfModel.handItem) // is it possible that it is in another world?\n        handItemWrapper.remove(selfModel.handItem);\n      selfModel.handItem = handItem;\n\n      if (handItem) {\n        handItemWrapper.position.copy(graphics.cameraManager.mainCamera.up.position);\n        this.cameraMoved(graphics.cameraManager.mainCamera);\n        handItemWrapper.add(handItem);\n\n        if (selfModel.displayHandItem) {\n          graphics.addToScene(handItemWrapper, worldId);\n        }\n      }\n    }\n\n    this.needsStopLoadingBow = true;\n    this.needsStartLoadingBow = false;\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/model/server/self/self.js\n/**\n *\n */\n\n\n\n\n\n\n\n\n\nvar self_SelfModel = function SelfModel(app) {\n  this.app = app;\n  this.xModel = null; // General.\n\n  this.entityId = \'-1\'; // Self default\n\n  this.worldId = \'-1\'; // Overworld default\n\n  this.oldWorldId = null; // Model component.\n\n  this.position = new three_module["Sb" /* Vector3 */](0, 0, 0);\n  this.rotation = [0, 0, 0, 0];\n  this.inventoryModel = new InventoryModel(); // Graphical component.\n\n  this.worldNeedsUpdate = false;\n  this.needsUpdate = false;\n  this.displayAvatar = false;\n  this.displayHandItem = true;\n  this.avatar = null;\n  this.handItem = null;\n  this.handItemWrapper = new three_module["kb" /* Object3D */]();\n  this.handItemWrapper.rotation.reorder(\'ZYX\'); // Melee mesh\n\n  this.meleeEffectMesh = null;\n  this.needsStartMelee = false;\n  this.isHittingMelee = false;\n  this.meleeWorld = null; // Loading bow\n\n  this.isLoadingBow = false;\n  this.needsStartLoadingBow = false;\n  this.needsStopLoadingBow = false; // Interpolation-prediction\n\n  this.lastPositionFromServer = new three_module["Sb" /* Vector3 */](0, 0, 0);\n  this.currentPositionFromServer = new three_module["Sb" /* Vector3 */](0, 0, 0);\n  this.interpolatingPosition = new three_module["Sb" /* Vector3 */](0, 0, 0);\n  this.lastRotationFromServer = new three_module["Tb" /* Vector4 */](0, 0, 0, 0);\n  this.currentRotationFromServer = new three_module["Tb" /* Vector4 */](0, 0, 0, 0);\n  this.interpolatingRotation = new three_module["Tb" /* Vector4 */](0, 0, 0, 0);\n  this.lastServerUpdateTime = this.getTime();\n  this.averageDeltaT = -1;\n  this.interpolationUpToDate = false;\n  this.needsWorldSwitchRetry = false; // this.lastInterpolatingPosition = new Vector3(0, 0, 0);\n  // this.maxDelta = 500; // ms\n  // this.predictedVelocity = new Vector3(0, 0, 0);\n  // this.lastClientUpdateTime = this.getTime();\n};\n\nextend(self_SelfModel.prototype, {\n  init: function init() {\n    this.loadSelf();\n  },\n  // Called every client frame.\n  refresh: function refresh() {\n    if (!this.needsUpdate) {\n      if (!this.interpolationUpToDate) this.interpolatePredictSelfPosition();\n      if (this.isHittingMelee) this.updateMelee();\n      this.updateBow();\n      return;\n    }\n\n    var avatar = this.avatar; // let r = this.rotation;\n\n    if (!avatar) return; // This could be made more fluid with\n    // a more involved interpolation routine\n    // (might need more data from the server)\n    // if (this.worldNeedsUpdate && this.oldWorldId)\n    // {\n    //     this.updateWorld();\n    //     let p = this.position;\n    //     let last = this.lastPositionFromServer;\n    //     let current = this.currentPositionFromServer;\n    //     last.copy(current);\n    //     current.copy(p);\n    //     this.interpolatingPosition.copy(p);\n    //     this.updatePosition(this.avatar, this.interpolatingPosition);\n    //     this.interpolationUpToDate = true;\n    // } else\n\n    if (!this.interpolationUpToDate) {\n      this.interpolatePredictSelfPosition();\n    } // if (r !== null) {\n    //     this.updateRotation(avatar, r);\n    // }\n\n\n    if (this.needsStartMelee) {\n      this.needsStartMelee = false;\n      this.initMelee();\n    }\n\n    if (this.isHittingMelee) {\n      this.updateMelee();\n    }\n\n    this.updateBow();\n    this.needsUpdate = false;\n  },\n  // Called every time a server update was received.\n  updateSelf: function updateSelf(p, r, w, s) {\n    w = w.toString();\n    var pos = this.position;\n    var rot = this.rotation;\n    var wid = this.worldId;\n\n    if (!pos || !rot || pos[0] !== p[0] || pos[1] !== p[1] || pos[2] !== p[2] || rot[0] !== r[0] || rot[1] !== r[1]) {\n      this.position.set(p[0], p[1], p[2]);\n      this.rotation = r;\n      this.needsUpdate = true;\n      this.interpolationUpToDate = false;\n    }\n\n    if (!wid || wid !== w) {\n      this.needsUpdate = true;\n      this.worldNeedsUpdate = true;\n      this.oldWorldId = this.worldId;\n      this.newWorldId = w; // this.worldId = w;\n    }\n\n    if (s) {\n      var hasJustMeleed = s[1];\n\n      if (hasJustMeleed) {\n        this.needsStartMelee = true;\n      }\n\n      var loadingBow = !!s[2];\n\n      if (loadingBow !== this.isLoadingBow) {\n        this.isLoadingBow = loadingBow;\n\n        if (this.isLoadingBow) {\n          this.needsStartLoadingBow = true;\n          this.needsStopLoadingBow = false;\n        } else {\n          this.needsStopLoadingBow = true;\n          this.needsStartLoadingBow = false;\n        }\n      }\n    }\n  },\n  cameraMoved: function cameraMoved(cameraObject) {\n    var handItem = this.handItem;\n    if (!handItem) return;\n    handItem.rotation.x = cameraObject.pitch.rotation.x;\n    handItem.rotation.z = cameraObject.yaw.rotation.z;\n    var handItemWrapper = this.handItemWrapper;\n    handItemWrapper.rotation.copy(cameraObject.up.rotation); // handItem.children[0].rotation.x += 0.01;\n  },\n  getSelfPosition: function getSelfPosition() {\n    return this.position;\n  },\n  getHeadPosition: function getHeadPosition() {\n    var head = this.avatar.getHead();\n    if (!head) return null;\n    return head.position;\n  },\n  getInventory: function getInventory() {\n    return this.inventoryModel;\n  },\n  getTime: function getTime() {\n    return window.performance.now();\n  },\n  cleanup: function cleanup() {\n    // General\n    this.entityId = \'-1\';\n    this.worldId = \'-1\';\n    this.oldWorldId = null; // Model component.\n\n    this.position = new three_module["Sb" /* Vector3 */](0, 0, 0);\n    this.rotation = [0, 0, 0, 0];\n    this.inventoryModel.reset(); // Graphical component.\n\n    this.worldNeedsUpdate = false;\n    this.needsUpdate = false;\n    this.displayAvatar = false;\n    this.displayHandItem = true;\n    this.avatar = null;\n    this.lastServerUpdateTime = this.getTime();\n    this.averageDeltaT = -1; // XXX [CLEANUP] avatar graphical component.\n  }\n});\nextend(self_SelfModel.prototype, SelfInterpolationModule);\nextend(self_SelfModel.prototype, SelfUpdateModule);\nextend(self_SelfModel.prototype, SelfObjectsModule);\n\n// CONCATENATED MODULE: ./client/app/model/server/x/tree.js\n/**\n *\n */\n\n\n\nvar XNode;\nvar XArc;\nvar XGraph;\n\nXNode = function XNode(nodeId, parentArc) {\n  this.nodeId = nodeId;\n\n  if (parentArc) {\n    this.parentArcs = [parentArc];\n  } else {\n    this.parentArcs = [];\n  }\n\n  this.childrenArcs = [];\n};\n\nextend(XNode.prototype, {\n  getNodeId: function getNodeId() {\n    return this.nodeId;\n  },\n  getNumberOfChildren: function getNumberOfChildren() {\n    return this.childrenArcs.length;\n  },\n  addExistingChild: function addExistingChild(arcId, node, xgraph) {\n    var arc = new XArc(this, node, arcId);\n    xgraph.setArc(arcId, this);\n    node.parentArcs.push(arc);\n    this.childrenArcs.push(arc);\n    return node;\n  },\n  addNewChild: function addNewChild(arcId, nodeId, xgraph) {\n    var node = new XNode(nodeId);\n    var arc = new XArc(this, node, arcId);\n    xgraph.setArc(arcId, arc);\n    node.parentArcs.push(arc);\n    this.childrenArcs.push(arc);\n    return node;\n  },\n  getParentArcs: function getParentArcs() {\n    if (this.parentArcs === null) throw Error(\'Root has no parent.\');\n    return this.parentArcs;\n  },\n  getChildrenArcs: function getChildrenArcs() {\n    return this.childrenArcs;\n  },\n  forEachChild: function forEachChild(callback) {\n    this.childrenArcs.forEach(function (arc) {\n      callback(arc);\n    });\n  }\n});\n\nXArc = function XArc(parentNode, childNode, arcId) {\n  this.arcId = arcId;\n  this.parentNode = parentNode;\n  this.childNode = childNode;\n};\n\nextend(XArc.prototype, {\n  getChild: function getChild() {\n    return this.childNode;\n  },\n  getParent: function getParent() {\n    return this.parentNode;\n  },\n  getArcId: function getArcId() {\n    return this.arcId;\n  }\n});\n\nXGraph = function XGraph(rootId) {\n  this.root = new XNode(rootId, null);\n  this.nodes = new Map();\n  this.arcs = new Map();\n  this.nodes.set(rootId, this.root); // Flat version going from root, linked to rendering graph strategy.\n\n  this.flatGraph = [];\n}; // Node are used for worlds,\n// Arcs for portals.\n\n\nextend(XGraph.prototype, {\n  setArc: function setArc(arcId, arc) {\n    if (this.arcs.has(arcId)) console.log(\'XGraph: adding an existing arc to the graph.\');\n    this.arcs.set(arcId, arc);\n  },\n  insertNode: function insertNode(newArcId, forwardArcId, newNodeId, parentNodeId) {\n    newArcId = "".concat(newArcId, ",").concat(forwardArcId);\n    var node = this.nodes.get(parentNodeId);\n\n    if (!node) {\n      node = new XNode(parentNodeId, null);\n      this.nodes.set(parentNodeId, node);\n    }\n\n    var newNode = this.nodes.get(newNodeId);\n\n    if (newNode) {\n      // N.B. graph passed to add arc to model\n      node.addExistingChild(newArcId, newNode, this);\n    } else {\n      newNode = node.addNewChild(newArcId, newNodeId, this);\n      this.nodes.set(newNodeId, newNode);\n    }\n\n    return newNode;\n  },\n  hasNode: function hasNode(nodeId) {\n    return this.nodes.has(nodeId);\n  },\n  getNode: function getNode(nodeId) {\n    return this.nodes.get(nodeId);\n  },\n  switchRoot: function switchRoot(oldRootId, newRootId) {\n    // Allow only 1-length switch at a time.\n    var oldRoot = this.root;\n\n    if (oldRoot.getNodeId() !== oldRootId) {\n      console.log(\'XGraph Error: trying to switch from invalid root.\');\n      return;\n    }\n\n    var children = oldRoot.getChildrenArcs();\n    if (!children) return; // No other world.\n\n    var currentArc;\n    var currentNode;\n    var currentNodeId;\n\n    for (var cid = 0, nbc = children.length; cid < nbc; ++cid) {\n      currentArc = children[cid];\n      currentNode = currentArc.getChild();\n      if (!currentNode) continue;\n      currentNodeId = currentNode.getNodeId();\n\n      if (currentNodeId === newRootId) {\n        // Do switch root with corresponding node.\n        this.root = currentNode;\n        break;\n      }\n    }\n  },\n  // Given an arc (portal), breadth-first apply a function\n  // that go from it (or the root) to the leaves or to a specified arc id.\n  // Generic BFS.\n  applyFromPosition: function applyFromPosition(starterArcId, deepestArcId, callback) {\n    var starterNode = this.root;\n\n    if (starterArcId) {\n      var starterArc = this.arcs.get(starterArcId);\n\n      if (!starterArc) {\n        console.log(\'Error at XGraph: starter arc not found.\');\n        return;\n      }\n\n      starterNode = starterArc.getChild();\n    }\n\n    var arcMarkers = new Set();\n    var nodeMarkers = new Map();\n    nodeMarkers.set(starterNode.getNodeId(), 0); // node id, depth\n\n    var stack = [];\n    var paths = []; // Arc paths. Nodes are easily deduced.\n\n    var depths = [];\n    var starterArcs = starterNode.childrenArcs;\n\n    if (!starterArcs) {\n      console.log(\'XGraph: no arc found.\');\n      return;\n    }\n\n    starterArcs.forEach(function (arc) {\n      stack.push(arc);\n      paths.push("".concat(arc.getArcId()));\n      depths.push(1);\n    });\n    var maxDepth = Number.POSITIVE_INFINITY;\n    var head;\n    var depth;\n    var path;\n\n    while (stack.length > 0) {\n      // Get current element.\n      head = stack.pop();\n      path = paths.pop();\n      depth = depths.pop();\n      var currentId = head.getArcId();\n      arcMarkers.add(currentId);\n\n      if (currentId === deepestArcId) {\n        maxDepth = depth;\n      }\n\n      var childNode = head.getChild();\n      if (childNode && nodeMarkers.get(childNode.getNodeId()) < depth) continue; // Do callback.\n\n      callback(head, path, depth); // Prepare next elements.\n\n      var newDepth = depth + 1;\n      if (newDepth > maxDepth) continue; // No other arc to process?\n\n      if (!childNode) continue; // Node was already processed?\n\n      var testNodeId = childNode.getNodeId();\n      var testRecursedNode = nodeMarkers.get(testNodeId);\n\n      if (testRecursedNode < newDepth) {\n        // Here, node was already encountered,\n        // so it is marked to avoid 1-step recursion.\n        continue;\n      }\n\n      nodeMarkers.set(testNodeId, newDepth);\n      var childrenArcs = childNode.getChildrenArcs();\n\n      for (var i = 0, l = childrenArcs.length; i < l; ++i) {\n        var arc = childrenArcs[i];\n        var addedArcId = arc.getArcId();\n\n        if (!arcMarkers.has(addedArcId)) {\n          stack.push(arc);\n          depths.push(newDepth);\n          paths.push("".concat(path, ",").concat(addedArcId));\n        }\n      }\n    }\n  },\n  toString: function toString() {\n    var string = \'\';\n    var flatGraph = this.flatGraph;\n    var currentStep;\n\n    for (var i = 0, l = flatGraph.length; i < l; ++i) {\n      currentStep = flatGraph[i]; // 0: depth\n      // 1: type\n      //      green: regular arc\n      //      yellow: 0-order involution\n      //      cyan: 1st order involution (the same pid as previously leads to the previous wid)\n      //      orange: denote an independent cycle\n      //      red: denote a dependant cycle (higher order involution)\n      // 2: pid\n      // 3: wid origin\n      // 4: wid destination\n\n      var dep = currentStep.depth;\n      var mod = currentStep.type;\n      var por = currentStep.pid;\n      var ori = currentStep.origin;\n      var ele = currentStep.destination;\n      var pat = currentStep.path;\n      var wpt = currentStep.wpath;\n\n      for (var j = 0, d = dep; j < d; ++j) {\n        string += "\\xA0\\xA0\\xA0";\n      }\n\n      string += "".concat(mod, " w.").concat(ori, " w.{").concat(ele, "} p.").concat(por, " // ").concat(pat, "|").concat(wpt);\n      string += \'\\n\';\n    }\n\n    return string;\n  },\n  computeCameraTransform: function computeCameraTransform(pidPath, portals) //, cameraManager\n  {\n    // let root = cameraManager.mainCamera;\n    var cameraTransform = [0, 0, 0, // Position\n    0, 0, 0 // Rotation\n    ]; // console.log(\'CAMERA TRANSFORMATION\');\n    // console.log(pidPath.length);\n\n    for (var pathId = 0, pathLength = pidPath.length; pathId < pathLength; ++pathId) {\n      var currentTunnel = pidPath[pathId].split(\',\');\n      var sourcePortalId = parseInt(currentTunnel[0], 10);\n      var sourcePortal = portals.get(sourcePortalId);\n      var destinationPortalId = parseInt(currentTunnel[1], 10);\n      var destinationPortal = portals.get(destinationPortalId); // console.log(sourcePortal);\n      // console.log(destinationPortal);\n\n      if (!destinationPortal || !sourcePortal) continue;\n      var P0B0 = sourcePortal.tempPosition;\n      var P0B1 = sourcePortal.tempOtherPosition;\n      var P1B0 = destinationPortal.tempPosition;\n      var P1B1 = destinationPortal.tempOtherPosition;\n      var isX0 = P0B0[0] !== P0B1[0];\n      var isX1 = P1B0[0] !== P1B1[0];\n      var isY0 = P0B0[1] !== P0B1[1];\n      var isY1 = P1B0[1] !== P1B1[1];\n      var isZ0 = P0B0[2] !== P0B1[2];\n      var isZ1 = P1B0[2] !== P1B1[2];\n\n      if (isX0 + isY0 + isZ0 !== 1 || isX1 + isY1 + isZ1 !== 1) {\n        console.warn(\'[Tree/CameraTransform]: unmanaged portal type.\');\n        return;\n      }\n\n      var p0x = 0;\n      var p0y = 0;\n      var p0z = 0;\n      var p1x = 0;\n      var p1y = 0;\n      var p1z = 0;\n\n      switch (true) {\n        case isX0:\n          p0x = 0.5 * (P0B0[0] + P0B1[0]);\n          p0y = 0.5 + P0B0[1];\n          p0z = 0.5 + P0B1[2];\n          break;\n\n        case isY0:\n          p0y = 0.5 * (P0B0[1] + P0B1[1]);\n          p0x = 0.5 + P0B0[0];\n          p0z = 0.5 + P0B1[2];\n          break;\n\n        case isZ0:\n          p0z = 0.5 * (P0B0[2] + P0B1[2]);\n          p0y = 0.5 + P0B0[1];\n          p0x = 0.5 + P0B1[0];\n          break;\n      }\n\n      switch (true) {\n        case isX1:\n          p1x = 0.5 * (P1B0[0] + P1B1[0]);\n          p1y = 0.5 + P1B0[1];\n          p1z = 0.5 + P1B1[2];\n          break;\n\n        case isY1:\n          p1y = 0.5 * (P1B0[1] + P1B1[1]);\n          p1x = 0.5 + P1B0[0];\n          p1z = 0.5 + P1B1[2];\n          break;\n\n        case isZ1:\n          p1z = 0.5 * (P1B0[2] + P1B1[2]);\n          p1y = 0.5 + P1B0[1];\n          p1x = 0.5 + P1B1[0];\n          break;\n      }\n\n      if (p0x !== p1x || p0y !== p1y || p0z !== p1z) {// console.warn(\'[Tree/CameraTransform]: // TODO Compute camera chain transform.\');\n      }\n\n      var thetaP0 = sourcePortal.tempOrientation;\n      var thetaP1 = destinationPortal.tempOrientation; // let portalRelativeOrientation = [o1[0] - p0[0], p1[1] - p0[1], p1[2] - p0[2]];\n\n      cameraTransform[0] += p1x - p0x;\n      cameraTransform[1] += p1y - p0y;\n      cameraTransform[2] += p1z - p0z;\n      cameraTransform[3] += thetaP1 - thetaP0; // console.log(destinationPortalId);\n      // console.log(destinationPortal.tempPosition);\n      // console.log(destinationPortal.tempOrientation);\n      // compose everything but NOT THE MAIN CAMERA!\n    } // console.log(\'Computed Camera Transform.\');\n    // console.log(cameraTransform);\n\n\n    return cameraTransform;\n  },\n  // Add cameras and everything and so on.\n  computeRenderingGraph: function computeRenderingGraph(graphicsEngine, xModel) {\n    var flatGraph = this.flatGraph;\n    if (flatGraph.length < 1) return;\n    graphicsEngine.flushPortalUpdates();\n    var cameraManager = graphicsEngine.cameraManager; // let worldToPortals = xModel.worldToPortals;\n\n    var portals = xModel.portals; // Fixed by xModel\n\n    var currentStep;\n    var destinationWid;\n    var originPid;\n    var destinationPid; // let originWid; let widPath;\n\n    var pidPathString;\n    var pidPath;\n    var depth;\n    var cameraTransform;\n\n    for (var i = 0, l = flatGraph.length; i < l; ++i) {\n      currentStep = flatGraph[i]; // originWid       = currentStep.origin;\n\n      destinationWid = currentStep.destination;\n      originPid = parseInt(currentStep.pid.split(\',\')[0], 10);\n      destinationPid = parseInt(currentStep.pid.split(\',\')[1], 10);\n      pidPathString = currentStep.path;\n      pidPath = pidPathString.split(\';\'); // widPath         = currentStep.wpath.split(\';\');\n\n      depth = currentStep.depth; // console.log(currentStep.type);\n\n      var p1 = void 0;\n      var p2 = void 0;\n\n      switch (currentStep.type) {\n        case \'lime\':\n          // Regular.\n          // Add screen.\n          // Add camera.\n          // Add path to camera.\n          p1 = portals.get(originPid);\n          p2 = portals.get(destinationPid);\n\n          if (!p1 || !p2) {\n            console.log("Problem while adding portal ".concat(originPid) + " / ".concat(destinationPid));\n            console.log("Origin: ".concat(p1, ", Destination ").concat(p2));\n            continue;\n          }\n\n          cameraTransform = this.computeCameraTransform(pidPath, portals, cameraManager);\n          graphicsEngine.addPortalObject(p1, p2, pidPathString, cameraTransform, depth, originPid, destinationPid, destinationWid, pidPathString);\n          break;\n\n        case \'orange\':\n          // Add screen.\n          // Add camera to all descendants.\n          break;\n\n        case \'yellow\':\n          // Add screen.\n          // Add camera to descendants, after?\n          p1 = portals.get(originPid);\n          p2 = portals.get(destinationPid);\n\n          if (!p1 || !p2) {\n            console.log("Problem while adding portal ".concat(originPid) + " / ".concat(destinationPid));\n            console.log("Origin: ".concat(p1, ", Destination ").concat(p2));\n            continue;\n          }\n\n          console.log(pidPath);\n          var pidPathLength = pidPath.length;\n\n          if (pidPathLength < 1) {\n            console.error(\'[X/Tree] Expected a longer camera path.\');\n            return;\n          }\n\n          cameraTransform = this.computeCameraTransform(pidPath, portals, cameraManager); // console.log(cameraTransform);\n          // console.log(pidPathString);\n          // console.log(`pushing ${p1.portalId}`);\n\n          graphicsEngine.addPortalObject(p1, p2, pidPathString, cameraTransform, depth, originPid, destinationPid, destinationWid, pidPathString); // console.log(`pushing ${p2.portalId}`);\n\n          var pidPath2 = pidPath.slice(); // copy pid path 2\n\n          var commaSeparatedLink = pidPath[pidPathLength - 1];\n          var ids = commaSeparatedLink.split(\',\');\n          var newIds = "".concat(ids[1], ",").concat(ids[0]);\n          pidPath2[pidPathLength - 1] = newIds;\n          var pidPathString2 = pidPath2.join(\';\');\n          cameraTransform = this.computeCameraTransform(pidPath2, portals, cameraManager); // console.log(cameraTransform);\n\n          graphicsEngine.addPortalObject(p2, p1, pidPathString2, cameraTransform, depth, destinationPid, originPid, destinationWid, pidPathString2);\n          break;\n\n        case \'cyan\':\n          // It rewires backwards.\n          // Do only when current camera isn\'t right camera\n          break;\n\n        case \'red\':\n          // Do nothing. Incorrect orientation of deeper\n          // cameras, however, should not be noticeable.\n          // Worst case: recurse on them.\n          break;\n\n        default:\n      }\n    } // Optimisation: remove only screens that differ from last pass.\n    // Add remaining ones asynchronously.\n\n\n    graphicsEngine.unflushPortalUpdates();\n  },\n  // Compute a graph representation, starting from the root. Custom BFS.\n  computeFlatGraph: function computeFlatGraph() {\n    var flatGraph = [];\n    var currentStep;\n    var currentElement;\n    var currentElementId;\n    var currentArc;\n    var currentArcId;\n    var currentOtherEnd;\n    var currentPidPath;\n    var currentWidPath;\n    var marks = new Set(); // Verification.\n\n    var markedPaths = new Set();\n    var queueNodes = [this.root];\n    var queueOtherEnds = [null];\n    var currentDepth = 0;\n    var queueWidPaths = [\'\'];\n    var queuePidPaths = [\'\'];\n    var queueDepth = [currentDepth];\n    var queueArcs = [null];\n    var elementDepths = new Map();\n    var elementPaths = new Map();\n    var elementProcessed = false; // DFS.\n\n    while (queueNodes.length > 0) {\n      currentElement = queueNodes.pop();\n      currentDepth = queueDepth.pop();\n      currentArc = queueArcs.pop();\n      currentPidPath = queuePidPaths.pop();\n      currentWidPath = queueWidPaths.pop();\n      currentOtherEnd = queueOtherEnds.pop();\n      currentElementId = currentElement.getNodeId();\n      elementProcessed = marks.has(currentElementId); //\n\n      var b = currentPidPath.split(\';\');\n      var c = b.pop().split(\',\').reverse();\n      b.pop();\n      b.push(c);\n      var directInvolutionPath = b.join(\';\'); //\n\n      var e = currentPidPath.split(\';\');\n      e.pop();\n      e.join(\';\');\n      var widArray = currentWidPath.split(\';\');\n\n      if (currentArc) {\n        currentArcId = currentArc.getArcId();\n        currentStep = {}; // Detect direct 0-involutions\n\n        if (elementProcessed && currentOtherEnd && currentOtherEnd.getNodeId() === currentElementId) {\n          // Check element swap with next one.\n          // if (currentDepth)\n          currentStep.type = \'yellow\';\n        } else if (elementProcessed && markedPaths.has(directInvolutionPath)) {\n          // Detect direct 1-involutions.\n          currentStep.type = \'cyan\';\n        } // Dependent cycle (full path is common)\n        else if (elementProcessed && widArray.indexOf(currentElementId) > -1) {\n            currentStep.type = \'red\';\n          } // Independent cycle (path is partly common)\n          // It was detected because the current world is marked as processed.\n          else if (elementProcessed) {\n              currentStep.type = \'orange\';\n            } // Regular path (at first pass, other derived may be considered degenerate).\n            else if (!elementProcessed) {\n                currentStep.type = \'lime\';\n              }\n\n        currentStep.depth = currentDepth; //if (currentOtherEnd)\n        // XXX [PORTAL] check. I guess an arc has always a parent and a child.\n\n        currentStep.origin = currentOtherEnd.getNodeId();\n        currentStep.destination = currentElementId;\n        currentStep.pid = currentArcId;\n        currentStep.path = currentPidPath; // Without the last pid.\n\n        currentStep.wpath = currentWidPath; // Without the last wid.\n\n        flatGraph.push(currentStep);\n      }\n\n      if (!elementProcessed) {\n        // Mark and go next.\n        if (!elementDepths.has(currentElementId) || currentDepth < elementDepths.get(currentElementId)) {\n          elementPaths.set(currentElementId, currentPidPath);\n          elementDepths.set(currentElementId, currentDepth);\n        }\n\n        marks.add(currentElementId);\n        markedPaths.add(currentPidPath);\n        var nextDepth = currentDepth + 1;\n        var childrenArcs = currentElement.getChildrenArcs();\n\n        for (var i = 0, l = childrenArcs.length; i < l; ++i) {\n          var arc = childrenArcs[i];\n          queueArcs.push(arc);\n          queueNodes.push(arc.getChild());\n          var sep = \'\';\n          if (currentPidPath.length > 0 && arc.getArcId()) sep = \';\';\n          queuePidPaths.push(currentPidPath + sep + arc.getArcId());\n          if (currentWidPath.length > 0 && currentElementId.length > 0) sep = \';\';\n          queueWidPaths.push(currentWidPath + sep + currentElementId);\n          queueDepth.push(nextDepth);\n          queueOtherEnds.push(arc.getParent());\n        }\n      }\n    }\n\n    this.flatGraph = flatGraph;\n    return this.flatGraph;\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/model/server/x/worldmap.js\n/**\n * Render target hierarchy management helper.\n */\n\n/*\n * Does not display stubs.\n *\n *  w0\n *   w1        | p1 -> p1\'\n *      w3   | p3 -> p3\'\n *      w4   | p4 -> p4\'\n *      w5   | p5 -> p5\'\n *   w2        | p2 -> p2\'\n *       w5    | p5 -> p5\'\n *       w6    | p6 -> p6\'\n *       w0    | p7 -> p7\'\n *\n * red: rewired backwards\n * cyan: contains direct circle\n * orange: duplicated\n * green: linear\n *\n */\n\n\n\n\nvar worldmap_WorldMap = function WorldMap(xModel) {\n  this.xModel = xModel;\n  this.xGraph = null;\n  this.string = \'\';\n  this.needsUpdate = true;\n};\n\nextend(worldmap_WorldMap.prototype, {\n  switchRoot: function switchRoot(oldRootId, newRootId) {\n    this.xGraph.switchRoot(oldRootId, newRootId);\n    this.invalidate();\n  },\n  computeWorldMap: function computeWorldMap() {\n    var portals = this.xModel.portals;\n    var starterWorldId = this.xModel.selfModel.worldId;\n    var xGraph = new XGraph(parseInt(starterWorldId, 10));\n    var forwardPortalId;\n    var forwardPortal;\n    var forwardWorldId;\n    var currentWorldId;\n    portals.forEach(function (portal, portalId) {\n      currentWorldId = portal.worldId;\n      forwardPortalId = portal.portalLinkedForward;\n      if (!forwardPortalId) return;\n      forwardPortal = portals.get(forwardPortalId);\n      if (!forwardPortal) return;\n      forwardWorldId = forwardPortal.worldId;\n      xGraph.insertNode(parseInt(portalId, 10), parseInt(forwardPortalId, 10), parseInt(forwardWorldId, 10), parseInt(currentWorldId, 10));\n    });\n    this.xGraph = xGraph;\n    return this;\n  },\n  computeFlatGraph: function computeFlatGraph() {\n    return this.xGraph.computeFlatGraph();\n  },\n  computeRenderingGraph: function computeRenderingGraph(graphicsEngine) {\n    return this.xGraph.computeRenderingGraph(graphicsEngine, this.xModel);\n  },\n  invalidate: function invalidate() {\n    this.needsUpdate = true;\n    return this;\n  },\n  // Representation\n  renderString: function renderString() {\n    this.computeWorldMap();\n    this.xGraph.computeFlatGraph();\n    this.string = this.xGraph.toString();\n    this.needsUpdate = false;\n    return this.string;\n  },\n  toString: function toString() {\n    if (this.needsUpdate) this.renderString();\n    return this.string;\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/model/server/x/portal.js\n/**\n *\n */\n\n\n\n\nvar Portal = function Portal(portalId, otherPortalId, chunkId, worldId, end1, end2, offset, orientation) {\n  this.portalId = portalId;\n  this.portalLinkedForward = otherPortalId;\n  this.chunkId = chunkId;\n  this.worldId = worldId;\n  var x0 = end1[0];\n  var x1 = end2[0];\n  var y0 = end1[1];\n  var y1 = end2[1];\n  var z0 = end1[2];\n  var z1 = end2[2];\n\n  if (offset) {\n    this.tempOffset = offset >= 0.001 && offset <= 0.999 ? offset : 0.999;\n  }\n\n  this.tempOrientation = orientation;\n  this.tempPosition = [x0, y0, z0];\n  this.tempOtherPosition = [x1, y1, z1];\n  this.tempWidth = 1;\n  this.tempHeight = 2;\n};\n\nextend(Portal.prototype, {//getP: function() {\n  //    return\n  //}\n});\n\n// CONCATENATED MODULE: ./client/app/model/server/x/update.js\n/**\n *\n */\n\n\n\nvar UpdateModule = {\n  addPortal: function addPortal(portalId, otherPortalId, chunkId, worldId, end1, end2, offset, orientation) {\n    console.log("Adding portal ".concat(portalId, " and linking to ").concat(otherPortalId));\n    portalId = parseInt(portalId, 10); // Build portal model.\n\n    if (this.portals.has(portalId)) {\n      console.log("Portal ".concat(portalId, " was here already..."));\n    }\n\n    var portal = new Portal(portalId, otherPortalId, chunkId, worldId, end1, end2, offset, orientation); // Add portal to model.\n\n    this.portals.set(portalId, portal); // Add to world-portal model.\n\n    var worldPortals = this.worldToPortals.get(worldId);\n    if (worldPortals) worldPortals.add(portalId);else {\n      worldPortals = new Set();\n      worldPortals.add(portalId);\n      this.worldToPortals.set(worldId, worldPortals);\n    }\n  },\n  removePortal: function removePortal(portalId) {\n    portalId = parseInt(portalId, 10);\n    var modelPortals = this.portals;\n    var worldToPortals = this.worldToPortals; // console.log(`Removing portal ${portalId}  ${typeof portalId}`);\n\n    var portal = modelPortals.get(portalId);\n\n    if (!portal) {\n      console.log("\\t... portal ".concat(portalId, " not present in model."));\n    } // Impact model.\n\n\n    modelPortals["delete"](portalId); // Impact world-portal model.\n\n    if (portal) {\n      var worldId = portal.worldId;\n      var worldPortals = worldToPortals.get(worldId);\n      worldPortals["delete"](portalId);\n      if (worldPortals.size < 1) worldToPortals["delete"](worldId);\n    }\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/model/server/x/x.js\n/**\n *\n */\n\n\n\n\n\n\nvar x_XModel = function XModel(app, selfModel) {\n  this.app = app;\n  this.selfModel = selfModel;\n  /** Model component **/\n  // Portal id -> portal (knows self world, forward portal)\n\n  this.portals = new Map(); // World id -> set of all portals contained in this world\n\n  this.worldToPortals = new Map(); // Map helper\n\n  this.worldMap = new worldmap_WorldMap(this);\n  /** Buffer **/\n\n  this.xUpdates = [];\n  /** Graphical component **/\n\n  this.needsUpdate = false;\n  this.forceUpdate = false;\n};\n\nextend(x_XModel.prototype, {\n  init: function init() {},\n  // Should always be called AFTER worldModel.refresh()\n  // So there is no more world to be added, all possible worlds\n  // are available for display in their portals texture renderer.\n  refresh: function refresh() {\n    if (!this.needsUpdate && !this.forceUpdate) return;\n    var register = this.app.register;\n    var worldMap = this.worldMap;\n    var updates = this.xUpdates;\n    var refreshWorldMap = false;\n    var graphics = this.app.engine.graphics;\n\n    for (var i = 0, l = updates.length; i < l; ++i) {\n      var data = updates[i];\n\n      for (var portalId in data) {\n        if (!data.hasOwnProperty(portalId)) continue;\n        var meta = data[portalId];\n        var isArray = meta instanceof Array;\n\n        if (isArray && meta.length > 0) {\n          // Full portal.\n          var otherPortalId = meta[0];\n          var chunkId = meta[1];\n          var worldId = meta[2];\n          var end1 = [meta[3], meta[4], meta[5]];\n          var end2 = [meta[6], meta[7], meta[8]];\n          var offset = meta[9];\n          var orientation = meta[10]; // Do add portal (not that world map is recomputed in process)\n\n          this.addPortal(portalId, otherPortalId, chunkId, worldId, end1, end2, offset, orientation);\n          refreshWorldMap = true;\n        } else {\n          // Null -> remove portal\n          this.removePortal(portalId);\n          refreshWorldMap = true;\n        }\n      }\n    }\n\n    if (refreshWorldMap || this.forceUpdate) {\n      // console.log(\'[X] Updating world graph render force.\');\n      var s = worldMap.invalidate().computeWorldMap().computeFlatGraph(); // Alternatively, use worldMap.toString();\n\n      register.updateSelfState({\n        diagram: s\n      }); // Possible perf improvements here.\n\n      worldMap.computeRenderingGraph(graphics);\n      this.forceUpdate = false;\n    }\n\n    this.xUpdates = [];\n    this.needsUpdate = false;\n  },\n\n  /** API\n   *  [11] -> new linked portal\n   0:448165    -> other portal id (null -> blank portal)\n   1:"0,0,0"   -> current side\'s chunk id (could change: f.x. in the same world)\n   2:645486    -> current side\'s world id\n   3:2         -> b1.x (absolutes)\n   4:8         -> b1.y |\n   5:17        -> b1.z |\n   6:2         -> b2.x |\n   7:8         -> b2.y |\n   8:18        -> b2.z |==> determination of which axis portal is orthogonal to\n   9:0.999     -> position (/rel + axix)\n   10:"both"   -> orientation ("+", "-" or "both")\n   * null -> removed portal\n   **/\n  updateX: function updateX(data) {\n    this.xUpdates.push(data);\n    this.needsUpdate = true;\n  },\n  switchAvatarToWorld: function switchAvatarToWorld(oldWorldId, newWorldId) {\n    console.log(\'[X] Switching avatar to other world\');\n    oldWorldId = parseInt(oldWorldId, 10);\n    newWorldId = parseInt(newWorldId, 10);\n    this.worldMap.switchRoot(oldWorldId, newWorldId); //this.forceUpdate = true;\n  },\n  cleanup: function cleanup() {\n    this.portals.clear();\n    this.worldToPortals.clear();\n    this.worldMap = new worldmap_WorldMap(this);\n    this.xUpdates = [];\n    this.needsUpdate = false;\n    this.forceUpdate = false; // XXX [CLEANUP] graphical component, scenes and render targets\n  }\n});\nextend(x_XModel.prototype, UpdateModule);\n\n// CONCATENATED MODULE: ./client/app/model/server/updates.js\n/**\n *\n */\n\n\nvar updates_UpdateModule = {\n  updateMe: function updateMe(data) {\n    if (!this.isRunning) return;\n    data = JSON.parse(data);\n    var mainState = data[0];\n    this.selfModel.updateSelf(mainState[0], mainState[1], mainState[2], mainState[3]);\n  },\n  updateEntities: function updateEntities(data) {\n    if (!this.isRunning) return;\n    data = JSON.parse(data);\n    this.entityModel.updateEntities(data);\n  },\n  updateChunks: function updateChunks(data) {\n    if (!this.isRunning) return;\n    data = JSON.parse(data);\n    this.chunkModel.updateChunks(data);\n  },\n  updateX: function updateX(data) {\n    if (!this.isRunning) return;\n    data = JSON.parse(data);\n    this.xModel.updateX(data);\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/model/server/server.js\n/**\n * Contains game-specific data structures.\n */\n\n\n\n\n\n\n\n\n\nvar server_Server = function Server(app) {\n  this.app = app;\n  this.selfModel = new self_SelfModel(app);\n  this.chunkModel = new ChunkModel(app);\n  this.entityModel = new entities_EntityModel(app);\n  this.xModel = new x_XModel(app, this.selfModel);\n  this.selfModel.xModel = this.xModel;\n  this.isRunning = false;\n  this.isDirty = false;\n};\n\nextend(server_Server.prototype, updates_UpdateModule);\nextend(server_Server.prototype, {\n  init: function init() {\n    this.isRunning = true;\n    this.selfModel.init();\n    this.chunkModel.init();\n    this.entityModel.init();\n    this.xModel.init();\n  },\n  stop: function stop() {\n    this.isRunning = false;\n  },\n  // Update graphics.\n  refresh: function refresh() {\n    this.selfModel.refresh();\n    this.chunkModel.refresh();\n    this.entityModel.refresh();\n    this.xModel.refresh();\n  },\n  getSelfModel: function getSelfModel() {\n    return this.selfModel;\n  },\n  cleanupFullModel: function cleanupFullModel() {\n    this.selfModel.cleanup();\n    this.chunkModel.cleanup();\n    this.entityModel.cleanup();\n    this.xModel.cleanup();\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/model/client/self/self.js\n/**\n *\n */\n\n\n\n\n\nvar self_SelfComponent = function SelfComponent(clientModel) {\n  this.clientModel = clientModel; // Camera.\n\n  this._cameraInteraction = \'first-person\';\n  this.cameraInteraction = {\n    /**\n     * @deprecated\n     */\n    isFirstPerson: function () {\n      return this._cameraInteraction === \'first-person\';\n    }.bind(this),\n\n    /**\n     * @deprecated\n     */\n    isThirdPerson: function () {\n      return this._cameraInteraction === \'third-person\';\n    }.bind(this)\n  }; // Inventory.\n\n  this.currentItemSlot = 0; // Index of current item in inventory.\n\n  this.angleFromIntersectionPoint = 0; // For portal placement.\n\n  var emptyItem = ItemType.NONE;\n  this.quickBarSize = 8;\n  this.defaultQuickBar = [// Default demo items\n  ItemType.BLOCK_PLANKS, ItemType.KATANA, ItemType.YUMI, ItemType.NONE, // ItemType.PORTAL_GUN_SINGLE,\n  ItemType.PORTAL_GUN_DOUBLE, emptyItem, emptyItem, emptyItem];\n  this.quickBar = this.defaultQuickBar.slice(); // clones\n  // Dynamic.\n  // Buffer filled by engine->controls.\n\n  this.changes = []; // Deprecated.\n  // LEGACY (should NOT be used)\n\n  this._itemOffset = 0.999;\n};\n\nextend(self_SelfComponent.prototype, {\n  init: function init() {\n    var register = this.clientModel.app.register;\n    register.updateSelfState({\n      itemSelected: this.currentItemSlot\n    });\n  },\n  cleanup: function cleanup() {\n    this.quickBar = this.defaultQuickBar.slice();\n    this.currentItemSlot = 0;\n    this._cameraInteraction = \'first-person\';\n  },\n  getCurrentItemID: function getCurrentItemID() {\n    return this.quickBar[this.currentItemSlot];\n  },\n  setAngleFromIntersectionPoint: function setAngleFromIntersectionPoint(angle) {\n    this.angleFromIntersectionPoint = angle;\n  },\n  getAngleFromIntersectionPoint: function getAngleFromIntersectionPoint() {\n    return this.angleFromIntersectionPoint;\n  },\n\n  /**\n   * @deprecated\n   */\n  getItemOffset: function getItemOffset() {\n    return this._itemOffset;\n  },\n  triggerChange: function triggerChange(type, data) {\n    this.changes.push([type, data]);\n  },\n  processChanges: function processChanges() {\n    var changes = this.changes;\n    if (changes.length < 1) return; // ENHANCEMENT [LOW]: filter & simplify\n\n    for (var c = 0; c < changes.length; ++c) {\n      var event = changes[c];\n      var type = event[0];\n      var data = event[1];\n      if (!type || !data) return;\n\n      switch (type) {\n        case \'camera-update\':\n          this.processSimpleCameraUpdate();\n          break;\n\n        case \'camera\':\n          this.processCameraModeChange(data);\n          break;\n\n        case \'interaction\':\n          this.processInteractionChange(data);\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    this.changes = [];\n  },\n  processSimpleCameraUpdate: function processSimpleCameraUpdate() {\n    var graphicsEngine = this.clientModel.app.engine.graphics; // XXX [PERF] only once per iteration.\n    //console.log(\'camera autoupdate\');\n    //graphicsEngine.cameraManager.updateCameraPosition(data);\n\n    graphicsEngine.cameraManager.moveCameraFromMouse(0, 0, 0, 0);\n  },\n  processCameraModeChange: function processCameraModeChange(data) {\n    var serverSelfModel = this.clientModel.app.model.server.selfModel;\n    var graphicsEngine = this.clientModel.app.engine.graphics;\n    var avatar = serverSelfModel.avatar;\n    var worldId = serverSelfModel.worldId;\n    var display;\n    if (data[0] === \'toggle\') display = !serverSelfModel.displayAvatar;else display = false;\n    serverSelfModel.displayAvatar = display;\n    if (display) this._cameraInteraction = \'third-person\';else this._cameraInteraction = \'first-person\'; // TODO [GAMEPLAY] Change held item size and parent mesh.\n\n    graphicsEngine.changeAvatarVisibility(display, avatar, worldId);\n    graphicsEngine.cameraManager.updateCameraPosition(serverSelfModel.position);\n  },\n  processInteractionChange: function processInteractionChange(data) {\n    var graphicsEngine = this.clientModel.app.engine.graphics;\n    var register = this.clientModel.app.register;\n    var actionType = data[0];\n\n    if (actionType === \'itemSelect\') {\n      var deltaY = data[1];\n      var currentItemSlot = this.currentItemSlot;\n      var oldItemSlot = currentItemSlot;\n      var quickBarSize = this.quickBarSize;\n\n      if (deltaY > 0) {\n        // Previous\n        currentItemSlot--;\n        if (currentItemSlot < 0) currentItemSlot = quickBarSize - 1;\n      } else if (deltaY < 0) {\n        // Next\n        currentItemSlot++;\n        currentItemSlot %= quickBarSize;\n      }\n\n      this.currentItemSlot = currentItemSlot; // This short-circuits the normal client-server await cycle\n      // because the player could be very fast.\n\n      graphicsEngine.changeHeldItem(this.quickBar[currentItemSlot]);\n      register.updateSelfState({\n        itemSelect: [currentItemSlot, oldItemSlot]\n      });\n    }\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/model/client/event/event.triggers.js\n/**\n *\n */\n\n\n\nvar TriggersModule = {\n  triggerUse: function triggerUse(type, data) {\n    var clientSelfModel = this.clientModel.selfComponent;\n    var activeItemID = clientSelfModel.getCurrentItemID();\n\n    if (!ItemsModelModule.isItemIDSupported(activeItemID)) {\n      console.error(\'[Client/Event] Item ID unsupported\');\n    }\n\n    var events = this.eventsToPush;\n\n    if (ItemsModelModule.isItemMelee(activeItemID)) {\n      data.push(\'melee\');\n      data.push(activeItemID);\n      events.push([type, data]);\n    } else if (ItemsModelModule.isItemRanged(activeItemID)) {\n      data.push(\'ranged\');\n      data.push(activeItemID);\n      events.push([type, data]);\n    }\n  },\n  triggerRayAction: function triggerRayAction(type, data) {\n    var clientSelfModel = this.clientModel.selfComponent;\n    var activeItemID = clientSelfModel.getCurrentItemID();\n\n    if (!ItemsModelModule.isItemIDSupported(activeItemID)) {\n      console.error(\'[Client/Event] Item ID unsupported\');\n      return;\n    }\n\n    if (ItemsModelModule.isItemBlock(activeItemID)) {\n      if (data[0] === \'add\') {\n        // From inventory, select block to be added.\n        data.pop();\n        data.splice(-3, 3); // There should be a server-wise check (if it is in the inventory)\n\n        data.push(activeItemID);\n      }\n\n      this.triggerBlock(\'b\', data);\n    } else if (ItemsModelModule.isItemX(activeItemID)) {\n      var fx1 = data[1];\n      var fy1 = data[2];\n      var fz1 = data[3];\n      var fx2 = data[4];\n      var fy2 = data[5];\n      var fz2 = data[6];\n      var isOrangeOrBlue = ItemsModelModule.isItemX2(activeItemID);\n      var isMainButton = data[7];\n      data.pop();\n\n      if (fx2 < fx1) {\n        data[1] = fx2;\n        data[4] = fx1;\n      }\n\n      if (fy2 < fy1) {\n        data[2] = fy2;\n        data[5] = fy1;\n      }\n\n      if (fz2 < fz1) {\n        data[3] = fz2;\n        data[6] = fz1;\n      }\n\n      data.push(clientSelfModel.getItemOffset());\n      data.push(clientSelfModel.getAngleFromIntersectionPoint());\n      data.push(isOrangeOrBlue);\n      data.push(isMainButton);\n      this.triggerBlock(\'x\', data);\n    } else if (ItemsModelModule.isItemNaught(activeItemID) && data[0] === \'del\') {\n      this.triggerBlock(\'b\', data);\n    } else {\n      // XXX [GAMEPLAY] object, skill\n      // Validate server-side? Keep duplicate in selfComponent?\n      console.warn(\'[Client/Event] Unsupported item.\');\n    }\n  },\n  triggerMovement: function triggerMovement(type, data) {\n    var ak = this.activeControls;\n    var events = this.eventsToPush;\n\n    var addEvent = function addEvent() {\n      events.push([type, data]);\n    };\n\n    var sameTypeEvents = this.getEventsOfType(type);\n\n    if (sameTypeEvents.length > 0) {// XXX [PERF] compress events\n    }\n\n    switch (data) {\n      case \'f\':\n        if (!ak.forward) addEvent();\n        ak.forward = true;\n        break;\n\n      case \'r\':\n        if (!ak.right) addEvent();\n        ak.right = true;\n        break;\n\n      case \'l\':\n        if (!ak.left) addEvent();\n        ak.left = true;\n        break;\n\n      case \'b\':\n        if (!ak.backwards) addEvent();\n        ak.backwards = true;\n        break;\n\n      case \'d\':\n        if (!ak.down) addEvent();\n        ak.down = true;\n        break;\n\n      case \'u\':\n        if (!ak.up) addEvent();\n        ak.up = true;\n        break;\n\n      case \'run\':\n        if (!ak.run) addEvent();\n        ak.run = true;\n        break;\n\n      case \'runx\':\n        if (ak.run) addEvent();\n        ak.run = false;\n        break;\n\n      case \'fx\':\n        ak.forward = false;\n        addEvent();\n        break;\n\n      case \'rx\':\n        ak.right = false;\n        addEvent();\n        break;\n\n      case \'lx\':\n        ak.left = false;\n        addEvent();\n        break;\n\n      case \'bx\':\n        ak.backwards = false;\n        addEvent();\n        break;\n\n      case \'dx\':\n        ak.down = false;\n        addEvent();\n        break;\n\n      case \'ux\':\n        ak.up = false;\n        addEvent();\n        break;\n\n      case \'xx\':\n        ak.forward = false;\n        ak.backwards = false;\n        ak.right = false;\n        ak.left = false;\n        addEvent();\n        break;\n\n      default:\n        console.log(\'Unrecognized movement, could not trigger.\');\n        break;\n    }\n  },\n  triggerAction: function triggerAction(type, data) {\n    var events = this.eventsToPush;\n\n    switch (data) {\n      case \'g\':\n        events.push([type, data]);\n        break;\n\n      default:\n        console.log(\'Unrecognized action, could not trigger.\');\n        break;\n    }\n  },\n  triggerRotation: function triggerRotation(type, data) {\n    var events = this.eventsToPush;\n    events.push([type, data]);\n  },\n  triggerBlock: function triggerBlock(type, data) {\n    var events = this.eventsToPush;\n    events.push([type, data]);\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/model/client/event/event.activecontrols.js\n/**\n *\n */\n\n\nvar ActiveControlsModule = {\n  getActiveControls: function getActiveControls() {\n    return {\n      forward: false,\n      backwards: false,\n      right: false,\n      left: false,\n      up: false,\n      down: false,\n      run: false\n    };\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/model/client/event/event.js\n/**\n *\n */\n\n\n\n\n\n\nvar EventComponent = function EventComponent(clientModel) {\n  this.clientModel = clientModel;\n  this.eventsToPush = [];\n  this.activeControls = {};\n  this.numberOfEvents = 0;\n  this.maxNumberOfEventsPer16ms = 16;\n};\n\nextend(EventComponent.prototype, {\n  init: function init() {\n    // XXX [REFACTOR] put this in self model\n    this.activeControls = this.getActiveControls();\n  },\n  triggerEvent: function triggerEvent(type, data) {\n    switch (type) {\n      case \'m\':\n        this.triggerMovement(type, data);\n        break;\n\n      case \'a\':\n        this.triggerAction(type, data);\n        break;\n\n      case \'r\':\n        this.triggerRotation(type, data);\n        break;\n\n      case \'u\':\n        // use item\n        this.triggerUse(type, data);\n        break;\n\n      case \'ray\':\n        // Ray casted.\n        this.triggerRayAction(type, data);\n        break;\n\n      default:\n        break;\n    } // Refresh, count transmitted items, if > threshold, stock them\n\n\n    this.numberOfEvents++;\n  },\n  pushEvents: function pushEvents() {\n    var connectionEngine = this.clientModel.app.engine.connection;\n    var events = this.eventsToPush;\n    var currentEvent;\n    var maxNumberOfEvents = this.maxNumberOfEventsPer16ms;\n\n    if (this.numberOfEvents > maxNumberOfEvents) {\n      this.filterEvents(); // Remove unnecessary events.\n\n      console.log("Calm down, user... ".concat(this.numberOfEvents, " unstacked events detected."));\n    } // Push to server\n    // XXX [PERF] simplify and aggregate per client.\n\n\n    for (var eventId = 0, length = events.length; eventId < length; ++eventId) {\n      currentEvent = events[eventId];\n      connectionEngine.send(currentEvent[0], currentEvent[1]);\n    } // Flush\n\n\n    this.eventsToPush = [];\n    this.numberOfEvents = 0;\n  },\n  getEventsOfType: function getEventsOfType(type) {\n    var events = this.eventsToPush;\n    var result = []; // N.B. prefer straight cache-friendly traversals\n\n    for (var eventId = 0, length = events.length; eventId < length; ++eventId) {\n      var currentEvent = events[eventId];\n\n      if (currentEvent[0] === type) {\n        result.push(currentEvent);\n      }\n    }\n\n    return result;\n  },\n  filterEvents: function filterEvents() {\n    var events = this.eventsToPush;\n    var filteredEvents = [];\n    var lastRotation; // Remove all rotations except the last.\n\n    for (var i = 0, l = events.length; i < l; ++i) {\n      var currentEvent = events[i];\n      if (!currentEvent) continue;\n\n      if (currentEvent[0] !== \'r\') {\n        lastRotation = events[i];\n      } else {\n        filteredEvents.push(currentEvent);\n      }\n    }\n\n    filteredEvents.push(lastRotation);\n    this.eventsToPush = filteredEvents;\n  }\n});\nextend(EventComponent.prototype, TriggersModule);\nextend(EventComponent.prototype, ActiveControlsModule);\n\n// CONCATENATED MODULE: ./client/app/model/client/client.js\n/**\n * Manages whatever mechanism must remain client-side (like interaction settings),\n * along with aggregating, filtering and triggering events\n * to be sent.\n */\n\n\n\n\n\n\nvar client_Client = function Client(app) {\n  this.app = app; // Client model component.\n\n  this.selfComponent = new self_SelfComponent(this); // Event component.\n\n  this.eventComponent = new EventComponent(this);\n};\n\nextend(client_Client.prototype, {\n  init: function init() {\n    this.selfComponent.init();\n    this.eventComponent.init();\n  },\n  refresh: function refresh() {\n    this.selfComponent.processChanges();\n    this.eventComponent.pushEvents();\n  },\n  pushForLaterUpdate: function pushForLaterUpdate(position) {\n    this.selfComponent.triggerChange(\'camera-update\', position);\n  },\n  triggerEvent: function triggerEvent(type, data) {\n    this.eventComponent.triggerEvent(type, data);\n  },\n  triggerChange: function triggerChange(type, data) {\n    this.selfComponent.triggerChange(type, data);\n  },\n\n  /**\n   * @deprecated\n   */\n  getCameraInteraction: function getCameraInteraction() {\n    return this.selfComponent.cameraInteraction;\n  },\n  cleanupFullModel: function cleanupFullModel() {\n    this.selfComponent.cleanup();\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/model/localserver/localserver.js\n/**\n * Keeps track of distant users that can connect to the local server.\n * Used when the local server is running.\n */\n\n\n\n\nvar LocalServer = function LocalServer(app) {\n  this.app = app;\n  this.users = new Map();\n  this.localClientOffer = \'\';\n  this.localClientAnswer = \'\';\n};\n\nextend(LocalServer.prototype, {\n  hasUser: function hasUser(userID) {\n    return this.users.has(userID);\n  },\n  addUser: function addUser(userID) {\n    this.users.set(userID, {\n      offer: \'\',\n      answer: \'\',\n      inboundConnection: null,\n      inboundChannel: null,\n      connected: false\n    });\n  },\n  removeUser: function removeUser(userID) {\n    this.users["delete"](userID);\n  },\n  // Server offer\n  setUserOffer: function setUserOffer(userID, offer) {\n    var user = this.users.get(userID);\n\n    if (!user) {\n      this.users.set(userID, {\n        offer: offer,\n        answer: \'\',\n        inboundConnection: null,\n        inboundChannel: null,\n        connected: false\n      });\n    } else {\n      user.offer = offer;\n    }\n  },\n  setUserConnection: function setUserConnection(userID, connection) {\n    var user = this.users.get(userID);\n\n    if (!user) {\n      console.error("[Model/LocalServer] User \\"".concat(userID, "\\" not found."));\n      return;\n    }\n\n    user.inboundConnection = connection;\n  },\n  setUserChannel: function setUserChannel(userID, channel) {\n    var user = this.users.get(userID);\n\n    if (!user) {\n      console.error("[Model/LocalServer] User \\"".concat(userID, "\\" not found."));\n      return;\n    }\n\n    user.inboundChannel = channel;\n  },\n  getUser: function getUser(userID) {\n    return this.users.get(userID);\n  },\n  setUserConnectionStatus: function setUserConnectionStatus(userID, isConnected) {\n    var user = this.users.get(userID);\n    if (!user) return;\n    user.connected = isConnected;\n  },\n  isUserConnectionAvailable: function isUserConnectionAvailable(userID) {\n    var user = this.users.get(userID);\n    return !!user && !user.connected;\n  },\n  // Client answer\n  addAnswer: function addAnswer(userID, answer) {\n    var user = this.users.get(userID);\n\n    if (!user) {\n      console.error("[Model/LocalServer] User \\"".concat(userID, "\\" not found."));\n      return;\n    }\n\n    user.answer = answer;\n  },\n  // WebRTC Client methods\n  setLocalClientOffer: function setLocalClientOffer(offer) {\n    this.localClientOffer = offer;\n  },\n  setLocalClientAnswer: function setLocalClientAnswer(answer) {\n    this.localClientAnswer = answer;\n  }\n});\n\n// CONCATENATED MODULE: ./server/app/engine/math/collections.js\n/**\n *\n */\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar CollectionUtils = /*#__PURE__*/function () {\n  function CollectionUtils() {\n    _classCallCheck(this, CollectionUtils);\n  }\n\n  _createClass(CollectionUtils, null, [{\n    key: "_locationOf",\n    // O(log(n))\n    value: function _locationOf(element, array, start, end) {\n      start = start || 0;\n      end = end || array.length;\n      var pivot = parseInt(start + (end - start) / 2, 10);\n      if (end - start <= 1 || array[pivot] === element) return pivot;\n\n      if (array[pivot] < element) {\n        return CollectionUtils._locationOf(element, array, pivot, end);\n      } else {\n        return CollectionUtils._locationOf(element, array, start, pivot);\n      }\n    }\n  }, {\n    key: "insert",\n    value: function insert(element, array) {\n      if (array === undefined) {\n        var e = new Error(\'BLD @insert: undefined array.\');\n        console.log(e.stack);\n        return -1;\n      }\n\n      var location = CollectionUtils._locationOf(element, array) + 1;\n\n      if (array[location] === element) {\n        console.log(\'Util.insert: element already in sorted array.\');\n        return location;\n      }\n\n      array.splice(location, 0, element);\n      return location;\n    }\n  }, {\n    key: "insertWithLocation",\n    value: function insertWithLocation(location, element, array) {\n      if (array === undefined) {\n        var e = new Error(\'BLD: undefined array.\');\n        console.log(e.stack);\n        return -1;\n      }\n\n      if (array[location] === element) {\n        console.log(\'Util.insert: element already in sorted array.\');\n        return location;\n      }\n\n      array.splice(location, 0, element);\n      return location;\n    }\n  }, {\n    key: "generateId",\n    value: function generateId(collection, propertyIdName) {\n      var random = function random() {\n        return Math.floor(Math.random() * 1000000);\n      };\n\n      var id = random();\n\n      if (collection instanceof Map) {\n        while (collection.has(id)) {\n          id = random();\n        }\n      } else if (collection instanceof Array) {\n        // Array\n        // Unicity mandatory check\n        if (!propertyIdName) throw Error(\'@generateId: generating id for \' + \'array for unknown property identifier\');\n\n        var f = function f(e) {\n          return e[propertyIdName] === id;\n        };\n\n        while (collection.filter(f).length > 0) {\n          id = random();\n        }\n      } else if (collection instanceof Object) {\n        // Object <-> Map\n        // Unicity mandatory check\n        while (id in collection) {\n          id = random();\n        }\n      }\n\n      return id;\n    }\n  }, {\n    key: "numberOfProperties",\n    value: function numberOfProperties(object) {\n      return Object.keys(object).length;\n    }\n  }, {\n    key: "removeFromArray",\n    value: function removeFromArray(array, object) {\n      if (array === undefined) {\n        var e = new Error(\'BLD @removeFromArray: undefined array.\');\n        console.log(e.stack);\n        return -1;\n      }\n\n      var objectId = array.indexOf(object);\n      if (objectId > -1) array.splice(objectId, 1);\n      return objectId;\n    }\n  }, {\n    key: "removeFromArrayWithId",\n    value: function removeFromArrayWithId(array, objectId) {\n      if (objectId > -1) array.splice(objectId, 1);\n    }\n  }, {\n    key: "forEachProperty",\n    value: function forEachProperty(object, func) {\n      Object.keys(object).forEach(func);\n    }\n  }]);\n\n  return CollectionUtils;\n}();\n\n/* harmony default export */ var collections = (CollectionUtils);\n// CONCATENATED MODULE: ./server/app/model/client/user_db.js\n/**\n * DB.\n */\n\n\nfunction user_db_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction user_db_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction user_db_createClass(Constructor, protoProps, staticProps) { if (protoProps) user_db_defineProperties(Constructor.prototype, protoProps); if (staticProps) user_db_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar user_db_UserDataBase = /*#__PURE__*/function () {\n  function UserDataBase(connector) {\n    user_db_classCallCheck(this, UserDataBase);\n\n    this._connection = connector;\n    this._users = new Map();\n  }\n\n  user_db_createClass(UserDataBase, [{\n    key: "containsUser",\n    value: function containsUser(user) {\n      return this._users.has(user.id);\n    }\n    /**\n     * Injects a socket into the user model.\n     * Registers the user (a socket knows its user since the connection).\n     * @param socket\n     */\n\n  }, {\n    key: "registerUser",\n    value: function registerUser(socket) {\n      var users = this._users;\n      var nick = \'\';\n      var id = collections.generateId(users);\n      var hub = this._connection.hub;\n      var user = model_factory.createUser(hub, socket, nick, id);\n      users.set(id, user);\n      return user;\n    }\n  }, {\n    key: "getUser",\n    value: function getUser(id) {\n      return this._users.get(id);\n    }\n  }, {\n    key: "getUsers",\n    value: function getUsers() {\n      return this._users;\n    }\n  }, {\n    key: "removeUser",\n    value: function removeUser(user) {\n      // Remove references to this user\n      this._users["delete"](user.id);\n\n      user.destroy();\n    }\n  }, {\n    key: "notifyGameCreation",\n    value: function notifyGameCreation(kind, id) {\n      var game = {};\n      game[kind] = [id];\n      var users = this._users;\n      users.forEach(function (user\n      /*, userId*/\n      ) {\n        user.fetchHubState(); // user.send(\'hub\', JSON.stringify(game));\n      });\n    }\n  }]);\n\n  return UserDataBase;\n}();\n\n/* harmony default export */ var user_db = (user_db_UserDataBase);\n// CONCATENATED MODULE: ./server/app/model/game/hub.js\n/**\n * Game management.\n */\n\n\nfunction hub_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction hub_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction hub_createClass(Constructor, protoProps, staticProps) { if (protoProps) hub_defineProperties(Constructor.prototype, protoProps); if (staticProps) hub_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar game_hub_Hub = /*#__PURE__*/function () {\n  function Hub(app) {\n    hub_classCallCheck(this, Hub);\n\n    this._app = app;\n    this._games = new Map();\n  }\n\n  hub_createClass(Hub, [{\n    key: "validateRequest",\n    value: function validateRequest() {\n      // Count games.\n      var games = this._games;\n      var nbGames = 0;\n      games.forEach(function (gamesForKind\n      /*, kind*/\n      ) {\n        nbGames += gamesForKind.size;\n      });\n      var validation = nbGames < 5; // console.log(nbGames > 0 ? nbGames : `No game${nbGames > 1 ? \'s are\' : \' is\'} running or idle.`);\n\n      if (!validation) console.error(\'[Server/Hub] Invalid game creation request: too many games running.\');\n      return validation;\n    }\n  }, {\n    key: "requestNewGame",\n    value: function requestNewGame(user, kind, options) {\n      var app = this._app; // Verify.\n\n      if (!Hub.validateUser(user)) return false;\n      if (!Hub.validateKind(kind)) return false;\n      if (!Hub.validateOptions(kind, options)) return false;\n      if (!this.validateRequest()) return false; // Create game and notify users.\n\n      var id = this.addGame(kind, options);\n\n      if (id || id === 0) {\n        app.connection.db.notifyGameCreation(kind, id);\n        return true;\n      } else return false;\n    }\n  }, {\n    key: "getGame",\n    value: function getGame(kind, gameId) {\n      var gamesOfKind = this._games.get(kind);\n\n      if (!gamesOfKind) return;\n      return gamesOfKind.get(gameId);\n    }\n    /**\n     * Lists all games with minimal information.\n     * @returns {{}} Object: 1 id = 1 game kind; 1 element = 1 array of game ids.\n     */\n\n  }, {\n    key: "listGames",\n    value: function listGames() {\n      var games = {};\n      var modelGames = this._games;\n      modelGames.forEach(function (gamesForKind, kind) {\n        games[kind] = [];\n        var g = games[kind];\n        gamesForKind.forEach(function (game, gameId) {\n          g.push(gameId);\n        });\n      });\n      return games;\n    }\n    /**\n     * Not param-safe: use \'requestNewGame\' to ensure kind validity.\n     */\n\n  }, {\n    key: "addGame",\n    value: function addGame(kind, options) {\n      var games = this._games;\n      var connection = this._app.connection; // Init list of games of this kind\n\n      if (!games.has(kind)) games.set(kind, new Map());\n      var gid = collections.generateId(games.get(kind)); // Create matching game\n\n      var game = model_factory.createGame(this, kind, gid, connection, options); // Add to games.\n\n      if (game) {\n        games.get(kind).set(gid, game);\n        return game.gameId;\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: "endGame",\n    value: function endGame(game) {\n      if (game.isRunning) {\n        console.log(\'WARN! Trying to end a running game. Abort.\');\n        return;\n      }\n\n      var games = this._games;\n      var gid = game.gameId;\n      var kind = game.kind;\n      game.destroy();\n      var gamesOfKind = games.get(kind);\n\n      if (gamesOfKind) {\n        gamesOfKind["delete"](gid);\n        if (gamesOfKind.size < 1) games["delete"](kind);\n      }\n    }\n  }, {\n    key: "_isServerLocal",\n    value: function _isServerLocal() {\n      return this._app._isLocal;\n    }\n  }, {\n    key: "_updateGameLoops",\n    value: function _updateGameLoops() {\n      this._games.forEach(function (gamesOfKind) {\n        gamesOfKind.forEach(function (game) {\n          game.update();\n        });\n      });\n    }\n  }], [{\n    key: "validateUser",\n    value: function validateUser(user) {\n      // Do validation\n      var res = user !== null;\n      if (!res) console.log(\'Invalid user requested new game.\');\n      return res;\n    }\n  }, {\n    key: "validateKind",\n    value: function validateKind(kind) {\n      switch (kind) {\n        case \'cube\':\n        case \'flat\':\n        case \'demo\':\n        case \'fantasy\':\n          return true;\n\n        case \'unstructured\':\n          console.log(\'[Server/Hub] Unstructured support coming soon.\');\n          return false;\n      }\n\n      console.log(\'[Server/Hub/Validator] Requested an unsupported game kind.\');\n      return false;\n    }\n  }, {\n    key: "validateOptions",\n    value: function validateOptions(kind, options) {\n      var validated;\n\n      switch (kind) {\n        case \'demo\':\n          validated = !options; // Options must be null.\n\n          break;\n\n        case \'cube\':\n          validated = options.hasOwnProperty(\'hills\') && function (x) {\n            return x >= 0 && x <= 1;\n          }(parseInt(options.hills, 10)) && options.hasOwnProperty(\'size\') && function (x) {\n            return x >= 1 && x <= 256;\n          }(parseInt(options.size, 10));\n\n          break;\n\n        case \'flat\':\n          validated = options.hasOwnProperty(\'hills\') && function (x) {\n            return x >= 0 && x <= 4;\n          }(parseInt(options.hills, 10)) && options.hasOwnProperty(\'trees\') && function (x) {\n            return x >= 0 && x <= 1;\n          }(parseInt(options.trees, 10));\n\n          break;\n\n        case \'fantasy\':\n          validated = true;\n          break;\n\n        case \'unstructured\':\n        default:\n          validated = false;\n          break;\n      }\n\n      if (!validated) console.error(\'[Server/Hub/Validator] Invalid game creation options.\');\n      return validated;\n    }\n  }]);\n\n  return Hub;\n}();\n\n/* harmony default export */ var game_hub = (game_hub_Hub);\n// CONCATENATED MODULE: ./server/app/model/client/user.js\n/**\n * User model.\n */\n\n\nfunction user_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction user_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction user_createClass(Constructor, protoProps, staticProps) { if (protoProps) user_defineProperties(Constructor.prototype, protoProps); if (staticProps) user_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar user_User = /*#__PURE__*/function () {\n  function User(hub, socket, nick, id) {\n    user_classCallCheck(this, User);\n\n    // Model\n    this._hub = hub;\n    this._userConnection = model_factory.createUserConnection(this, socket);\n    this._nick = nick;\n    this._id = id; // States\n\n    this._ingame = false;\n    this._player = null;\n  } // Model\n\n\n  user_createClass(User, [{\n    key: "send",\n    // Send a message to this user through its UserConnection.\n    value: function send(kind, data) {\n      this._userConnection.send(kind, data);\n    } // Requests the hub to create a new gaming pool.\n\n  }, {\n    key: "requestNewGame",\n    value: function requestNewGame(kind, options) {\n      return this._hub.requestNewGame(this, kind, options);\n    } // Join a specific game.\n\n  }, {\n    key: "join",\n    value: function join(kind, gameId) {\n      gameId = parseInt(gameId, 10);\n      this._ingame = true;\n\n      var game = this._hub.getGame(kind, gameId);\n\n      if (!game || game.killed) return false; // Stop listening for general game management events...\n      // Prevents the user from joining multiple games.\n\n      this._userConnection.idle(); // Check if the game already contains a player with the same socket\n\n\n      if (game.hasPlayerForSocket(this._userConnection.socket)) return true; // Create a player associated to this game and spawn it\n\n      var player = model_factory.createPlayer(this, game);\n      this._player = player;\n      game.addPlayer(player);\n      return true;\n    }\n  }, {\n    key: "fetchHubState",\n    value: function fetchHubState() {\n      var games = this._hub.listGames();\n\n      if (Object.keys(games).length < 1) {\n        this._userConnection.send(\'hub\', JSON.stringify(games));\n\n        return;\n      }\n\n      for (var kind in games) {\n        if (games[kind] instanceof Array && games[kind].length > 0) {\n          this._userConnection.send(\'hub\', JSON.stringify(games));\n\n          return;\n        }\n      }\n    } // Leave all games (current game). Stay idle.\n\n  }, {\n    key: "leave",\n    value: function leave() {\n      console.log(\'[User] A user left.\');\n      this._ingame = false;\n\n      if (this._player) {\n        this._player.leave();\n\n        this._player.destroy(); // OK given player.leave() was called\n        // So player does not belong to its game model.\n\n\n        this._player = null;\n      }\n\n      this.listen();\n    }\n  }, {\n    key: "listen",\n    value: function listen() {\n      this._userConnection.listen();\n    } // Disconnect from ingame socket. Stay inside game model.\n    // Maybe the connection will come back.\n\n  }, {\n    key: "disconnect",\n    value: function disconnect() {\n      // Do not destroy player (account for unexpected disconnections)\n      if (this._player) this._player.disconnect();\n    } // Clean references.\n\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      this._userConnection.destroy(); // Do not destroy player before its game ends.\n      // Useful for user reconnection...\n      // if (this._player) this._player.destroy();\n\n\n      delete this._userConnection;\n      delete this._player;\n      delete this._hub;\n      delete this._nick;\n      delete this._id;\n      delete this._ingame;\n    }\n  }, {\n    key: "hub",\n    get: function get() {\n      return this._hub;\n    }\n  }, {\n    key: "id",\n    get: function get() {\n      return this._id;\n    }\n  }, {\n    key: "connection",\n    get: function get() {\n      return this._userConnection;\n    }\n  }, {\n    key: "player",\n    get: function get() {\n      return this._player;\n    }\n  }, {\n    key: "nick",\n    get: function get() {\n      return this._nick;\n    },\n    set: function set(nick) {\n      this._nick = nick;\n    }\n  }, {\n    key: "ingame",\n    get: function get() {\n      return this._ingame;\n    },\n    set: function set(value) {\n      if (value) this._ingame = value;\n    }\n  }]);\n\n  return User;\n}();\n\n/* harmony default export */ var client_user = (user_User);\n// CONCATENATED MODULE: ./server/app/model/client/player.js\n/**\n * Player model.\n */\n\n\nfunction player_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction player_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction player_createClass(Constructor, protoProps, staticProps) { if (protoProps) player_defineProperties(Constructor.prototype, protoProps); if (staticProps) player_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar player_Player = /*#__PURE__*/function () {\n  function Player(user, game) {\n    player_classCallCheck(this, Player);\n\n    this._user = user;\n    this._game = game; // May be given an avatar when logged to a game.\n\n    this._avatar = undefined;\n    this._playerConnection = model_factory.createPlayerConnection(user.connection.socket);\n  } // Model\n\n\n  player_createClass(Player, [{\n    key: "join",\n\n    /**\n     * Join a socket room.\n     * @param room Socket subset of users.\n     */\n    value: function join(room) {\n      this._playerConnection.join(room);\n    }\n    /**\n     * Send a message to this user.\n     * @param kind\n     * @param data\n     */\n\n  }, {\n    key: "send",\n    value: function send(kind, data) {\n      this._playerConnection.send(kind, data);\n    } // Leave game and make the game forget.\n\n  }, {\n    key: "leave",\n    value: function leave() {\n      this.disconnect();\n      if (this._game) this._game.removePlayer(this);\n    } // Close player connection.\n\n  }, {\n    key: "disconnect",\n    value: function disconnect() {\n      if (this._playerConnection) this._playerConnection.close();\n    }\n    /**\n     * Define custom interactions (see PlayerConnection).\n     * @param message\n     * @param behaviour\n     */\n\n  }, {\n    key: "on",\n    value: function on(message, behaviour) {\n      this._playerConnection.on(message, behaviour);\n    }\n    /**\n     * Stop listening for a specified input type.\n     * @param message\n     * @param behaviour\n     */\n\n  }, {\n    key: "off",\n    value: function off(message, behaviour) {\n      this._playerConnection.off(message, behaviour);\n    } // Clean references. Only use from a Game instance.\n\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      // Destroy player connection which is a single child of this object.\n      if (this._playerConnection) this._playerConnection.destroy();\n      delete this._playerConnection;\n      delete this._game;\n      delete this._user;\n    }\n  }, {\n    key: "game",\n    get: function get() {\n      return this._game;\n    }\n  }, {\n    key: "user",\n    get: function get() {\n      return this._user;\n    }\n  }, {\n    key: "connection",\n    get: function get() {\n      return this._playerConnection;\n    }\n  }]);\n\n  return Player;\n}();\n\n/* harmony default export */ var client_player = (player_Player);\n// CONCATENATED MODULE: ./server/app/model/client/player_manager.js\n/**\n * Utility class encapsulating player management.\n */\n\n\nfunction player_manager_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction player_manager_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction player_manager_createClass(Constructor, protoProps, staticProps) { if (protoProps) player_manager_defineProperties(Constructor.prototype, protoProps); if (staticProps) player_manager_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n/**\n * Note: every time a user joins a given game, it is given a new Player instance.\n * So all Player instances which belong to a game must be cleaned at the moment this game is cleaned.\n */\n\nvar player_manager_PlayerManager = /*#__PURE__*/function () {\n  function PlayerManager() {\n    player_manager_classCallCheck(this, PlayerManager);\n\n    this._players = [];\n    this._handleAddPlayer = null;\n    this._handleRemovePlayer = null;\n  }\n\n  player_manager_createClass(PlayerManager, [{\n    key: "addPlayer",\n    value: function addPlayer(player) {\n      this._players.push(player);\n\n      if (this._handleAddPlayer) this._handleAddPlayer(player);\n    }\n  }, {\n    key: "getRandomPlayer",\n    value: function getRandomPlayer() {\n      var nbPlayers = this._players.length;\n      if (nbPlayers < 1) return null;\n      var id = Math.floor(Math.random() * nbPlayers);\n      var player = this._players[id];\n      if (player && player.avatar) return player.avatar;else return null;\n    }\n  }, {\n    key: "getPlayerFromId",\n    value: function getPlayerFromId(playerId) {\n      var players = this._players;\n\n      for (var p = 0, l = players.length; p < l; ++p) {\n        var player = players[p];\n        var avatar = player.avatar;\n        if (avatar && avatar.entityId === playerId) return player;\n      }\n\n      return false;\n    }\n  }, {\n    key: "removePlayer",\n    value: function removePlayer(player) {\n      collections.removeFromArray(this._players, player);\n      if (this._handleRemovePlayer) this._handleRemovePlayer(player);\n      player.avatar.die();\n      delete player.avatar; // Listen to user requests for joining games.\n\n      player.user.listen(); // Clean references from player\n\n      player.destroy();\n    }\n  }, {\n    key: "removeAllPlayers",\n    value: function removeAllPlayers() {\n      var _this = this;\n\n      if (this._handleRemovePlayer) this._players.forEach(function (p) {\n        return _this._handleRemovePlayer(p);\n      });\n\n      this._players.forEach(function (p) {\n        return p.destroy();\n      }); // Clean references from all players\n\n\n      this._players = [];\n    }\n  }, {\n    key: "setAddPlayerBehaviour",\n    value: function setAddPlayerBehaviour(f) {\n      this._handleAddPlayer = f;\n    }\n  }, {\n    key: "setRemovePlayerBehaviour",\n    value: function setRemovePlayerBehaviour(f) {\n      this._handleRemovePlayer = f;\n    } // Iterator on players.\n\n  }, {\n    key: "forEach",\n    value: function forEach(callback) {\n      return this._players.forEach(function (p) {\n        return callback(p);\n      });\n    } // Clean all references.\n\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      this.removeAllPlayers();\n      delete this._players;\n      delete this._handleAddPlayer;\n      delete this._handleRemovePlayer;\n    }\n  }, {\n    key: "hasPlayerForSocket",\n    value: function hasPlayerForSocket(socket) {\n      var players = this._players;\n      var nb = players.length;\n      if (!socket || !socket.name) return false;\n\n      for (var p = 0; p < nb; ++p) {\n        var player = players[p];\n        if (!player.connection.socket || !player.connection.socket.name) continue;\n\n        if (socket.name === player.connection.socket.name) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: "nbPlayers",\n    get: function get() {\n      return this._players.length;\n    }\n  }]);\n\n  return PlayerManager;\n}();\n\n/* harmony default export */ var player_manager = (player_manager_PlayerManager);\n// CONCATENATED MODULE: ./server/app/model/connection/connection.js\n/**\n * Custom socket communication layer.\n */\n\n\nfunction connection_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction connection_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction connection_createClass(Constructor, protoProps, staticProps) { if (protoProps) connection_defineProperties(Constructor.prototype, protoProps); if (staticProps) connection_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar connection_Connector = /*#__PURE__*/function () {\n  function Connector(app) {\n    connection_classCallCheck(this, Connector);\n\n    this._app = app;\n    this._userDB = model_factory.createUserDB(this);\n    this._io = null;\n    this._debug = false;\n    this._sandboxConnections = new Set();\n  } // Model\n\n\n  connection_createClass(Connector, [{\n    key: "setupUser",\n    // When the user connects, register him\n    value: function setupUser(socket) {\n      // Add user to app DB\n      var user = this._userDB.registerUser(socket); // A user knows its socket and reciprocally\n\n\n      socket.user = user; // Inform the user that its connection is established\n      // Make him wait a little... Server does not hurry.\n\n      this.confirmUserConnection(socket);\n    }\n  }, {\n    key: "confirmUserConnection",\n    value: function confirmUserConnection(socket) {\n      setTimeout(function () {\n        return socket.emit(\'connected\', \'\');\n      }, 50);\n    }\n  }, {\n    key: "setupDisconnect",\n    value: function setupDisconnect(socket) {\n      var _this = this;\n\n      // Setup off util function\n      socket.off = socket.removeListener; // Call onDisconnect.\n\n      socket.on(\'disconnect\', function () {\n        var user = socket.user;\n        if (user === undefined) return; // Leave from any running game.\n\n        user.leave(); // First disconnects then makes the game forget.\n        // Destroy user.\n\n        _this._userDB.removeUser(user);\n\n        if (_this._debug) socket.log(\'DISCONNECTED\');\n\n        if (socket.isWebRTC) {\n          socket.closeConnection();\n        }\n      });\n    }\n  }, {\n    key: "setupDebug",\n    value: function setupDebug(socket) {\n      this._debug = true;\n      socket.address = "".concat(socket.request.connection.remoteAddress, ":").concat(socket.request.connection.remotePort);\n      socket.connectedAt = new Date();\n\n      socket.log = function () {\n        var _console;\n\n        for (var _len = arguments.length, data = new Array(_len), _key = 0; _key < _len; _key++) {\n          data[_key] = arguments[_key];\n        }\n\n        (_console = console).log.apply(_console, ["SocketIO ".concat(socket.nsp.name, " [").concat(socket.address, "]")].concat(data));\n      }; // When the client emits \'info\', this listens and executes\n\n\n      socket.on(\'info\', function (data) {\n        socket.log(JSON.stringify(data, null, 2));\n      });\n    }\n    /**\n     * Configure socket connections.\n     *\n     * socket.io (v1.x.x) is powered by debug.\n     *\n     * In order to see all the debug output, set DEBUG\n     * (in server/config/local.env.js) to including the desired scope.\n     * (don\'t forget to import config from \'./environment\' ;)\n     * ex: DEBUG: "http*,socket.io:socket"\n     *\n     * We can authenticate socket.io users and access their token through socket.decoded_token\n     * 1. You will need to send the token in `client/components/socket/socket.service.js`\n     * 2. Require authentication here:\n     *      socketio.use(require(\'socketio-jwt\').authorize({\n     *          secret: config.secrets.session,\n     *          handshake: true\n     *      }));\n     *\n     * @param socketio\n     */\n\n  }, {\n    key: "configure",\n    value: function configure(socketio) {\n      var _this2 = this;\n\n      if (this._io) {\n        console.log(\'[Server/Connector] Trying to configure a running app, \' + \'using the last configuration!\');\n        return;\n      }\n\n      console.log(\'[Connection] SocketIO configuration pending...\');\n      this._io = socketio;\n      socketio.on(\'connection\', function (socket) {\n        _this2.configureFromSocket(socket);\n      });\n    }\n  }, {\n    key: "configureFromSocket",\n    value: function configureFromSocket(socket, userID) {\n      if (userID) {\n        var hasUser = this._sandboxConnections.has(userID);\n\n        if (hasUser) {\n          // Find user with the connection id.\n          var users = this._userDB.getUsers();\n\n          var userReplace = null;\n          users.forEach(function (user) {\n            // replace user socket\n            if (user.connection.socket.name === userID) {\n              userReplace = user;\n            }\n          });\n\n          if (userReplace) {\n            console.log(\'CLEANUP OLD SOCKET\'); // CAUTION! Setter handles cleanup.\n\n            userReplace.connection.socket = socket;\n\n            if (userReplace.player) {\n              var playerCo = userReplace.player.connection; // CAUTION! Setter handles cleanup here too.\n\n              playerCo.socket = socket;\n            }\n\n            this.confirmUserConnection(socket);\n            return;\n          }\n        } else this._sandboxConnections.add(userID);\n      } // Define debug functions and attributes\n\n\n      this.setupDebug(socket); // Define disconnect behaviour\n\n      this.setupDisconnect(socket); // Register user\n\n      this.setupUser(socket);\n      if (this._debug) socket.log(\'CONNECTED\');\n    }\n  }, {\n    key: "hub",\n    get: function get() {\n      return this._app.hub;\n    }\n  }, {\n    key: "io",\n    get: function get() {\n      return this._io;\n    }\n  }, {\n    key: "db",\n    get: function get() {\n      return this._userDB;\n    }\n  }]);\n\n  return Connector;\n}();\n\n/* harmony default export */ var connection_connection = (connection_Connector);\n// CONCATENATED MODULE: ./server/app/model/connection/user_connection.js\n/**\n *\n */\n\n\nfunction user_connection_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction user_connection_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction user_connection_createClass(Constructor, protoProps, staticProps) { if (protoProps) user_connection_defineProperties(Constructor.prototype, protoProps); if (staticProps) user_connection_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar UserConnection = /*#__PURE__*/function () {\n  function UserConnection(user, socket) {\n    user_connection_classCallCheck(this, UserConnection);\n\n    this._user = user;\n    this._socket = socket;\n    this.listen();\n  } // Model\n\n\n  user_connection_createClass(UserConnection, [{\n    key: "send",\n    value: function send(kind, data) {\n      this._socket.emit(kind, data);\n    } // Game & hub management.\n\n  }, {\n    key: "listen",\n    value: function listen() {\n      // Use a unique channel for util functions\n      // Actions are specified within the data\n      this._socket.on(\'util\', this.onUserRequest.bind(this));\n    } // Drawback: switch potentially evaluates all statements\n    // Advantage: does not load the socket with many listeners\n\n  }, {\n    key: "onUserRequest",\n    value: function onUserRequest(data) {\n      switch (data.request) {\n        // A user can ask the hub for a new game to be created.\n        case \'createGame\':\n          if (!data.hasOwnProperty(\'gameType\')) {\n            console.error(\'[Server/UserConnection] Missing game type.\');\n            break;\n          }\n\n          this.handleCreateGame(data.gameType, data.options);\n          break;\n        // A user can join a specific game (given a kind and id).\n\n        case \'joinGame\':\n          console.log(\'[UserConnection] A player tries to join.\');\n\n          if (!data.hasOwnProperty(\'gameId\') || !data.hasOwnProperty(\'gameType\') || !data.gameId || !data.gameType || !this.handleJoinGame(data)) {\n            this.send(\'cantjoin\', \'foo\');\n          }\n\n          break;\n        // A user can ask for the list of all available games.\n\n        case \'hub\':\n          this.handleGetHubState();\n          break;\n      }\n    }\n  }, {\n    key: "handleCreateGame",\n    value: function handleCreateGame(kind, options) {\n      var created = this._user.requestNewGame(kind, options);\n\n      if (created) console.log(\'[UserConnection] Created new game.\');\n      return created;\n    }\n  }, {\n    key: "handleJoinGame",\n    value: function handleJoinGame(data) {\n      var joined = this._user.join(data.gameType, data.gameId);\n\n      if (joined) this.send(\'joined\', \'foo\');\n      return joined;\n    }\n  }, {\n    key: "handleGetHubState",\n    value: function handleGetHubState() {\n      this._user.fetchHubState();\n    }\n  }, {\n    key: "idle",\n    value: function idle() {\n      this._socket.off(\'util\', this.onUserRequest.bind(this));\n    } // Clean references.\n\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      this.idle();\n      delete this._user;\n      delete this._socket;\n    }\n  }, {\n    key: "user",\n    get: function get() {\n      return this._user;\n    },\n    set: function set(user) {\n      this._user = user;\n    }\n  }, {\n    key: "socket",\n    get: function get() {\n      return this._socket;\n    },\n    set: function set(socket) {\n      this.idle();\n      this._socket = socket;\n      this.listen();\n    }\n  }]);\n\n  return UserConnection;\n}();\n\n/* harmony default export */ var user_connection = (UserConnection);\n// CONCATENATED MODULE: ./server/app/model/connection/player_connection.js\n/**\n *\n */\n\n\nfunction player_connection_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction player_connection_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction player_connection_createClass(Constructor, protoProps, staticProps) { if (protoProps) player_connection_defineProperties(Constructor.prototype, protoProps); if (staticProps) player_connection_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar player_connection_PlayerConnection = /*#__PURE__*/function () {\n  function PlayerConnection(socket) {\n    player_connection_classCallCheck(this, PlayerConnection);\n\n    this._socket = socket;\n    this._rooms = [];\n    this._listeners = [];\n    this._savedListeners = {};\n  }\n\n  player_connection_createClass(PlayerConnection, [{\n    key: "send",\n    value: function send(kind, data) {\n      this._socket.emit(kind, data);\n    }\n    /**\n     * Register custom socket behaviour.\n     * @param message\n     * @param behaviour\n     */\n\n  }, {\n    key: "on",\n    value: function on(message, behaviour) {\n      if (typeof behaviour !== \'function\') console.log(\'WARN: invalid socket definition.\');else {\n        this._listeners.push(message);\n\n        this._savedListeners[message] = behaviour;\n\n        this._socket.on(message, behaviour);\n      }\n    }\n    /**\n     * Stop listening for a specific message.\n     * @param message\n     * @param behaviour the bound function\n     */\n\n  }, {\n    key: "off",\n    value: function off(message, behaviour) {\n      this._socket.off(message, behaviour);\n\n      collections.removeFromArray(this._listeners, message);\n    } // Remove all listeners.\n\n  }, {\n    key: "offAll",\n    value: function offAll() {\n      var _this = this;\n\n      this._listeners.forEach(function () {\n        return _this._socket.removeAllListeners();\n      });\n\n      this._listeners = [];\n    }\n  }, {\n    key: "dropListenersAndSave",\n    value: function dropListenersAndSave() {\n      var _this2 = this;\n\n      this._listeners.forEach(function (message) {\n        return _this2._socket.off(message, _this2._savedListeners[message]);\n      });\n    }\n  }, {\n    key: "resetListenersFromSave",\n    value: function resetListenersFromSave() {\n      var _this3 = this;\n\n      this._listeners.forEach(function (message) {\n        return _this3._socket.on(message, _this3._savedListeners[message]);\n      });\n    }\n    /**\n     * Join a specific chan.\n     * @param room\n     */\n\n  }, {\n    key: "join",\n    value: function join(room) {\n      // this._socket.join(room);\n      this._rooms.push(room);\n    }\n    /**\n     * Leave a specific chan.\n     * @param room\n     */\n\n  }, {\n    key: "leave",\n    value: function leave(room) {\n      // this._socket.leave(room);\n      // Is there a reason for using rooms?\n      collections.removeFromArray(this._rooms, room);\n    } // Leave all chans this player was connected to.\n\n  }, {\n    key: "leaveAll",\n    value: function leaveAll() {\n      // this._rooms.forEach(room => this._socket.leave(room));\n      this._rooms = [];\n    } // Close connection: removes all listeners.\n\n  }, {\n    key: "close",\n    value: function close() {\n      this.leaveAll();\n      this.offAll();\n    } // Make the object eligible for garbage collection.\n\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      this.close();\n      delete this._socket;\n      delete this._rooms;\n      delete this._listeners;\n    }\n  }, {\n    key: "socket",\n    get: function get() {\n      return this._socket;\n    },\n    set: function set(newSocket) {\n      this.dropListenersAndSave();\n      this._socket = newSocket;\n      this.resetListenersFromSave();\n    }\n  }]);\n\n  return PlayerConnection;\n}();\n\n/* harmony default export */ var player_connection = (player_connection_PlayerConnection);\n// CONCATENATED MODULE: ./server/app/model/game/game.js\n/**\n * Game (instance) model.\n */\n\n\nfunction game_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction game_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction game_createClass(Constructor, protoProps, staticProps) { if (protoProps) game_defineProperties(Constructor.prototype, protoProps); if (staticProps) game_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar game_Game = /*#__PURE__*/function () {\n  function Game(hub, gameId, connector, isServerLocal) {\n    game_classCallCheck(this, Game);\n\n    // Utility parameters.\n    this._hub = hub;\n    this._gameId = gameId;\n    this._jobId = null;\n    this._timeIdleId = null;\n    this._connection = connector; //\n\n    this._kind = null;\n    this._refreshRate = 200;\n    this._isRunning = false;\n    this._ready = false;\n    this._killed = false;\n    this._awaitingJoin = 0; //\n\n    this._playerManager = model_factory.createPlayerManager(); // FF optim\n\n    this._isServerLocal = isServerLocal;\n  } // Model\n\n\n  game_createClass(Game, [{\n    key: "broadcast",\n\n    /** Connection **/\n    // Send a message to ALL connected users.\n    // N.B. encouraged to create custom subchannels within implementations.\n    value: function broadcast(kind, data) {\n      // [PERF] optimize with dynamic subchans?\n      this._connection.io.to(this._gameId).emit(kind, data);\n    }\n    /** Game loop **/\n    // Server-render update function (abstract).\n\n  }, {\n    key: "update",\n    value: function update() {\n      console.log(\'Abstract loop.\');\n    } // Start game loop.\n\n  }, {\n    key: "start",\n    value: function start() {\n      var _this = this;\n\n      // Stop waiting for idle threshold.\n      clearTimeout(this._timeIdleId); // Launch\n\n      this._isRunning = true;\n      console.log(\'[Game] Game running.\'); // When the server is local (on FF), update from pings.\n\n      if (this._isServerLocal) {\n        console.log(\'[Game] Awaiting game pings from sandbox.\');\n      } else {\n        this._jobId = setInterval(function () {\n          _this.update();\n        }, this._refreshRate);\n      }\n    } // Stop game loop.\n\n  }, {\n    key: "pause",\n    value: function pause(doTimeout) {\n      var _this2 = this;\n\n      console.log(\'[Game] Game stopping.\');\n      if (this._jobId !== undefined) clearInterval(this._jobId);\n      this._isRunning = false; // Set idle time limit before despawning this game.\n\n      if (doTimeout) this._timeIdleId = setTimeout(function () {\n        return _this2.stop();\n      }, 30000);\n    }\n    /** Players **/\n\n  }, {\n    key: "hasPlayerForSocket",\n    value: function hasPlayerForSocket(socket) {\n      return this._playerManager.hasPlayerForSocket(socket);\n    }\n  }, {\n    key: "addPlayer",\n    value: function addPlayer(player) {\n      var _this3 = this;\n\n      if (!this._ready) {\n        ++this._awaitingJoin;\n\n        if (this._awaitingJoin < 10) {\n          console.warn(\'[Game] A player tries to join although the game is not ready; retrying in 300ms.\');\n          setTimeout(function () {\n            _this3.addPlayer(player);\n          }, 300);\n        } else {\n          console.error(\'[Game] A player tries to too many times although the game is not ready. Refusing connection.\');\n        }\n\n        return;\n      }\n\n      console.log(\'[Game] A player joined.\');\n      this._awaitingJoin = 0; // Join channel.\n\n      player.join(this.gameId); // Add player to model.\n\n      this._playerManager.addPlayer(player); // Start game if need be.\n\n\n      if (this._isRunning) return;\n      this._isRunning = true; // Double check\n\n      this.start();\n    }\n  }, {\n    key: "removePlayer",\n    value: function removePlayer(player) {\n      console.log(\'[Game] A player left.\'); // Remove from model.\n\n      this._playerManager.removePlayer(player); // Stop game if need be.\n      // if (this._playerManager.nbPlayers > 0 || !this._isRunning) return;\n\n    }\n  }, {\n    key: "removeAllPlayers",\n    value: function removeAllPlayers() {\n      this._playerManager.removeAllPlayers();\n\n      if (this._isRunning) this.pause(true); // Stop with idle timeout.\n    } // Auto-destruction for being idle for too long. Internal use.\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      console.log("Game ".concat(this._gameId, " ended for being idle for too long."));\n\n      this._hub.endGame(this);\n    } // To be triggered from Hub only.\n\n  }, {\n    key: "destroy",\n    value: function destroy() {\n      this._killed = true;\n      if (this._isRunning) this.pause(false); // Going to destroy -> no idle timeout.\n\n      this.removeAllPlayers();\n\n      this._playerManager.destroy();\n\n      delete this._hub;\n      delete this._timeIdleId;\n      delete this._gameId;\n      delete this._jobId;\n      delete this._connection;\n      delete this._kind;\n      delete this._refreshRate;\n      delete this._isRunning;\n    }\n  }, {\n    key: "players",\n    get: function get() {\n      return this._playerManager;\n    }\n  }, {\n    key: "connector",\n    get: function get() {\n      return this._connection;\n    }\n  }, {\n    key: "ready",\n    get: function get() {\n      return this._ready;\n    },\n    set: function set(value) {\n      this._ready = value;\n    }\n  }, {\n    key: "killed",\n    get: function get() {\n      return this._killed;\n    }\n  }, {\n    key: "kind",\n    get: function get() {\n      return this._kind;\n    }\n  }, {\n    key: "gameId",\n    get: function get() {\n      return this._gameId;\n    }\n  }, {\n    key: "isRunning",\n    get: function get() {\n      return this._isRunning;\n    }\n  }]);\n\n  return Game;\n}();\n\n/* harmony default export */ var game_game = (game_Game);\n// CONCATENATED MODULE: ./server/app/engine/game3d/io_user/input/input.js\n/**\n *\n */\n\n\nfunction input_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction input_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction input_createClass(Constructor, protoProps, staticProps) { if (protoProps) input_defineProperties(Constructor.prototype, protoProps); if (staticProps) input_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar UserInput = /*#__PURE__*/function () {\n  function UserInput(game) {\n    input_classCallCheck(this, UserInput);\n\n    this._game = game;\n    this._physicsEngine = game.physicsEngine;\n    this._topologyEngine = game.topologyEngine;\n    this._consistencyEngine = game.consistencyEngine;\n    this._chat = game.chat;\n    this._listeners = {}; // XXX [PERF] Map.\n\n    this._playerUpdateBuffer = [];\n  } // Update change in player connection / disconnection.\n\n\n  input_createClass(UserInput, [{\n    key: "update",\n    value: function update() {\n      var consistencyEngine = this._consistencyEngine;\n      var addedOrRemovedPlayers = this._playerUpdateBuffer; // WARN: short-circuits physics engine update.\n\n      addedOrRemovedPlayers.forEach(function (update) {\n        var type = update[0];\n        var player = update[1]; // Spawn and then listen.\n\n        if (type === \'connect\') {\n          consistencyEngine.spawnPlayer(player); // this.listenPlayer(player); // Done at spawn, in consistency engine\n        } // Despawn.\n        else if (type === \'disconnect\') {\n            // Dispensable to unlisten: a disconnected player has purged its playerConnection.\n            // this.unlistenPlayer(player);\n            consistencyEngine.despawnPlayer(player); // player = playerId\n          }\n      }); // Flush.\n\n      this._playerUpdateBuffer = [];\n    }\n  }, {\n    key: "addPlayer",\n    value: function addPlayer(player) {\n      this._playerUpdateBuffer.push([\'connect\', player]);\n    }\n  }, {\n    key: "removePlayer",\n    value: function removePlayer(playerId) {\n      this._playerUpdateBuffer.push([\'disconnect\', playerId]);\n    }\n  }, {\n    key: "pushToEngine",\n    value: function pushToEngine(kind, avatar, engine) {\n      return function (data) {\n        // [SECURITY] Think about banning users who send too much meta\n        engine.addInput({\n          action: kind,\n          meta: data\n        }, avatar);\n      };\n    }\n  }, {\n    key: "listenPlayer",\n    value: function listenPlayer(player) {\n      var physicsEngine = this._physicsEngine;\n      var topologyEngine = this._topologyEngine;\n      var consistencyEngine = this._consistencyEngine;\n      var avatar = player.avatar;\n      var listener = this._listeners[player] = [this.pushToEngine(\'move\', avatar, physicsEngine), this.pushToEngine(\'rotate\', avatar, physicsEngine), this.pushToEngine(\'block\', avatar, topologyEngine), this.pushToEngine(\'gate\', avatar, consistencyEngine), this.pushToEngine(\'action\', avatar, physicsEngine), this.pushToEngine(\'use\', avatar, physicsEngine), this._chat.playerInput(player)];\n      var i = 0;\n      player.on(\'m\', listener[i++]);\n      player.on(\'r\', listener[i++]);\n      player.on(\'b\', listener[i++]);\n      player.on(\'x\', listener[i++]);\n      player.on(\'a\', listener[i++]);\n      player.on(\'u\', listener[i++]);\n      player.on(\'chat\', listener[i]);\n      player.on(\'leave\', function () {\n        player.leave();\n      });\n    }\n  }, {\n    key: "unlistenPlayer",\n    value: function unlistenPlayer(player) {\n      // Do not modify queue.\n      // Drop inconsistent players when an update is performed.\n      var listener = this._listeners[player];\n\n      if (!listener) {\n        console.log(\'WARN: a player which was not listened to left.\');\n        return;\n      }\n\n      var i = 0;\n      player.off(\'m\', listener[i++]);\n      player.off(\'r\', listener[i++]);\n      player.off(\'b\', listener[i++]);\n      player.off(\'x\', listener[i++]);\n      player.off(\'a\', listener[i++]);\n      player.off(\'chat\', listener[i]);\n      player.off(\'leave\', function () {\n        player.leave();\n      });\n      delete this._listeners[player];\n    }\n  }]);\n\n  return UserInput;\n}();\n\n/* harmony default export */ var input = (UserInput);\n// CONCATENATED MODULE: ./server/app/engine/game3d/io_user/output/output.js\n/**\n *\n */\n // import TimeUtils from \'../../../math/time\';\n\nfunction output_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction output_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction output_createClass(Constructor, protoProps, staticProps) { if (protoProps) output_defineProperties(Constructor.prototype, protoProps); if (staticProps) output_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar UserOutput = /*#__PURE__*/function () {\n  function UserOutput(game) {\n    output_classCallCheck(this, UserOutput);\n\n    this._game = game;\n    this._physicsEngine = game.physicsEngine;\n    this._topologyEngine = game.topologyEngine;\n    this._consistencyEngine = game.consistencyEngine;\n  }\n\n  output_createClass(UserOutput, [{\n    key: "update",\n    // XXX [PERF] -> don\'t recurse over every player, but rather over updates\n    value: function update(updateEntities) {\n      // let t1;\n      // let t2;\n      // t1 = TimeUtils.getTimeSecNano();\n      this.updateChunks(); // t2 = TimeUtils.getTimeSecNano(t1)[1] / 1000;\n      // if (UserOutput.bench && t2 > 1000) console.log(`${t2} s to send chunk updates.`);\n      // t1 = TimeUtils.getTimeSecNano();\n\n      if (updateEntities) this.updateEntities(); // t2 = TimeUtils.getTimeSecNano(t1)[1] / 1000;\n      // if (UserOutput.bench && t2 > 1000) console.log(`${t2} s to send entity updates.`);\n      // t1 = TimeUtils.getTimeSecNano();\n\n      this.updateX(); // t2 = TimeUtils.getTimeSecNano(t1)[1] / 1000;\n      // if (UserOutput.bench && t2 > 1000) console.log(`${t2} s to send x updates.`);\n      // t1 = TimeUtils.getTimeSecNano();\n\n      this.updateMeta(); // t2 = TimeUtils.getTimeSecNano(t1)[1] / 1000;\n      // if (UserOutput.bench && t2 > 1000) console.log(`${t2} s to send other stuff.`);\n\n      this._consistencyEngine.flushBuffers(updateEntities);\n    }\n  }, {\n    key: "updateChunks",\n    value: function updateChunks() {\n      var game = this._game;\n      var topologyEngine = this._topologyEngine;\n      var consistencyEngine = this._consistencyEngine;\n      var updatedChunks = topologyEngine.getOutput();\n      var consistencyOutput = consistencyEngine.getChunkOutput();\n      game.players.forEach(function (p) {\n        if (p.avatar) {\n          var hasNew;\n          var hasUpdated;\n          var pid = p.avatar.entityId; // XXX [PERF] check \'player has updated position\'\n          // player id -> changes (world id -> chunk id -> changes)\n\n          var addedOrRemovedChunks = consistencyOutput.get(pid);\n          hasNew = addedOrRemovedChunks && Object.keys(addedOrRemovedChunks).length > 0;\n          var updatedChunksForPlayer = topologyEngine.getOutputForPlayer(p, updatedChunks, addedOrRemovedChunks);\n          hasUpdated = updatedChunksForPlayer && Object.keys(updatedChunksForPlayer).length > 0; // New chunk + update => bundle updates with new chunks in one call.\n\n          if (hasNew && hasUpdated) {\n            for (var wiA in addedOrRemovedChunks) {\n              if (!addedOrRemovedChunks.hasOwnProperty(wiA)) continue;\n\n              if (wiA in updatedChunksForPlayer) {\n                Object.assign(addedOrRemovedChunks[wiA], updatedChunksForPlayer[wiA]);\n                delete updatedChunksForPlayer[wiA];\n              }\n            }\n\n            Object.assign(addedOrRemovedChunks, updatedChunksForPlayer);\n          }\n\n          if (hasNew) {\n            // Format:\n            // {\n            //  \'worldsMeta\': {worldId:[type, r, cx,cy,cz]} . World metadata\n            //  \'worlds\': {worldId:[x,y,z]} ................. World chunk dimensions\n            //  worldId:\n            //      {chunkId: [fastCC, fastCCId]} ........... Added chunk\n            //      {chunkId: [removed, added, updated]} .... Updated chunk\n            //      {chunkId: null} ......................... Removed chunk\n            // }\n            var output = UserOutput.pack(addedOrRemovedChunks);\n            p.send(\'chk\', output); // XXX [PERF] check if data === []\n            // for (let wiA in addedOrRemovedChunks) console.log(Object.keys(addedOrRemovedChunks[wiA]));\n          } else if (hasUpdated) {\n            // (Format: ditto)\n            // If only an update occurred on an existing, loaded chunk.\n            var _output = UserOutput.pack(updatedChunksForPlayer);\n\n            p.send(\'chk\', _output);\n          }\n        }\n      }); // Empty chunk updates buffer.\n\n      topologyEngine.flushOutput();\n    }\n  }, {\n    key: "updateEntities",\n    value: function updateEntities() {\n      var game = this._game;\n      var physicsEngine = this._physicsEngine;\n      var consistencyEngine = this._consistencyEngine;\n      var updatedEntities = physicsEngine.getOutput();\n      var consistencyOutput = consistencyEngine.getEntityOutput();\n      if (updatedEntities.size < 1 && consistencyOutput.size < 1) return; // Broadcast updates.\n      // XXX [PERF] bundle update in one chunk.\n      // XXX [ENTITIES] ensure sync for player disconnections.\n\n      game.players.forEach(function (p) {\n        var pid = p.avatar.entityId; // If an entity in range of player p has just updated.\n\n        var addedOrRemovedEntities = consistencyOutput.get(pid); // Consistency output SIMULATES UPDATED ENTITIES AS NEW ENTITIES.\n        // Rapidly checked client-side, it prevents from using YET ANOTHER CALL to physicsEngine\n        // and to compute distances between entities.\n        //let updatedEntities = physicsEngine.getOutputForPlayer(p, updatedEntities);\n        // XXX [PERF] detect change in position since the last time.\n        // if (!entities), do it nevertheless, for it gives the player its own position.\n        // Format:\n        // [myPosition, myRotation, {\n        //  entityId:\n        //      null .................. removed entity\n        //      {p: [], r:[], k:\'\'} ... added or updated entity\n        // }]\n        // XXX [PERF] bundle, detect change.\n\n        if (addedOrRemovedEntities && Object.keys(addedOrRemovedEntities).length > 0) p.send(\'ent\', UserOutput.pack(addedOrRemovedEntities));\n        var av = p.avatar;\n        if (!av) return; // Array of [1. position, 2. rotation, 3. worldId] for each world.\n        // First one is the main world.\n\n        var rot = av.rotation;\n        var oldRot = av.oldRotation;\n        var selfState = [[av.position, [rot[0], oldRot[0], rot[2], rot[3]], av.worldId, [// additional states\n        !!av.hit + 0, !!av._isHitting + 0, !!av._loadingRanged + 0, !!av._isParrying + 0]]]; // let otherStates = av.otherWorlds;\n        // otherStates.forEach((state, worldId) => selfState.push([state.position, state.rotation, worldId]));\n\n        p.send(\'me\', UserOutput.pack(selfState));\n        if (av._isHitting) av._isHitting = false;\n      }); // Empty entity updates buffer.\n\n      physicsEngine.flushOutput();\n    }\n  }, {\n    key: "updateX",\n    value: function updateX() {\n      var game = this._game;\n      var consistencyEngine = this._consistencyEngine;\n      var xOutput = consistencyEngine.getXOutput();\n      game.players.forEach(function (p) {\n        var pav = p.avatar;\n        if (!pav) return;\n        var pid = pav.entityId;\n        var addedOrRemovedX = xOutput.get(pid);\n\n        if (addedOrRemovedX && Object.keys(addedOrRemovedX).length > 0) {\n          var output = UserOutput.pack(addedOrRemovedX); // Format:\n          // {portalId:\n          //  null ....................................... removed portal\n          //  [otherId, chunkId, worldId, ...state] ...... new or updated portal\n          // }\n\n          p.send(\'x\', output);\n        }\n      }); // TODO [PORTAL] Implement x updates.\n      // xEngine.flushOutput();\n    }\n  }, {\n    key: "updateMeta",\n    value: function updateMeta() {\n      var game = this._game;\n      game.chat.updateOutput();\n    }\n  }], [{\n    key: "pack",\n    value: function pack(message) {\n      return JSON.stringify(message);\n    }\n  }]);\n\n  return UserOutput;\n}();\n\n_defineProperty(UserOutput, "debug", false);\n\n_defineProperty(UserOutput, "bench", false);\n\n/* harmony default export */ var output = (UserOutput);\n// CONCATENATED MODULE: ./server/app/engine/game3d/io_ai/input/input.js\n/**\n *\n */\n\n\nfunction input_input_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction input_input_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction input_input_createClass(Constructor, protoProps, staticProps) { if (protoProps) input_input_defineProperties(Constructor.prototype, protoProps); if (staticProps) input_input_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar AIInput = /*#__PURE__*/function () {\n  function AIInput(game) {\n    input_input_classCallCheck(this, AIInput);\n\n    this._game = game;\n    this._entityModel = game.entityModel;\n    this._worldModel = game.worldModel;\n  }\n\n  input_input_createClass(AIInput, [{\n    key: "update",\n    value: function update() {// console.log(\'pushing desires to physics\');\n    }\n  }]);\n\n  return AIInput;\n}();\n\n/* harmony default export */ var input_input = (AIInput);\n// CONCATENATED MODULE: ./server/app/engine/game3d/io_ai/output/output.js\n/**\n *\n */\n\n\nfunction output_output_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction output_output_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction output_output_createClass(Constructor, protoProps, staticProps) { if (protoProps) output_output_defineProperties(Constructor.prototype, protoProps); if (staticProps) output_output_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar AIOutput = /*#__PURE__*/function () {\n  function AIOutput(game) {\n    output_output_classCallCheck(this, AIOutput);\n\n    this._game = game;\n    this._entityModel = game.entityModel;\n    this._worldModel = game.worldModel;\n  }\n\n  output_output_createClass(AIOutput, [{\n    key: "update",\n    value: function update() {// console.log(\'giving the world to AI\');\n    }\n  }]);\n\n  return AIOutput;\n}();\n\n/* harmony default export */ var output_output = (AIOutput);\n// CONCATENATED MODULE: ./server/app/engine/game3d/model_world/world.js\n/**\n *\n */\n\n\nfunction world_toConsumableArray(arr) { return world_arrayWithoutHoles(arr) || world_iterableToArray(arr) || world_unsupportedIterableToArray(arr) || world_nonIterableSpread(); }\n\nfunction world_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction world_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return world_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return world_arrayLikeToArray(o, minLen); }\n\nfunction world_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction world_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return world_arrayLikeToArray(arr); }\n\nfunction world_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction world_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction world_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction world_createClass(Constructor, protoProps, staticProps) { if (protoProps) world_defineProperties(Constructor.prototype, protoProps); if (staticProps) world_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar world_World = /*#__PURE__*/function () {\n  function World(id, worldInfo, worldModel) {\n    world_classCallCheck(this, World);\n\n    this._worldId = id; // Identifier\n\n    this._worldModel = worldModel;\n    this._worldInfo = {\n      hills: worldInfo.hills,\n      trees: worldInfo.trees,\n      type: worldInfo.kind,\n      // Only for CubeWorld\n      radius: worldInfo.sideSize,\n      center: {\n        x: 0,\n        y: 0,\n        z: -worldInfo.sideSize\n      }\n    }; // Chunk id (i+\',\'+j+\',\'+k) -> chunk\n\n    this._chunks = new Map();\n    var chunkSizes = worldInfo.chunkSizes || ChunkSizes.CUBE_SMALL; // Constants\n\n    this._xSize = chunkSizes[0] * 2;\n    this._ySize = chunkSizes[1] * 2;\n    this._zSize = chunkSizes[2] * 2;\n\n    if (this._xSize % 2 !== 0 || this._ySize % 2 !== 0 || this._zSize % 2 !== 0) {\n      console.error(\'World creation:chunk sizes must be even.\');\n    }\n\n    this._waitingChunks = [];\n    this._lastQueriedChunk = null;\n  }\n\n  world_createClass(World, [{\n    key: "isFlat",\n    value: function isFlat() {\n      return this._worldInfo.type === model_WorldType.FLAT || this._worldInfo.type === model_WorldType.FANTASY;\n    }\n  }, {\n    key: "pushChunkForGeneration",\n    value: function pushChunkForGeneration(chunkId) {\n      this._waitingChunks.push(chunkId);\n    }\n  }, {\n    key: "getNextChunkForGeneration",\n    value: function getNextChunkForGeneration() {\n      var l = this._waitingChunks.length;\n      if (l < 0) return null;\n      var cid = this._waitingChunks[l - 1];\n      return this._chunks.get(cid);\n    }\n  }, {\n    key: "popChunkForGeneration",\n    value: function popChunkForGeneration() {\n      // const cid =\n      this._waitingChunks.pop(); // if (!cid) return null;\n      // return this._chunks.get(cid);\n\n    }\n  }, {\n    key: "addChunk",\n    value: function addChunk(id, chunk) {\n      this._chunks.set(id, chunk);\n    }\n  }, {\n    key: "getChunkCoordinates",\n    value: function getChunkCoordinates(x, y, z) {\n      var f = Math.floor;\n      var dx = this.xSize;\n      var dy = this.ySize;\n      var dz = this.zSize;\n      return [f(x / dx), f(y / dy), f(z / dz)];\n    }\n  }, {\n    key: "getChunkByCoordinates",\n    value: function getChunkByCoordinates(x, y, z) {\n      var c = this.getChunkCoordinates(x, y, z);\n      return this.getChunk.apply(this, world_toConsumableArray(c));\n    }\n  }, {\n    key: "whatBlock",\n    value: function whatBlock(x, y, z) {\n      var coords = this.getChunkCoordinates(x, y, z);\n      var dx = this.xSize;\n      var dy = this.ySize;\n      var dz = this.zSize;\n      var i = coords[0];\n      var j = coords[1];\n      var k = coords[2];\n      var chunkX = x - i * dx;\n      var chunkY = y - j * dy;\n      var chunkZ = z - k * dz;\n      var chunkId = "".concat(i, ",").concat(j, ",").concat(k);\n      var lastQueried = this._lastQueriedChunk;\n      var chunk = lastQueried && lastQueried.chunkId === chunkId ? lastQueried : this._chunks.get(chunkId);\n\n      if (!chunk || !chunk.blocksReady) {\n        // console.log(\n        //     `ChkMgr@whatBlock: could not find chunk\n        //     ${chunkId} from (${x},${y},${z})!`\n        // );\n        return -1;\n      } else {\n        this._lastQueriedChunk = chunk;\n      }\n\n      return chunk.what(chunkX, chunkY, chunkZ);\n    }\n  }, {\n    key: "getFreePosition",\n    value: function getFreePosition() {\n      // return [-100, 187, 18];\n      var zLimit = this._zSize;\n      var z = zLimit - 2;\n      var centerInteger = Math.trunc(zLimit / 2); // parseInt(zLimit / 2, 10);\n\n      var centerFloat = zLimit / 2 + 0.01; // parseFloat(zLimit / 2) + 0.01;\n\n      var currentBlock = this.whatBlock(centerInteger, centerInteger, z - 1);\n\n      if (currentBlock < 0) {\n        // Chunk not ready yet.\n        return null;\n      }\n\n      var nextBlock;\n\n      while ((currentBlock !== BlockType.AIR || (nextBlock = this.whatBlock(centerInteger, centerInteger, z)) !== 0) && z < 5 * zLimit) // check 2 chunks and abort\n      {\n        ++z;\n        currentBlock = nextBlock;\n      }\n\n      return [centerFloat, centerFloat, z];\n    }\n  }, {\n    key: "getChunk",\n    value: function getChunk(iCoordinate, jCoordinate, kCoordinate) {\n      var id = "".concat(iCoordinate, ",").concat(jCoordinate, ",").concat(kCoordinate);\n      return this._chunks.get(id);\n    }\n  }, {\n    key: "getChunkById",\n    value: function getChunkById(chunkId) {\n      return this._chunks.get(chunkId);\n    }\n  }, {\n    key: "hasChunkById",\n    value: function hasChunkById(chunkId) {\n      return this._chunks.has(chunkId);\n    }\n  }, {\n    key: "hasChunk",\n    value: function hasChunk(i, j, k) {\n      return !!this.getChunk(i, j, k);\n    }\n  }, {\n    key: "isWater",\n    value: function isWater(p0, p1, p2) {\n      var n = this.whatBlock(Math.floor(p0), Math.floor(p1), Math.floor(p2));\n      return n === BlockType.WATER;\n    }\n  }, {\n    key: "isFree",\n    value: function isFree(p0, p1, p2) {\n      var n = this.whatBlock(p0, p1, p2);\n      return n === BlockType.AIR || n === BlockType.WATER; // && this.whatBlock(p[0], p[1], p[2]+1) === 0;\n    }\n  }, {\n    key: "worldId",\n    get: function get() {\n      return this._worldId;\n    } // get worldType() { return this._worldType; }\n\n  }, {\n    key: "worldInfo",\n    get: function get() {\n      return this._worldInfo;\n    }\n  }, {\n    key: "xSize",\n    get: function get() {\n      return this._xSize;\n    }\n  }, {\n    key: "ySize",\n    get: function get() {\n      return this._ySize;\n    }\n  }, {\n    key: "zSize",\n    get: function get() {\n      return this._zSize;\n    }\n  }, {\n    key: "allChunks",\n    get: function get() {\n      return this._chunks;\n    },\n    set: function set(newChunks) {\n      this._chunks = newChunks;\n    }\n  }]);\n\n  return World;\n}();\n\n/* harmony default export */ var model_world_world = (world_World);\n// CONCATENATED MODULE: ./server/app/engine/game3d/model_world/model.js\n/**\n *\n */\n\n\nfunction model_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction model_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction model_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction model_createClass(Constructor, protoProps, staticProps) { if (protoProps) model_defineProperties(Constructor.prototype, protoProps); if (staticProps) model_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar BlockType = Object.freeze({\n  AIR: 0,\n  GRASS: 1,\n  STONE: 2,\n  DIRT: 3,\n  WOOD: 4,\n  PLANKS: 5,\n  STONEBRICKS: 6,\n  BRICKS: 7,\n  LEAVES: 8,\n  WATER: 16,\n  SAND: 17,\n  IRON: 18,\n  OBSIDIAN: 19,\n  ORE_GOLD: 20,\n  ORE_COAL: 21,\n  ORE_DIAMOND: 22,\n  ORE_REDSTONE: 23,\n  WOOL_WHITE: 32,\n  WOOL_GREY: 33,\n  WOOL_CYAN: 34,\n  WOOL_ORANGE: 35,\n  WOOL_DARK_PURPLE: 36,\n  WOOL_LIGHT_PURPLE: 37,\n  WOOL_DARK_BLUE: 38,\n  WOOL_LIGHT_BLUE: 39,\n  WOOL_BROWN: 40,\n  WOOL_YELLOW: 41,\n  WOOL_DARK_GREEN: 42,\n  WOOL_LIGHT_GREEN: 43,\n  WOOL_RED: 44,\n  WOOL_ROSE: 45,\n  WOOL_BLACK: 46,\n  WOOL_DARK_GREY: 47,\n  LAPIS: 48,\n  SPONGE: 49,\n  BEDROCK: 50,\n  MOSSY_STONE: 51,\n  CRACKED_STONE: 52,\n  ENDER: 53,\n  NETHER: 54,\n  DIAMOND: 55,\n  GOLD: 56\n});\nvar model_WorldType = Object.freeze({\n  FLAT: 0,\n  CUBE: 1,\n  SHRIKE: 2,\n  UNSTRUCTURED: 3,\n  FANTASY: 4\n});\nvar HillType = Object.freeze({\n  NO_HILLS: 0,\n  REGULAR_HILLS: 1,\n  GIANT_HILLS: 2,\n  ERODED: 3,\n  SPIKES: 4\n});\nvar TreeType = Object.freeze({\n  NO_TREES: 0,\n  SOME_TREES: 1\n});\nvar ChunkSizes = Object.freeze({\n  CUBE_VERY_SMALL: [2, 2, 2],\n  CUBE_SMALL: [4, 4, 4],\n  CUBE_REGULAR: [8, 8, 8],\n  CUBE_HUGE: [16, 16, 16],\n  FLAT_SMALL: [8, 8, 16],\n  FLAT_REGULAR: [16, 16, 16],\n  FLAT_HUGE: [32, 32, 64]\n});\n\nvar BlockTypes = /*#__PURE__*/function () {\n  function BlockTypes() {\n    model_classCallCheck(this, BlockTypes);\n  }\n\n  model_createClass(BlockTypes, null, [{\n    key: "isBlock",\n    value: function isBlock(id) {\n      return id !== BlockType.AIR && (id >= BlockType.GRASS && id <= BlockType.BRICKS || id >= BlockType.SAND && id <= BlockType.IRON);\n    }\n  }]);\n\n  return BlockTypes;\n}();\n\nvar model_WorldModel = /*#__PURE__*/function () {\n  function WorldModel(game) {\n    model_classCallCheck(this, WorldModel);\n\n    this._game = game;\n    this._worlds = new Map();\n    var masterWorldInfo = this.generateWorldInfoFromGameInfo(-1);\n\n    this._worlds.set(-1, new model_world_world(-1, masterWorldInfo, this));\n  }\n\n  model_createClass(WorldModel, [{\n    key: "addWorld",\n    value: function addWorld(worldId) {\n      var wid = worldId || collections.generateId(this._worlds);\n      if (this._worlds.has(wid)) return;\n      var newWorldInfo = this.generateWorldInfoFromGameInfo(wid);\n      var w = new model_world_world(wid, newWorldInfo, this);\n\n      this._worlds.set(wid, w);\n\n      return w;\n    }\n  }, {\n    key: "getWorld",\n    value: function getWorld(worldId) {\n      if (!worldId) worldId = -1;\n      return this._worlds.get(worldId);\n    }\n  }, {\n    key: "getFreeWorld",\n    value: function getFreeWorld() {\n      return this.getWorld(-1);\n    }\n  }, {\n    key: "generateWorldInfoFromGameInfo",\n    value: function generateWorldInfoFromGameInfo(worldId) {\n      var worldInfo = {};\n      var gameInfo = this._game.gameInfo;\n      var gk = gameInfo.kind;\n      var wk = model_WorldType.FLAT;\n\n      switch (gk) {\n        case GameType.DEMO:\n          var wid = parseInt(worldId, 10);\n\n          if (wid === 2) {\n            return {\n              kind: model_WorldType.CUBE,\n              sideSize: 4,\n              hills: HillType.NO_HILLS,\n              trees: TreeType.NO_TREES\n            };\n          } else if (wid === 3) {\n            return {\n              kind: model_WorldType.CUBE,\n              sideSize: 16,\n              hills: HillType.REGULAR_HILLS,\n              trees: TreeType.NO_TREES\n            };\n          } else {\n            wk = model_WorldType.FLAT;\n            gameInfo.trees = TreeType.SOME_TREES;\n          }\n\n          break;\n\n        case GameType.FLAT:\n          wk = model_WorldType.FLAT;\n          break;\n\n        case GameType.FANTASY:\n          wk = model_WorldType.FANTASY;\n          break;\n\n        case GameType.CUBE:\n          wk = model_WorldType.CUBE;\n          break;\n\n        case GameType.UNSTRUCTURED:\n        default:\n          console.error(\'[Server/Model] Unsupported game type.\');\n          return;\n      }\n\n      worldInfo.kind = wk;\n\n      switch (wk) {\n        case model_WorldType.CUBE:\n          switch (gameInfo.threeHillsType) {\n            case 0:\n              worldInfo.hills = HillType.NO_HILLS;\n              break;\n\n            case 1:\n              worldInfo.hills = HillType.REGULAR_HILLS;\n              break;\n\n            default:\n              break;\n          }\n\n          worldInfo.sideSize = parseInt(gameInfo.size, 10);\n          worldInfo.trees = TreeType.NO_TREES;\n          worldInfo.chunkSizes = ChunkSizes.CUBE_REGULAR;\n          break;\n\n        case model_WorldType.FLAT:\n          worldInfo.kind = model_WorldType.FLAT;\n\n          switch (gameInfo.flatHillsType) {\n            case 0:\n              worldInfo.hills = HillType.NO_HILLS;\n              break;\n\n            case 1:\n              worldInfo.hills = HillType.REGULAR_HILLS;\n              break;\n\n            case 2:\n              worldInfo.hills = HillType.GIANT_HILLS;\n              break;\n\n            case 3:\n              worldInfo.hills = HillType.ERODED;\n              break;\n\n            case 4:\n              worldInfo.hills = HillType.SPIKES;\n              break;\n\n            default:\n              break;\n          }\n\n          switch (gameInfo.trees) {\n            case 0:\n              worldInfo.trees = TreeType.NO_TREES;\n              break;\n\n            case 1:\n              worldInfo.trees = TreeType.SOME_TREES;\n              break;\n\n            default:\n              break;\n          }\n\n          worldInfo.sideSize = -1; // infinite flat world\n\n          worldInfo.chunkSizes = ChunkSizes.FLAT_REGULAR;\n          break;\n\n        case model_WorldType.FANTASY:\n          worldInfo.kind = model_WorldType.FANTASY;\n          worldInfo.sideSize = -1; // infinite flat world\n\n          worldInfo.chunkSizes = ChunkSizes.FLAT_REGULAR;\n          break;\n\n        case model_WorldType.SHRIKE:\n        case model_WorldType.UNSTRUCTURED:\n        default:\n          console.error(\'[Server/Model] Unsupported world type.\');\n          return;\n      }\n\n      return worldInfo;\n    }\n  }, {\n    key: "worlds",\n    get: function get() {\n      return this._worlds;\n    }\n  }]);\n\n  return WorldModel;\n}();\n\nmodel_defineProperty(model_WorldModel, "serverLoadingRadius", 6);\n\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/io_ai/ai.js\n/**\n *\n */\n\n\nfunction ai_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction ai_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction ai_createClass(Constructor, protoProps, staticProps) { if (protoProps) ai_defineProperties(Constructor.prototype, protoProps); if (staticProps) ai_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar ai_AI = /*#__PURE__*/function () {\n  function AI(game) {\n    ai_classCallCheck(this, AI);\n\n    this._game = game;\n    this._entityModel = game.entityModel;\n    this._worldModel = game.worldModel; // this._xModel        = game.xModel;\n\n    this._ais = [];\n    this._maxAis = 20;\n    this._needingPath = [];\n    this._cycle = 1;\n    this._cycleLength = 10000;\n    this._projectilesNeedingSpawn = [];\n    this._projectilesNeedingDespawn = [];\n  }\n\n  ai_createClass(AI, [{\n    key: "update",\n    value: function update() {\n      var nc = (this._cycle + 1) % this._cycleLength;\n      this._cycle = nc; // console.log(\'seeing, thinking, acting\');\n\n      this.despawnProjectiles();\n      this.spawnAI(nc);\n      this.aggroPass(nc);\n      this.pathFindingPass(nc);\n      this.actionPass(nc);\n      this.magnusPass();\n      this.spawnProjectiles();\n    }\n  }, {\n    key: "despawnProjectiles",\n    value: function despawnProjectiles() {\n      var despawn = this._projectilesNeedingDespawn;\n\n      if (despawn.length > 0) {\n        for (var i = 0; i < despawn.length; ++i) {\n          var eid = despawn.pop();\n          var ce = this._game.consistencyEngine;\n          ce.despawnEntity(eid);\n        }\n      }\n    }\n  }, {\n    key: "spawnProjectiles",\n    value: function spawnProjectiles() {\n      var pns = this._projectilesNeedingSpawn;\n      var l = pns.length;\n\n      if (l > 0) {\n        var ce = this._game.consistencyEngine;\n\n        for (var i = 0; i < Math.min(10, l); ++i) {\n          var p = pns.pop();\n          var wid = p[6];\n          var power = Math.min(p[7] / 60, 2); // const wx = p[7];\n          // const wy = p[8];\n          // const wz = p[9];\n\n          var world = this._worldModel.getWorld(wid); // let solver = this._game.physicsEngine._frontend._rigidBodies;\n          // let g = solver.getGravity(world, wid, p[0], p[1], p[2]);\n\n\n          var a1 = p[8];\n          var a2 = p[9];\n          var a3 = p[10];\n          var norm = a1 * a1 + a2 * a2 + a3 * a3;\n          if (norm === 0) continue;\n          norm = Math.sqrt(norm);\n          a1 /= norm;\n          a2 /= norm;\n          a3 /= norm;\n          var b1 = p[3];\n          var b2 = p[4];\n          var b3 = p[5];\n          var crossX = a2 * b3 - a3 * b2;\n          var crossY = a3 * b1 - a1 * b3;\n          var crossZ = a1 * b2 - a2 * b1;\n          var projectile = ce.spawnEntity(\'projectile\', world, [p[0] - 0.1 * crossX + 0.5 * p[3], p[1] - 0.1 * crossY + 0.5 * p[4], p[2] - 0.1 * crossZ + 0.5 * p[5]]);\n          projectile.a0[0] = power * 4 * p[3];\n          projectile.a0[1] = power * 4 * p[4];\n          projectile.a0[2] = power * 4 * p[5]; // projectile.v0[0] = 1 * power * 0.5 * p[3];\n          // projectile.v0[1] = 1 * power * 0.5 * p[4];\n          // projectile.v0[2] = 1 * power * 0.5 * p[5];\n        }\n      }\n    }\n  }, {\n    key: "magnusPass",\n    value: function magnusPass() {} // To alter projectiles trajectory\n    // Random spawn an IA around a player\n\n  }, {\n    key: "spawnAI",\n    value: function spawnAI(cycle) {\n      var nbAIs = this._ais.length;\n      var maxNbAIs = this._maxAis;\n\n      if (nbAIs < maxNbAIs) {\n        if (cycle % 600 === 0 && Math.random() > 0.5) {\n          var avatar = this._game.players.getRandomPlayer();\n\n          if (!avatar) {\n            console.warn(\'[AI] An inconsistent player.\');\n            return;\n          }\n\n          var p = avatar.p0;\n          var wid = avatar.worldId;\n\n          var world = this._worldModel.getWorld(wid);\n\n          if (!world) {\n            console.warn(\'[AI] An inconsistent world.\');\n            return;\n          } else if (world.worldInfo.type === model_WorldType.CUBE) {\n            // IA unsupported.\n            return;\n          }\n\n          var xTest;\n          var yTest;\n          var zTest;\n          var isFree = false;\n          var attempt = 0;\n          var maxAttempts = 5;\n\n          do {\n            var xo = Math.random() - 0.5;\n            var yo = Math.random() - 0.5;\n            xTest = Math.floor(p[0] + 10 * xo + 5 * Math.sign(xo));\n            yTest = Math.floor(p[1] + 10 * yo + 5 * Math.sign(yo));\n            zTest = Math.floor(p[2] + 2);\n            ++attempt;\n            isFree = world.isFree(xTest, yTest, zTest) && world.isFree(xTest, yTest, zTest + 1);\n          } while (!isFree && attempt < maxAttempts);\n\n          if (isFree) {\n            var ce = this._game.consistencyEngine;\n            var newAI = ce.spawnEntity(\'walker\', world, [xTest + 0.5, yTest + 0.5, zTest + 1.0]);\n            newAI.aggro = avatar;\n            newAI.captain = avatar;\n            newAI.target = p; // Move toward avatar.\n\n            this._ais.push(newAI);\n          } else {\n            console.log(\'Failed spawning an entity.\');\n          }\n        }\n      }\n    }\n  }, {\n    key: "aggroPass",\n    value: function aggroPass() {// XXX [IA] see and trigger aggro\n    }\n  }, {\n    key: "pathFindingPass",\n    value: function pathFindingPass() {\n      var anEntityNeedsPathFinding = this._needingPath.length > 0;\n\n      if (anEntityNeedsPathFinding) {// Get aggro\n        // let currentEntity = this._needingPath.pop();\n        // XXX [IA] path finding\n      }\n    }\n  }, {\n    key: "actionPass",\n    value: function actionPass() {\n      this._ais.forEach(function (ai) {\n        ai.age();\n\n        if (ai.howLongSinceLastDecision() > 300) {\n          // Bump entity clock\n          ai.takeDecision(); // Follow player\n\n          var aggro = ai.aggro;\n\n          if (aggro && aggro.p0) {\n            ai.target = aggro.p0;\n          } // Random movement.\n          // let oldTarget = ai.target;\n          // ai.target = [\n          //     oldTarget[0] + Math.floor(10 * (Math.random() - 0.5)),\n          //     oldTarget[1] + Math.floor(10 * (Math.random() - 0.5)),\n          //     oldTarget[2],\n          // ];\n\n        }\n\n        var p = ai.p0;\n        var d = ai.target;\n\n        if (!d || !p) {\n          console.log(\'[IA] No entity target (or position).\');\n          return; // to next entity\n        } // Rotate toward player.\n\n\n        var dx = d[0] - p[0];\n        var dy = d[1] - p[1]; // let newPitch = Math.atan2(dx, -dy);\n        // Move toward player.\n\n        var dz = d[2] - p[2];\n        if (dz > 0.5) ai.goUp();else ai.stopUp();\n        var r = ai.rotation;\n        var newPitch = Math.atan2(dy, dx) - Math.PI / 2;\n        ai.rotate(newPitch, r[1], r[2], r[3]);\n        if (dx * dx + dy * dy > 4) ai.goForward();else ai.stopForward(); // if (dx < -0.5) ai.goForward();\n        // else if (dx > 0.5) ai.goBackwards();\n        // if (dy < -0.5) ai.goRight();\n        // else if (dy > 0.5) ai.goLeft();\n        // if (dz < -0.5) ai.goUp(); // Jumps?\n        // else if (dz > 0.5) ai.goDown(); // Digs??\n      });\n    }\n  }, {\n    key: "pushProjectileForSpawn",\n    value: function pushProjectileForSpawn(projectile) {\n      this._projectilesNeedingSpawn.push(projectile);\n    }\n  }, {\n    key: "pushProjectileForDespawn",\n    value: function pushProjectileForDespawn(id) {\n      this._projectilesNeedingDespawn.push(id);\n    }\n  }]);\n\n  return AI;\n}();\n\n/* harmony default export */ var ai = (ai_AI);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_physics/input_buffer.js\n/**\n * Manage entity inputs.\n */\n\n\nfunction input_buffer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction input_buffer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction input_buffer_createClass(Constructor, protoProps, staticProps) { if (protoProps) input_buffer_defineProperties(Constructor.prototype, protoProps); if (staticProps) input_buffer_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar InputBuffer = /*#__PURE__*/function () {\n  function InputBuffer() {\n    input_buffer_classCallCheck(this, InputBuffer);\n\n    this._buffer = new Map();\n  }\n\n  input_buffer_createClass(InputBuffer, [{\n    key: "addInput",\n    value: function addInput(meta, avatar) {\n      var array = this._buffer.get(avatar);\n\n      if (!array) this._buffer.set(avatar, [meta]);else array.push(meta);\n    }\n  }, {\n    key: "getInput",\n    value: function getInput() {\n      return this._buffer;\n    }\n  }, {\n    key: "flush",\n    value: function flush() {\n      this._buffer = new Map();\n    }\n  }]);\n\n  return InputBuffer;\n}();\n\n/* harmony default export */ var input_buffer = (InputBuffer);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_physics/output_buffer.js\n/**\n * Aggregate entity updates.\n */\n\n\nfunction output_buffer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction output_buffer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction output_buffer_createClass(Constructor, protoProps, staticProps) { if (protoProps) output_buffer_defineProperties(Constructor.prototype, protoProps); if (staticProps) output_buffer_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar OutputBuffer = /*#__PURE__*/function () {\n  function OutputBuffer() {\n    output_buffer_classCallCheck(this, OutputBuffer);\n\n    // Contains ids of updated entities.\n    this._buffer = new Set();\n  }\n\n  output_buffer_createClass(OutputBuffer, [{\n    key: "entityUpdated",\n    value: function entityUpdated(entityId) {\n      this._buffer.add(entityId);\n    } // Shallow.\n\n  }, {\n    key: "getOutput",\n    value: function getOutput() {\n      return new Set(this._buffer);\n    }\n  }, {\n    key: "flushOutput",\n    value: function flushOutput() {\n      this._buffer = new Set();\n    }\n  }]);\n\n  return OutputBuffer;\n}();\n\n/* harmony default export */ var output_buffer = (OutputBuffer);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_physics/solver/collision/searcher.js\n/**\n *\n */\n\n/**\n * How to use:\n *\n * // Start with:\n * let s = new Searcher(em, x, y, z);\n * s.initObjects(objects);\n *\n * // Whenever sth. moves:\n * s.updateObjectAxis(object.index);\n *\n */\n\nfunction searcher_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction searcher_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction searcher_createClass(Constructor, protoProps, staticProps) { if (protoProps) searcher_defineProperties(Constructor.prototype, protoProps); if (staticProps) searcher_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Searcher = /*#__PURE__*/function () {\n  // Fast intern. math. util.\n  // No getters/setters.\n  function Searcher(entities, axisX, axisY, axisZ) {\n    searcher_classCallCheck(this, Searcher);\n\n    this.entities = entities;\n    this.objectsAxisX = axisX;\n    this.objectsAxisY = axisY;\n    this.objectsAxisZ = axisZ;\n  }\n\n  searcher_createClass(Searcher, [{\n    key: "updateObjectAxis",\n    value: function updateObjectAxis(entityId) {\n      var axisX = this.objectsAxisX;\n      var axisY = this.objectsAxisY;\n      var axisZ = this.objectsAxisZ;\n      var objects = this.entities;\n      var object = objects[entityId];\n      var length = axisX.length;\n      var p = object.p0;\n      var x = p[0];\n      var y = p[1];\n      var z = p[2];\n      var iXl = object.indexX - 1;\n      var iXr = object.indexX + 1;\n      var iYl = object.indexY - 1;\n      var iYr = object.indexY + 1;\n      var iZl = object.indexZ - 1;\n      var iZr = object.indexZ + 1;\n      var hasSwapped = false;\n\n      var log =\n      /*axis*/\n      function log() {\n        //console.log(\'\\tswap performed on axis \' + axis);\n        hasSwapped = true;\n      }; // Resort left X.\n\n\n      while (iXl > -1 && objects[axisX[iXl].id].p0[0] > x) {\n        log(\'x-\');\n        this.swap(axisX, iXl, iXl + 1);\n        --iXl;\n      } // Resort right X.\n\n\n      while (iXr < length && objects[axisX[iXr].id].p0[0] < x) {\n        log(\'x+\');\n        this.swap(axisX, iXr, iXr - 1);\n        ++iXr;\n      } // Resort left Y.\n\n\n      while (iYl > -1 && objects[axisY[iYl].id].p0[1] > y) {\n        log(\'y-\');\n        this.swap(axisY, iYl, iYl + 1);\n        --iYl;\n      } // Resort right Y.\n\n\n      while (iYr < length && objects[axisY[iYr].id].p0[1] < y) {\n        log(\'y+\');\n        this.swap(axisY, iYr, iYr - 1);\n        ++iYr;\n      } // Resort left Z.\n\n\n      while (iZl > -1 && objects[axisZ[iZl].id].p0[2] > z) {\n        log(\'z-\');\n        this.swap(axisZ, iZl, iZl + 1);\n        --iZl;\n      } // Resort right Z.\n\n\n      while (iZr < length && objects[axisZ[iZr].id].p0[2] < z) {\n        log(\'z+\');\n        this.swap(axisZ, iZr, iZr - 1);\n        ++iZr;\n      }\n\n      if (hasSwapped) {//console.log(\'Updated object axis for \' + entityId);\n        //console.log(this.objectsAxisX);\n      }\n    }\n  }, {\n    key: "swap",\n    // XXX [PERF] distinguish between \'e\' and \'x\'\n    value: function swap(axisArray, i, j) {\n      var objects = this.entities;\n      Searcher.SWP(axisArray, i, j);\n\n      if (axisArray === this.objectsAxisX) {\n        objects[axisArray[i].id].indexX = i;\n        objects[axisArray[j].id].indexX = j;\n      } else if (axisArray === this.objectsAxisY) {\n        objects[axisArray[i].id].indexY = i;\n        objects[axisArray[j].id].indexY = j;\n      } else if (axisArray === this.objectsAxisZ) {\n        objects[axisArray[i].id].indexZ = i;\n        objects[axisArray[j].id].indexZ = j;\n      }\n    }\n  }, {\n    key: "initObjects",\n    value: function initObjects(objects) {\n      this.entities = objects;\n      var axisX = this.objectsAxisX;\n      var axisY = this.objectsAxisY;\n      var axisZ = this.objectsAxisZ; // Init objects order on every axis.\n\n      for (var i = 0; i < objects.length; ++i) {\n        axisX[i] = i;\n        axisY[i] = i;\n        axisZ[i] = i;\n      }\n\n      axisX.sort(function (a, b) {\n        if (objects[a].p0[0] < objects[b].p0[0]) return -1;else if (objects[a].p0[0] > objects[b].p0[0]) return 1;else return 0;\n      });\n      axisY.sort(function (a, b) {\n        if (objects[a].p0[1] < objects[b].p0[1]) return -1;else if (objects[a].p0[1] > objects[b].p0[1]) return 1;else return 0;\n      });\n      axisZ.sort(function (a, b) {\n        if (objects[a].p0[2] < objects[b].p0[2]) return -1;else if (objects[a].p0[2] > objects[b].p0[2]) return 1;else return 0;\n      }); // Init object indices on every axis.\n\n      var numberOfObjects = objects.length;\n\n      for (var _i = 0; _i < numberOfObjects; ++_i) {\n        objects[axisX[_i]].indexX = _i;\n        objects[axisY[_i]].indexY = _i;\n        objects[axisZ[_i]].indexZ = _i;\n      }\n    } // Works with x axis\n\n  }, {\n    key: "computeIsland",\n    value: function computeIsland(lArray, index) {\n      var threshAndIndex = lArray[index];\n      var tx = threshAndIndex[0];\n      var ty = threshAndIndex[1];\n      var tz = threshAndIndex[2];\n      var entityIndexX = threshAndIndex[3];\n      var xAxisIsland = [entityIndexX];\n      var iterator;\n\n      try {\n        iterator = new ObjectsIterator(this, entityIndexX, tx, ty, tz);\n      } catch (e) {\n        console.error(\'Could not create object iterator.\');\n        return [];\n      }\n\n      var element = iterator.next(); // let it = 0;\n      // console.log(\'Begin search.\');\n\n      while (element !== null && element !== undefined) {\n        var iX = element.indexX; // console.log("\\tIteration " + (++it) + " resulting in " + iX);\n\n        xAxisIsland.push(iX);\n        element = iterator.next();\n      } // console.log(\'End search.\');\n\n\n      return xAxisIsland;\n    }\n  }], [{\n    key: "SWP",\n    value: function SWP(array, i, j) {\n      var t = array[i];\n      array[i] = array[j];\n      array[j] = t;\n      return array;\n    }\n  }]);\n\n  return Searcher;\n}();\n/**\n * How to use:\n *\n * let iterator = new ObjectsIterator(searcher, object.index, howFarToSearch);\n * while ((let you = iterator.next()) != null) {\n *     // Do stuff with next element (i.e. collide)\n * }\n *\n */\n\n\nvar ObjectsIterator = /*#__PURE__*/function () {\n  function ObjectsIterator(searcher, objectIndexX, thresholdX, thresholdY, thresholdZ) {\n    searcher_classCallCheck(this, ObjectsIterator);\n\n    this.axisX = searcher.objectsAxisX;\n    this.axisY = searcher.objectsAxisY;\n    this.axisZ = searcher.objectsAxisZ;\n    this.objects = searcher.entities;\n    var objects = this.objects;\n    var obj = this.axisX[objectIndexX];\n    if (!obj) throw Error(\'[ObjectsIterator]: invalid initialization.\');\n    var objectIndex = obj.id;\n    this.object = objects[objectIndex];\n    var o = this.object;\n    this.x = o.p0[0];\n    var xW = o.widthX;\n    this.y = o.p0[1];\n    var yW = o.widthY;\n    this.z = o.p0[2];\n    var zW = o.widthZ;\n\n    if (objectIndexX !== o.indexX) {\n      throw Error(\'[Searcher] Mismatch between \' + \'transmitted indexX and the object\\\'s x index.\');\n    }\n\n    this.iX = o.indexX;\n    this.iY = o.indexY;\n    this.iZ = o.indexZ; // Others not moving faster than current.\n\n    var abs = Math.abs;\n    var maxT = Math.max(abs(thresholdX), abs(thresholdY), abs(thresholdZ));\n    this.tx = abs(thresholdX) + maxT + 4 * xW;\n    this.ty = abs(thresholdY) + maxT + 4 * yW;\n    this.tz = abs(thresholdZ) + maxT + 4 * zW; // XXX [ENTITIES] account for max width when objects are huge.\n\n    this.onX = true;\n    this.onY = false;\n    this.onZ = false;\n    this.step = 1;\n    this.stack = 0;\n    this.toPlus = true;\n    this.done = new Set();\n    this.locked = [!1, !1, !1, !1, !1, !1];\n  }\n\n  searcher_createClass(ObjectsIterator, [{\n    key: "finalize",\n    value: function finalize() {\n      // console.log("\\t\\tstack: " + this.stack + ", depth: " + this.step);\n      this.step = 1;\n      this.stack = 0;\n      this.toPlus = true;\n      this.onX = true;\n      this.onY = false;\n      this.onZ = false;\n      this.done = new Set(); // Do not reinit population!\n\n      this.locked = [!1, !1, !1, !1, !1, !1];\n    }\n  }, {\n    key: "next",\n    value: function next(indexLocked) {\n      this.stack++;\n\n      if (this.stack > 100) {\n        console.log("EXPT: stack ".concat(this.stack, ", depth ").concat(this.step));\n        console.log(this.locked);\n        this.finalize();\n        throw Error(\'Exploded stack\');\n      }\n\n      if (indexLocked % 2 === 0) {\n        var l = this.locked;\n\n        if (l[indexLocked] && l[indexLocked + 1]) {\n          this.finalize();\n          return null;\n        }\n      }\n\n      var abs = Math.abs;\n      var objects = this.objects;\n      var axisX = this.axisX;\n      var axisY = this.axisY;\n      var axisZ = this.axisZ;\n      var x = this.x;\n      var iX = this.iX;\n      var tx = this.tx;\n      var y = this.y;\n      var iY = this.iY;\n      var ty = this.ty;\n      var z = this.z;\n      var iZ = this.iZ;\n      var tz = this.tz;\n      var max = axisX.length;\n      var s = this.step;\n      var onX = this.onX;\n      var toPlus = this.toPlus;\n      var done = this.done;\n      var locked = this.locked;\n\n      var debugObject = function debugObject(id) {\n        if (!objects[id]) throw Error("[Searcher] Couldn\\u2019t find object ".concat(id));\n      };\n\n      if (done.size >= axisX.length - 1) {\n        this.finalize();\n        return null;\n      } // Search on X axis.\n\n\n      if (onX && toPlus && !locked[0]) {\n        //console.log(\'\\t\\tx+\');\n        if (iX + s >= max) {\n          locked[0] = true;\n          this.toPlus = false;\n          return this.next(0);\n        } // XXX [PERF] replace id with indexX\n\n\n        var id = axisX[iX + s].id;\n\n        if (done.has(id)) {\n          this.toPlus = false;\n          return this.next();\n        } else done.add(id);\n\n        debugObject(id);\n        var object = objects[id];\n\n        if (abs(object.p0[0] - x) <= tx) {\n          // XXX [PERF] use lfarray instead of tx\n          if (abs(object.p0[1] - y) <= ty && abs(object.p0[2] - z) <= tz) return object;else {\n            return this.next();\n          }\n        } else {\n          locked[0] = true;\n          this.toPlus = false;\n          return this.next(0);\n        }\n      }\n\n      if (onX && !toPlus && !locked[1]) {\n        //console.log(\'\\t\\tx-\');\n        if (iX - s < 0) {\n          locked[1] = true;\n          this.toPlus = true;\n          this.onX = false;\n          this.onY = true;\n          return this.next(0);\n        }\n\n        var _id = axisX[iX - s].id;\n\n        if (done.has(_id)) {\n          this.toPlus = true;\n          this.onX = false;\n          this.onY = true;\n          return this.next();\n        } else done.add(_id);\n\n        debugObject(_id);\n        var _object = objects[_id]; // console.log(x + \',\' + object.p0[0] + \' < - > \' + tx);\n\n        if (abs(_object.p0[0] - x) <= tx) {\n          if (abs(_object.p0[1] - y) <= ty && abs(_object.p0[2] - z) <= tz) return _object;else return this.next();\n        } else {\n          locked[1] = true;\n          this.toPlus = true;\n          this.onX = false;\n          this.onY = true;\n          return this.next(0);\n        }\n      } // Search on Y axis.\n\n\n      var onY = this.onY;\n\n      if (onY && toPlus && !locked[2]) {\n        // console.log(\'\\t\\ty+\');\n        if (iY + s >= max) {\n          locked[2] = true;\n          this.toPlus = false;\n          return this.next(2);\n        }\n\n        var _id2 = axisY[iY + s].id;\n\n        if (done.has(_id2)) {\n          this.toPlus = false;\n          return this.next();\n        } else done.add(_id2);\n\n        debugObject(_id2);\n        var _object2 = objects[_id2];\n\n        if (abs(_object2.p0[1] - y) <= ty) {\n          if (abs(_object2.p0[0] - x) <= tx && abs(_object2.p0[2] - z) <= tz) return _object2;else return this.next();\n        } else {\n          locked[2] = true;\n          this.toPlus = false;\n          return this.next(2);\n        }\n      }\n\n      if (onY && !toPlus && !locked[3]) {\n        if (iY - s < 0) {\n          locked[3] = true;\n          this.toPlus = true;\n          this.onY = false;\n          this.onZ = true;\n          return this.next(2);\n        }\n\n        var _id3 = axisY[iY - s].id;\n\n        if (done.has(_id3)) {\n          this.toPlus = true;\n          this.onY = false;\n          this.onZ = true;\n          return this.next();\n        } else done.add(_id3);\n\n        debugObject(_id3);\n        var _object3 = objects[_id3];\n\n        if (abs(_object3.p0[1] - y) <= ty) {\n          if (abs(_object3.p0[0] - x) <= tx && abs(_object3.p0[2] - z) <= tz) return _object3;else return this.next();\n        } else {\n          locked[3] = true;\n          this.toPlus = true;\n          this.onY = false;\n          this.onZ = true;\n          return this.next(2);\n        }\n      }\n\n      var onZ = this.onZ;\n\n      if (onZ && toPlus && !locked[4]) {\n        if (iZ + s >= max) {\n          locked[4] = true;\n          this.toPlus = false;\n          return this.next(4);\n        }\n\n        var _id4 = axisZ[iZ + s].id;\n\n        if (done.has(_id4)) {\n          this.toPlus = false;\n          return this.next();\n        } else done.add(_id4);\n\n        debugObject(_id4);\n        var _object4 = objects[_id4];\n\n        if (abs(_object4.p0[2] - z) <= tz) {\n          if (abs(_object4.p0[0] - x) <= tx && abs(_object4.p0[1] - y) <= ty) return _object4;else return this.next();\n        } else {\n          locked[4] = true;\n          this.toPlus = false;\n          return this.next(4);\n        }\n      }\n\n      if (onZ && !toPlus && !locked[5]) {\n        if (iZ - s < 0) {\n          locked[5] = true;\n          this.toPlus = true;\n          this.onX = true;\n          this.onZ = false;\n          this.step++;\n          return this.next(4);\n        }\n\n        var _id5 = axisZ[iZ - s].id;\n\n        if (done.has(_id5)) {\n          this.toPlus = true;\n          this.onX = true;\n          this.onZ = false;\n          this.step++;\n          return this.next();\n        } else done.add(_id5);\n\n        debugObject(_id5);\n        var _object5 = objects[_id5];\n\n        if (abs(_object5.p0[2] - z) <= tz) {\n          if (abs(_object5.p0[0] - x) <= tx && abs(_object5.p0[1] - y) <= ty) return _object5;else return this.next();\n        } else {\n          locked[5] = true;\n          this.toPlus = true;\n          this.onX = true;\n          this.onZ = false;\n          this.step++;\n          return this.next(4);\n        }\n      }\n    }\n  }]);\n\n  return ObjectsIterator;\n}();\n\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_physics/solver/rigid_bodies/orderer_events.js\n/**\n *\n */\n // import ObjectOrderer from \'./orderer_objects\';\n\n/**\n * @deprecated\n */\n\nfunction orderer_events_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction orderer_events_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction orderer_events_createClass(Constructor, protoProps, staticProps) { if (protoProps) orderer_events_defineProperties(Constructor.prototype, protoProps); if (staticProps) orderer_events_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction orderer_events_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar EventOrderer = /*#__PURE__*/function () {\n  function EventOrderer() {\n    orderer_events_classCallCheck(this, EventOrderer);\n\n    this._events = [];\n    this._axes = new Map(); // World -> events.\n  }\n\n  orderer_events_createClass(EventOrderer, [{\n    key: "addEvent",\n    value: function addEvent(worldId, event) {\n      // let p = event.position;\n      // let x = p[0]; let y = p[1]; let z = p[2];\n      var events = this._events; // let eventId = events.length;\n\n      events.push(event);\n\n      var worldAxes = this._axes.get(worldId);\n\n      if (!worldAxes) {\n        this._axes.set(worldId, [[0], [0], [0]]);\n      } else {// let xAxis = worldAxes[0];\n        // let yAxis = worldAxes[1];\n        // let zAxis = worldAxes[2];\n        // let dichotomyLowerBound = ObjectOrderer.dichotomyLowerBound;\n        // let orderCache = ObjectOrderer.orderCache;\n      }\n    } // Automatically removes event when they are outdated.\n    // If you wish to abort an event, simply set its lifespan to 0.\n    // It will be destroyed at the next server iteration.\n\n  }, {\n    key: "applyEventsInWorld",\n    value: function applyEventsInWorld(worldId) {\n      var axes = this._axes.get(worldId);\n\n      var events = this._events;\n      if (!axes) return;\n      var toDelete = [];\n      var xAxis = axes[0];\n      var yAxis = axes[1];\n      var zAxis = axes[2];\n      var currentEvent;\n      var eventIndex; // Detect deletable events.\n\n      for (var i = 0, l = xAxis.length; i < l; ++i) {\n        eventIndex = xAxis[i];\n        currentEvent = events[eventIndex];\n        currentEvent.apply();\n        if (!currentEvent.isActive()) toDelete.push(eventIndex);\n      } // Shift all numbers...\n\n\n      toDelete.sort();\n\n      for (var _i = 0, li = toDelete.length; _i < li; ++_i) {\n        currentEvent = events[_i];\n\n        for (var j = currentEvent.indexX, lj = xAxis.length; j < lj; ++j) {\n          events[xAxis[j]].indexX -= 1;\n        }\n\n        for (var _j = currentEvent.indexY, _lj = yAxis.length; _j < _lj; ++_j) {\n          events[yAxis[_j]].indexY -= 1;\n        }\n\n        for (var _j2 = currentEvent.indexZ, _lj2 = zAxis.length; _j2 < _lj2; ++_j2) {\n          events[zAxis[_j2]].indexZ -= 1;\n        }\n      } // Delete from all arrays.\n\n\n      for (var _i2 = 0, _li = toDelete.length; _i2 < _li; ++_i2) {\n        eventIndex = toDelete[_i2];\n        events.splice(eventIndex, 1);\n        xAxis.splice(xAxis.indexOf(eventIndex), 1);\n        yAxis.splice(yAxis.indexOf(eventIndex), 1);\n        zAxis.splice(zAxis.indexOf(eventIndex), 1);\n      }\n    }\n  }, {\n    key: "axes",\n    get: function get() {\n      return this._axes;\n    }\n  }, {\n    key: "events",\n    get: function get() {\n      return this._events;\n    }\n  }]);\n\n  return EventOrderer;\n}();\n\norderer_events_defineProperty(EventOrderer, "maxRange", 32.);\n\n/* harmony default export */ var orderer_events = (EventOrderer);\n// CONCATENATED MODULE: ./server/app/engine/game3d/model_entity/entity.js\n/**\n * Moving object.\n */\n\n\nfunction entity_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction entity_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction entity_createClass(Constructor, protoProps, staticProps) { if (protoProps) entity_defineProperties(Constructor.prototype, protoProps); if (staticProps) entity_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction entity_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar model_entity_entity_Entity = /*#__PURE__*/function () {\n  function Entity(id) {\n    entity_classCallCheck(this, Entity);\n\n    // Properties\n    this._entityId = id;\n    this._kind = \'abstract\'; // New physics engine\n\n    this._p0 = [0, 0, 0];\n    this._p1 = [0, 0, 0];\n    this._v0 = [0, 0, 0];\n    this._v1 = [0, 0, 0];\n    this._a0 = [0, 0, 0];\n    this._a1 = [0, 0, 0];\n    this._nu = [0, 0, 0];\n    this._nu1 = [0, 0, 0];\n    this._d = [!0, !0, !0, !0, !0, !0];\n    this._r = [0, 0, 0, 0]; // rel, abs\n\n    this._olR = [0, 0, 0, 0]; // rel, abs\n\n    this._metaX = null; // Displacement speeds\n\n    this._capS = .005;\n    this._capW = .01;\n    this._capR = .03; // LEGACY PhysicsEngine\n\n    this._mass = 1;\n    this._adherence = [!1, !1, !1, // Right, Into, Up\n    !1, !1, !1 // Left, From, Down\n    ]; // Situation.\n    // Barycenter.\n\n    this._worldId = -1; // When crossing multiple portals...\n    // 1 state = Object { position:p, rotation:r }\n    // this._otherWorlds = new Map(); // Not yet.\n    // Linked events.\n\n    this._events = []; // Physics/consistency optimization.\n\n    this._indexX = -1;\n    this._indexY = -1;\n    this._indexZ = -1;\n    this._dtr = 1.; // Hit box.\n\n    this._widthX = .25; // -> .5\n\n    this._widthY = .25; // -> .5\n\n    this._widthZ = .9; // -> 1.6\n    // Physical properties\n\n    this._mass = 1;\n    this._lastR = -1;\n    this._walljump = false;\n    this._running = false;\n    this._hitVector = [0, 0, 0];\n    this._hit = false;\n    this._sinceLastHit = 10;\n  }\n\n  entity_createClass(Entity, [{\n    key: "spawn",\n    value: function spawn(position, worldId) {\n      this._worldId = worldId;\n      this._r[0] = this._r[2] = this._r[3] = 0;\n      this._r[1] = Math.PI / 2;\n      this._d[0] = this._d[1] = this._d[2] = this._d[3] = this._d[4] = this._d[5] = !1; // this._p0[0] = this._p0[1] = this._p0[2] = 0;\n\n      this._p1[0] = this._p1[1] = this._p1[2] = 0;\n      this._v0[0] = this._v0[1] = this._v0[2] = 0;\n      this._v1[0] = this._v1[1] = this._v1[2] = 0;\n      this._a0[0] = this._a0[1] = this._a0[2] = 0;\n      this._a1[0] = this._a1[1] = this._a1[2] = 0;\n      this._nu[0] = this._nu[1] = this._nu[2] = 0;\n      this._nu1[0] = this._nu1[1] = this._nu1[2] = 0;\n      this._p0[0] = position[0];\n      this._p0[1] = position[1];\n      this._p0[2] = position[2];\n    }\n  }, {\n    key: "die",\n    value: function die() {// Here deallocate arrays.\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._d[0] = this._d[1] = this._d[2] = this._d[3] = this._d[4] = this._d[5] = !1; // console.log(\'[Entity] Entity stopping.\');\n    }\n  }, {\n    key: "goForward",\n    value: function goForward() {\n      this._d[0] = !0;\n    }\n  }, {\n    key: "goBackwards",\n    value: function goBackwards() {\n      this._d[1] = !0;\n    }\n  }, {\n    key: "goRight",\n    value: function goRight() {\n      this._d[2] = !0;\n    }\n  }, {\n    key: "goLeft",\n    value: function goLeft() {\n      this._d[3] = !0;\n    }\n  }, {\n    key: "goUp",\n    value: function goUp() {\n      this._d[4] = !0;\n    }\n  }, {\n    key: "goDown",\n    value: function goDown() {\n      this._d[5] = !0;\n    }\n  }, {\n    key: "stopForward",\n    value: function stopForward() {\n      this._d[0] = !1;\n    }\n  }, {\n    key: "stopBackwards",\n    value: function stopBackwards() {\n      this._d[1] = !1;\n    }\n  }, {\n    key: "stopRight",\n    value: function stopRight() {\n      this._d[2] = !1;\n    }\n  }, {\n    key: "stopLeft",\n    value: function stopLeft() {\n      this._d[3] = !1;\n    }\n  }, {\n    key: "stopUp",\n    value: function stopUp() {\n      this._d[4] = !1;\n    }\n  }, {\n    key: "stopDown",\n    value: function stopDown() {\n      this._d[5] = !1;\n    }\n  }, {\n    key: "startRunning",\n    value: function startRunning() {\n      this._running = true;\n    }\n  }, {\n    key: "stopRunning",\n    value: function stopRunning() {\n      this._running = false;\n    }\n  }, {\n    key: "rotate",\n    value: function rotate(relPitch, relYaw, absPitch, absYaw) {\n      for (var i = 0; i < 4; ++i) {\n        this._olR[i] = this._r[i];\n      }\n\n      this._r[0] = relPitch;\n      this._r[1] = relYaw;\n      this._r[2] = absPitch;\n      this._r[3] = absYaw;\n    } // Physics.\n\n  }, {\n    key: "setHitVector",\n    value: function setHitVector(x, y, z) {\n      this._hitVector[0] = x;\n      this._hitVector[1] = y;\n      this._hitVector[2] = z;\n    }\n  }, {\n    key: "countSinceLastHit",\n    value: function countSinceLastHit() {\n      ++this._sinceLastHit;\n    }\n  }, {\n    key: "wasHit",\n    value: function wasHit() {\n      this._sinceLastHit = 0;\n    }\n  }, {\n    key: "sinceLastHit",\n    value: function sinceLastHit() {\n      return this._sinceLastHit;\n    }\n  }, {\n    key: "getVelocity",\n    value: function getVelocity() {\n      return this._running ? this.runVelocity : this.walkVelocity;\n    }\n  }, {\n    key: "entityId",\n    // 1 blocks per time unit.\n    get: function get() {\n      return this._entityId;\n    }\n  }, {\n    key: "kind",\n    get: function get() {\n      return this._kind;\n    }\n  }, {\n    key: "worldId",\n    get: function get() {\n      return this._worldId;\n    },\n    set: function set(nwi) {\n      this._worldId = nwi;\n    }\n  }, {\n    key: "dtr",\n    get: function get() {\n      return this._dtr;\n    },\n    set: function set(dtr) {\n      this._dtr = dtr;\n    }\n  }, {\n    key: "lastR",\n    get: function get() {\n      return this._lastR;\n    },\n    set: function set(r) {\n      this._lastR = r;\n    }\n  }, {\n    key: "walljump",\n    get: function get() {\n      return this._walljump;\n    }\n  }, {\n    key: "rotation",\n    get: function get() {\n      return this._r;\n    },\n    set: function set(nr) {\n      this._r = nr;\n    }\n  }, {\n    key: "oldRotation",\n    get: function get() {\n      return this._olR;\n    },\n    set: function set(nr) {\n      this._olR = nr;\n    }\n  }, {\n    key: "position",\n    get: function get() {\n      return this._p0;\n    },\n    set: function set(np) {\n      this._p0 = np;\n    }\n  }, {\n    key: "adherence",\n    get: function get() {\n      return this._adherence;\n    } // get otherWorlds()       { return this._otherWorlds; }\n    ,\n    set: function set(na) {\n      this._adherence = na;\n    }\n  }, {\n    key: "indexX",\n    set: function set(indexX) {\n      this._indexX = indexX;\n    },\n    get: function get() {\n      return this._indexX;\n    }\n  }, {\n    key: "indexY",\n    set: function set(indexY) {\n      this._indexY = indexY;\n    },\n    get: function get() {\n      return this._indexY;\n    }\n  }, {\n    key: "indexZ",\n    set: function set(indexZ) {\n      this._indexZ = indexZ;\n    },\n    get: function get() {\n      return this._indexZ;\n    }\n  }, {\n    key: "widthX",\n    get: function get() {\n      return this._widthX;\n    },\n    set: function set(widthX) {\n      this._widthX = widthX;\n    }\n  }, {\n    key: "widthY",\n    get: function get() {\n      return this._widthY;\n    },\n    set: function set(widthY) {\n      this._widthY = widthY;\n    }\n  }, {\n    key: "widthZ",\n    get: function get() {\n      return this._widthZ;\n    },\n    set: function set(widthZ) {\n      this._widthZ = widthZ;\n    }\n  }, {\n    key: "metaX",\n    get: function get() {\n      return this._metaX;\n    },\n    set: function set(metaX) {\n      this._metaX = metaX;\n    }\n  }, {\n    key: "a0",\n    get: function get() {\n      return this._a0;\n    },\n    set: function set(a0) {\n      this._a0 = a0;\n    }\n  }, {\n    key: "a1",\n    get: function get() {\n      return this._a1;\n    },\n    set: function set(a1) {\n      this._a1 = a1;\n    }\n  }, {\n    key: "v0",\n    get: function get() {\n      return this._v0;\n    },\n    set: function set(v0) {\n      this._v0 = v0;\n    }\n  }, {\n    key: "v1",\n    get: function get() {\n      return this._v1;\n    },\n    set: function set(v1) {\n      this._v1 = v1;\n    }\n  }, {\n    key: "p0",\n    get: function get() {\n      return this._p0;\n    },\n    set: function set(p0) {\n      this._p0 = p0;\n    }\n  }, {\n    key: "p1",\n    get: function get() {\n      return this._p1;\n    },\n    set: function set(p1) {\n      this._p1 = p1;\n    }\n  }, {\n    key: "mass",\n    get: function get() {\n      return this._mass;\n    },\n    set: function set(m) {\n      this._mass = m;\n    }\n  }, {\n    key: "nu",\n    get: function get() {\n      return this._nu;\n    },\n    set: function set(nu) {\n      this._nu = nu;\n    }\n  }, {\n    key: "nu1",\n    get: function get() {\n      return this._nu1;\n    },\n    set: function set(nu1) {\n      this._nu1 = nu1;\n    }\n  }, {\n    key: "d",\n    get: function get() {\n      return this._d;\n    },\n    set: function set(d) {\n      this._d = d;\n    }\n  }, {\n    key: "r",\n    get: function get() {\n      return this._r;\n    },\n    set: function set(r) {\n      this._r = r;\n    }\n  }, {\n    key: "stealthVelocity",\n    get: function get() {\n      return this._capS;\n    },\n    set: function set(v) {\n      this._capS = v;\n    }\n  }, {\n    key: "walkVelocity",\n    get: function get() {\n      return this._capW;\n    },\n    set: function set(v) {\n      this._capW = v;\n    }\n  }, {\n    key: "runVelocity",\n    get: function get() {\n      return this._capR;\n    },\n    set: function set(v) {\n      this._capR = v;\n    }\n  }, {\n    key: "hit",\n    get: function get() {\n      return this._hit;\n    },\n    set: function set(h) {\n      this._hit = h;\n    }\n  }, {\n    key: "hitVector",\n    get: function get() {\n      return this._hitVector;\n    }\n  }]);\n\n  return Entity;\n}();\n\nentity_defineProperty(model_entity_entity_Entity, "maxWidth", 10.);\n\nentity_defineProperty(model_entity_entity_Entity, "maxSpeed", 8.);\n\nentity_defineProperty(model_entity_entity_Entity, "maxSpeedInWater", 0.005);\n\n/* harmony default export */ var model_entity_entity = (model_entity_entity_Entity);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_physics/solver/rigid_bodies/rigid_bodies_phase_1.js\nfunction rigid_bodies_phase_1_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rigid_bodies_phase_1_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rigid_bodies_phase_1_createClass(Constructor, protoProps, staticProps) { if (protoProps) rigid_bodies_phase_1_defineProperties(Constructor.prototype, protoProps); if (staticProps) rigid_bodies_phase_1_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Event processing.\n * Applies forces to or accelerates entities.\n * Compute entity desires.\n */\n\n\n\n\n\nvar rigid_bodies_phase_1_RigidBodiesPhase1 = /*#__PURE__*/function () {\n  function RigidBodiesPhase1() {\n    rigid_bodies_phase_1_classCallCheck(this, RigidBodiesPhase1);\n  }\n\n  rigid_bodies_phase_1_createClass(RigidBodiesPhase1, null, [{\n    key: "processLocalEvents",\n    value: function processLocalEvents(eventOrderer, entities, events, worldId, eventWorldAxes, oxAxis) {\n      var exAxis = eventWorldAxes[0]; // This uses only one axis to optimize solving\n      // but could absolutely use the others.\n\n      var lastEX = 0;\n      var eventIndex;\n      var entityIndex;\n      var currentEvent;\n      var op;\n      var ep;\n      var ox;\n      var oy;\n      var oz;\n      var ex;\n      var range;\n      var wx;\n      var wy;\n      var wz;\n      var maxRange = orderer_events.maxRange;\n      var maxWidth = model_entity_entity.maxWidth; // For all entities.\n\n      for (var oi = 0, ol = oxAxis.length; oi < ol; ++oi) {\n        var currentObject = oxAxis[oi];\n\n        if (!currentObject) {\n          console.log(\'Current object empty.\');\n          console.log("Expected number of objects ".concat(oxAxis.length));\n          console.log("Queried object index ".concat(oi));\n          console.log(\'oxAxis:\');\n          console.log(oxAxis);\n        }\n\n        if (!currentObject || currentObject.kind !== \'e\') continue;\n        entityIndex = oxAxis[oi].id;\n        var currentEntity = entities[entityIndex];\n        op = currentEntity.position;\n        ox = op[0];\n        wx = currentEntity.widthX;\n        oy = op[1];\n        wy = currentEntity.widthY;\n        oz = op[2];\n        wz = currentEntity.widthZ; // Search events.\n\n        for (var ei = lastEX, el = exAxis.length; ei < el; ++ei) {\n          eventIndex = exAxis[ei];\n          currentEvent = events[eventIndex];\n          ep = currentEvent.position;\n          ex = ep[0];\n          range = currentEntity.range; // Cache for next entities.\n\n          if (ox + maxWidth <= ex - maxRange) lastEX = ei;\n          if (ox + wx < ex - range) continue; // Not yet.\n\n          if (ox - wx > ex + range) break; // Too far.\n          // Out of bounds.\n\n          if (oy + wy < ep[1] - range) continue;\n          if (oz + wy < ep[2] - range) continue;\n          if (oy - wz > ep[1] + range) continue;\n          if (oz - wz > ep[2] + range) continue; // Apply effect to entity.\n\n          var a = currentEvent.effect.acceleration;\n\n          if (a) {\n            var dx = ep[0] - op[0];\n            var dy = ep[1] - op[1];\n            var dz = ep[2] - op[2];\n            var rat = Math.sqrt(a / (dx * dx + dy * dy + dz * dz));\n            var a1 = currentEntity.a1;\n            a1[0] += rat * dx;\n            a1[1] += rat * dy;\n            a1[2] += rat * dz;\n          }\n        }\n      } // Decrease event counters.\n\n\n      eventOrderer.applyEventsInWorld(worldId);\n    }\n    /**\n     * Integrates with leapfrog.\n     */\n\n  }, {\n    key: "processGlobalEvents",\n    value: function processGlobalEvents(entities, world, worldId, relativeDt, oxAxis, leapfrogArray, passId, rigidBodiesSolver) {\n      // let vS = [];\n      // let aS = [];\n      // const debug = false;\n      var isCubeWorld = world.worldInfo.type === model_WorldType.CUBE;\n      var maxSpeedInAir = model_entity_entity.maxSpeed;\n      var maxSpeedInWater = model_entity_entity.maxSpeedInWater;\n\n      for (var oi = 0, ol = oxAxis.length; oi < ol; ++oi) {\n        var currentObject = oxAxis[oi];\n        if (!currentObject || currentObject.kind !== \'e\') continue;\n        var entityIndex = oxAxis[oi].id;\n        var currentEntity = entities[entityIndex];\n        var p0 = currentEntity.p0;\n        var p1 = currentEntity.p1;\n        var v0 = currentEntity.v0;\n        var v1 = currentEntity.v1;\n        var a0 = currentEntity.a0;\n        var a1 = currentEntity.a1;\n        var nu = currentEntity.nu; // Instantaneous speed.\n\n        var nu1 = currentEntity.nu1;\n        var localTimeDilation = rigidBodiesSolver.getTimeDilation(worldId, p0[0], p0[1], p0[2]); // const dta = absoluteDt * localTimeDilation;\n\n        var dtr = relativeDt * localTimeDilation;\n        currentEntity.dtr = localTimeDilation; // dtr;\n\n        var inWater = world.isWater(p0[0], p0[1], p0[2]);\n        var maxSpeed = inWater ? maxSpeedInWater : maxSpeedInAir; // REAL PHYSICS, PART 1\n        // Rules: the only non-gp physics entry point should be\n        // acceleration. Speed might be accessed for lookup,\n        // but should never be directly modified.\n        // New positions are computed internally and cropped\n        // should a collision occur with the terrain or another\n        // entity (or x).\n\n        var g = rigid_bodies.creativeMode ? [0, 0, 0] : rigidBodiesSolver.getGravity(world, worldId, p0[0], p0[1], p0[2]); // Only one non-zeno gravity component accepted on cube worlds.\n\n        if (isCubeWorld && (g[0] !== 0) + (g[1] !== 0) + (g[2] !== 0) > 1) {\n          g[0] = g[1] = g[2] = 0;\n        } // let vector = RigidBodiesPhase1.getEntityForwardVector(d, r, factor, false); // 3D\n\n\n        var vector = RigidBodiesPhase1.getEntityForwardVector(currentEntity, // d, r, factor,\n        true);\n        var adh = currentEntity.adherence; // Compute the exact acceleration which is necessary\n        // to get to the cap speed at the next iteration.\n        // x_i+1 = x_i + v_i*T + (a_i/2)*T\n\n        var inc = [0, 0, 0, entityIndex];\n        var sum = 0;\n\n        for (var i = 0; i < 3; ++i) // Account for server congestion / lag with relative dilation.\n        {\n          nu1[i] = nu[i];\n          var increment = v0[i] * dtr + .5 * a0[i] * dtr * dtr;\n          inc[i] = increment;\n          sum += increment * increment;\n        } // Max speed correction.\n\n\n        if (sum > maxSpeed * dtr) for (var _i = 0; _i < 3; ++_i) {\n          inc[_i] *= maxSpeed * dtr / sum;\n        }\n\n        for (var _i2 = 0; _i2 < 3; ++_i2) {\n          var vi = vector[_i2];\n          var gi = g[_i2];\n          nu[_i2] = vi;\n\n          if ( // Cannot jump in air (does not apply to gods because for them g = 0)\n          !inWater && (!adh[_i2] && gi < 0 || !adh[3 + _i2] && gi > 0) // Clamp when marching toward a wall\n          // adh[i] && nu[i] < 0 || adh[3 + i] && nu[i] > 0\n          ) {\n              nu[_i2] = 0;\n            }\n\n          nu1[_i2] = nu[_i2];\n          inc[_i2] += nu[_i2] * dtr;\n        }\n\n        var min = Math.min;\n        var max = Math.max;\n        var gettingOutOfWater = false;\n\n        if (!inWater) {\n          if (g[0] < 0 && vector[0] > 0.05 && world.isWater(p0[0] - 1, p0[1], p0[2])) {\n            inc[0] = max(inc[0], 0);\n            gettingOutOfWater = true;\n            if (adh[1] || adh[2] || adh[4] || adh[5]) inc[0] = vector[0] * dtr;\n          } else if (g[0] > 0 && vector[0] < -0.05 && world.isWater(p0[0] - 1, p0[1], p0[2])) {\n            gettingOutOfWater = true;\n            inc[0] = min(inc[0], 0);\n            if (adh[1] || adh[2] || adh[4] || adh[5]) inc[0] = vector[0] * dtr;\n          }\n\n          if (g[1] < 0 && vector[1] > 0.05 && world.isWater(p0[0], p0[1] - 1, p0[2])) {\n            gettingOutOfWater = true;\n            inc[1] = max(inc[1], 0);\n            if (adh[0] || adh[2] || adh[3] || adh[5]) inc[1] = vector[1] * dtr;\n          } else if (g[1] > 0 && vector[1] < -0.05 && world.isWater(p0[0], p0[1] + 1, p0[2])) {\n            gettingOutOfWater = true;\n            inc[1] = min(inc[1], 0);\n            if (adh[0] || adh[2] || adh[3] || adh[5]) inc[1] = vector[1] * dtr;\n          }\n\n          if (g[2] < 0 && vector[2] > 0.05 && world.isWater(p0[0], p0[1], p0[2] - 1)) {\n            gettingOutOfWater = true;\n            inc[2] = max(inc[2], 0);\n            if (adh[1] || adh[0] || adh[4] || adh[3]) inc[2] = vector[2] * dtr;\n          } else if (g[2] > 0 && vector[2] < -0.05 && world.isWater(p0[0], p0[1], p0[2] + 1)) {\n            gettingOutOfWater = true;\n            inc[2] = min(inc[2], 0);\n            if (adh[1] || adh[0] || adh[4] || adh[3]) inc[2] = vector[2] * dtr;\n          }\n        }\n\n        var wj = currentEntity.walljump;\n\n        for (var _i3 = 0; _i3 < 3; ++_i3) {\n          var _gi = g[_i3];\n          var _vi = vector[_i3];\n\n          if (_gi < 0 && _vi > 0.05) {\n            if (adh[_i3]) {\n              // jump\n              a1[_i3] += 0.7;\n              inc[_i3] = 0;\n              adh[_i3] = false;\n            } else if (wj && !gettingOutOfWater && !adh[3 + _i3] && inc[_i3] < 0 && adh.reduce(function (a, v) {\n              return a + v;\n            }) === 1) {\n              a1[_i3] += 0.7;\n              inc[_i3] = 0; // walljump\n\n              for (var j = 0; j < 3; ++j) {\n                if (j === _i3) continue;\n\n                if (adh[j]) {\n                  a1[j] += 0.7;\n                  inc[j] = 0;\n                  adh[j] = false;\n                } else if (adh[3 + j]) {\n                  a1[j] -= 0.7;\n                  inc[j] = 0;\n                  adh[j] = false;\n                }\n              }\n            }\n          } else if (_gi > 0 && _vi < -0.05) {\n            if (adh[3 + _i3]) {\n              // jump downward\n              a1[_i3] -= 0.7;\n              inc[_i3] = 0;\n              adh[3 + _i3] = false;\n            } else if (wj && !gettingOutOfWater && !adh[_i3] && inc[_i3] > 0 && adh.reduce(function (a, v) {\n              return a + v;\n            }) === 1) {\n              a1[_i3] -= 0.7;\n              inc[_i3] = 0; // walljump downward\n\n              for (var _j = 0; _j < 3; ++_j) {\n                if (_j === _i3) continue;\n\n                if (adh[_j]) {\n                  a1[_j] += 0.7;\n                  inc[_j] = 0;\n                  adh[_j] = false;\n                } else if (adh[3 + _j]) {\n                  a1[_j] -= 0.7;\n                  inc[_j] = 0;\n                  adh[_j] = false;\n                }\n              }\n            }\n          }\n        }\n\n        for (var _i4 = 0; _i4 < 3; ++_i4) {\n          p1[_i4] = p0[_i4] + inc[_i4];\n        } // Associate incremental term with entity index.\n\n\n        leapfrogArray[oi] = [inc[0], inc[1], inc[2], oi];\n        var forces = RigidBodiesPhase1.getEntityForces(currentEntity); // Apply globals and inputs.\n        // a_i+1 = sum(constraints)\n\n        for (var _i5 = 0; _i5 < 3; ++_i5) {\n          a1[_i5] += g[_i5] + forces[_i5];\n        } // N.B. f=ma => a=f/m => a=(P=mg)/m => a=g\n        // Apply velocity formula with absolute time\n        // (lag would undesirably change topologies).\n        // v_i+1 = v_i< + T*(a_i + a_i+1)/2\n\n\n        sum = 0;\n\n        for (var _i6 = 0; _i6 < 3; ++_i6) {\n          var v1i = v0[_i6] + dtr * .5 * (a0[_i6] + a1[_i6]);\n          v1[_i6] = v1i;\n          sum += v1i * v1i;\n        } // Velocity correction.\n\n\n        if (sum > maxSpeed * dtr) for (var _i7 = 0; _i7 < 3; ++_i7) {\n          v1[_i7] *= maxSpeed * dtr / sum;\n        }\n      }\n    }\n  }, {\n    key: "getForwardVector",\n    value: function getForwardVector(d) {\n      var fw = d[0] && !d[1];\n      var bw = !d[0] && d[1];\n      var rg = d[2] && !d[3];\n      var lf = !d[2] && d[3];\n      var up = d[4] && !d[5];\n      var dn = !d[4] && d[5];\n      if (fw) return [1, 0, 0];\n      if (bw) return [-1, 0, 0];\n      if (rg) return [0, -1, 0];\n      if (lf) return [0, 1, 0];\n      if (up) return [0, 0, 1];\n      if (dn) return [0, 0, -1];\n      return [0, 0, 0];\n    }\n  }, {\n    key: "getEntityForces",\n    value: function getEntityForces(entity) {\n      if (entity.hit) {\n        entity.hit = false;\n        return entity.hitVector;\n      }\n\n      return [0, 0, 0];\n    } // XXX [PERF] use quaternions instead\n\n  }, {\n    key: "getEntityForwardVector",\n    value: function getEntityForwardVector(entity, project2D) {\n      var d = entity.d; // Directions.\n\n      var rotation = entity.r; // Rotation.\n\n      var maxV = entity.getVelocity();\n      var factor = Math.sqrt(maxV * 1.05);\n      var cos = Math.cos;\n      var sin = Math.sin;\n      var acos = Math.acos;\n      var sgn = Math.sign;\n      var sqrt = Math.sqrt;\n\n      var square = function square(x) {\n        return x * x;\n      };\n\n      var PI = Math.PI;\n      var PI2 = PI / 2;\n      var PI4 = PI / 4;\n      var PI34 = 3 * PI4;\n      var relTheta0 = rotation[0];\n      var relTheta1 = rotation[1];\n      var absTheta0 = rotation[2];\n      var absTheta1 = rotation[3]; // d[0], d[1]: fw, bw\n      // d[2], d[3]: rg, lf\n      // d[4], d[5]: up, dn\n\n      var fw = d[0] && !d[1];\n      var bw = !d[0] && d[1];\n      var rg = d[2] && !d[3];\n      var lf = !d[2] && d[3];\n      var up = d[4] && !d[5];\n      var dn = !d[4] && d[5];\n\n      if (project2D) {\n        relTheta1 = PI2; // I left a comment here saying this was wrong\n        // but as I am dropping support for this project it will stay like this.\n      }\n\n      var nb0 = (fw || bw) + (rg || lf) + (up || dn);\n      if (nb0 === 0) return [0, 0, 0];\n\n      var getPsy1 = function getPsy1(theta0, theta1, phi0, phi1) {\n        var st0 = sin(theta0);\n        var st1 = sin(theta1);\n        var ct0 = cos(theta0);\n        var ct1 = cos(theta1);\n        var sp0 = sin(phi0);\n        var sp1 = sin(phi1);\n        var cp0 = cos(phi0);\n        var cp1 = cos(phi1);\n        return acos((ct1 + cp1) / sqrt(square(st1 * st0 + sp1 * sp0) + square(st1 * ct0 + sp1 * cp0) + square(ct1 + cp1)));\n      };\n\n      var getPsy0 = function getPsy0(theta0, theta1, phi0, phi1) {\n        var st0 = sin(theta0);\n        var st1 = sin(theta1);\n        var ct0 = cos(theta0);\n        var sp0 = sin(phi0);\n        var sp1 = sin(phi1);\n        var cp0 = cos(phi0);\n        var s = sgn(st1 * st0 + sp1 * sp0);\n        return s * acos((st1 * ct0 + sp1 * cp0) / sqrt(square(st1 * st0 + sp1 * sp0) + square(st1 * ct0 + sp1 * cp0)));\n      };\n\n      if (nb0 === 1) {\n        if (fw) ; // {}\n        else if (bw) relTheta1 += PI;else if (up) relTheta1 += PI2;else if (dn) relTheta1 -= PI2;else if (rg) {\n            relTheta0 -= PI2;\n            relTheta1 = PI2;\n          } else if (lf) {\n            relTheta0 += PI2;\n            relTheta1 = PI2;\n          } else {\n            console.log(\'[RigidBodies] Undefined direction (1).\');\n            return [0, 0, 0];\n          }\n      } else if (nb0 === 2) {\n        var t0 = relTheta0;\n        var t1 = relTheta1;\n\n        switch (true) {\n          case fw && up:\n            relTheta1 += PI4;\n            break;\n\n          case fw && dn:\n            relTheta1 -= PI4;\n            break;\n\n          case bw && up:\n            relTheta1 += PI34;\n            break;\n\n          case bw && dn:\n            relTheta1 -= PI34;\n            break;\n\n          case fw && rg:\n            // Faster.\n            // relTheta0 = relTheta0 - (PI2 - PI4*sin(relTheta1));\n            // relTheta1 = PI2 - PI4*cos(relTheta1);\n            // More accurate.\n            relTheta0 = getPsy0(t0, t1, t0 - PI2, PI2) || 0;\n            relTheta1 = getPsy1(t0, t1, t0 - PI2, PI2) || 0;\n            break;\n\n          case fw && lf:\n            relTheta0 = getPsy0(t0, t1, t0 + PI2, PI2) || 0;\n            relTheta1 = getPsy1(t0, t1, t0 + PI2, PI2) || 0;\n            break;\n\n          case bw && rg:\n            relTheta0 = getPsy0(t0, t1 + PI, t0 - PI2, PI2) || 0;\n            relTheta1 = getPsy1(t0, t1 + PI, t0 - PI2, PI2) || 0;\n            break;\n\n          case bw && lf:\n            relTheta0 = getPsy0(t0, t1 + PI, t0 + PI2, PI2) || 0;\n            relTheta1 = getPsy1(t0, t1 + PI, t0 + PI2, PI2) || 0;\n            break;\n\n          case rg && up:\n            relTheta0 = getPsy0(t0, t1 + PI2, t0 - PI2, PI2) || 0;\n            relTheta1 = getPsy1(t0, t1 + PI2, t0 - PI2, PI2) || 0;\n            break;\n\n          case rg && dn:\n            relTheta0 = getPsy0(t0, t1 - PI2, t0 - PI2, PI2) || 0;\n            relTheta1 = getPsy1(t0, t1 - PI2, t0 - PI2, PI2) || 0;\n            break;\n\n          case lf && up:\n            relTheta0 = getPsy0(t0, t1 + PI2, t0 + PI2, PI2) || 0;\n            relTheta1 = getPsy1(t0, t1 + PI2, t0 + PI2, PI2) || 0;\n            break;\n\n          case lf && dn:\n            relTheta0 = getPsy0(t0, t1 - PI2, t0 + PI2, PI2) || 0;\n            relTheta1 = getPsy1(t0, t1 - PI2, t0 + PI2, PI2) || 0;\n            break;\n\n          default:\n            console.log(\'[RigidBodies] Undefined direction (2).\');\n            return [0, 0, 0];\n        }\n      } else if (nb0 === 3) {\n        var _t = relTheta0;\n        var _t2 = relTheta1;\n\n        switch (true) {\n          case fw && up && rg:\n            relTheta0 = getPsy0(_t, _t2 + PI4, _t - PI2, PI2) || 0;\n            relTheta1 = getPsy1(_t, _t2 + PI4, _t - PI2, PI2) || 0;\n            break;\n\n          case fw && dn && rg:\n            relTheta0 = getPsy0(_t, _t2 - PI4, _t - PI2, PI2) || 0;\n            relTheta1 = getPsy1(_t, _t2 - PI4, _t - PI2, PI2) || 0;\n            break;\n\n          case fw && up && lf:\n            relTheta0 = getPsy0(_t, _t2 + PI4, _t + PI2, PI2) || 0;\n            relTheta1 = getPsy1(_t, _t2 + PI4, _t + PI2, PI2) || 0;\n            break;\n\n          case fw && dn && lf:\n            relTheta0 = getPsy0(_t, _t2 - PI4, _t + PI2, PI2) || 0;\n            relTheta1 = getPsy1(_t, _t2 - PI4, _t + PI2, PI2) || 0;\n            break;\n\n          case bw && up && rg:\n            relTheta0 = getPsy0(_t, _t2 + PI34, _t - PI2, PI2) || 0;\n            relTheta1 = getPsy1(_t, _t2 + PI34, _t - PI2, PI2) || 0;\n            break;\n\n          case bw && dn && rg:\n            relTheta0 = getPsy0(_t, _t2 - PI34, _t - PI2, PI2) || 0;\n            relTheta1 = getPsy1(_t, _t2 - PI34, _t - PI2, PI2) || 0;\n            break;\n\n          case bw && up && lf:\n            relTheta0 = getPsy0(_t, _t2 + PI34, _t + PI2, PI2) || 0;\n            relTheta1 = getPsy1(_t, _t2 + PI34, _t + PI2, PI2) || 0;\n            break;\n\n          case bw && dn && lf:\n            relTheta0 = getPsy0(_t, _t2 - PI34, _t + PI2, PI2) || 0;\n            relTheta1 = getPsy1(_t, _t2 - PI34, _t + PI2, PI2) || 0;\n            break;\n\n          default:\n            console.log(\'[RigidBodies] Undefined direction (3).\');\n            return [0, 0, 0];\n        }\n      }\n\n      var cosAbs0 = cos(absTheta0);\n      var cosRel0 = cos(relTheta0);\n      var cosAbs1 = cos(absTheta1);\n      var cosRel1 = cos(relTheta1);\n      var sinAbs0 = sin(absTheta0);\n      var sinRel0 = sin(relTheta0);\n      var sinAbs1 = sin(absTheta1);\n      var sinRel1 = sin(relTheta1); // let absUpVector =    [sinAbs1 * cosAbs0, sinAbs1 * sinAbs0, cosAbs1];\n      // let absFrontVector = [cosAbs1 * cosAbs0, cosAbs1 * sinAbs0, -sinAbs1];\n      // let relUpVector =    [sinRel1 * cosRel0, sinRel1 * sinRel0, cosRel1];\n      // let relFrontVector = [- sinRel1 * sinRel0, sinRel1 * cosRel0, -cosRel1];\n\n      var relFrontVector; // Rx(theta1) times Rz(theta0) times Forward [-sinRel1*sinRel0, sinRel1*cosRel0, -cosRel1]\n      // N.B. Plane normal is Rx(theta1).Rz(theta0).(0,0,-1).\n      // Rx(1)             Rz(0)\n      // ( 1   0   0 )     ( c  -s   0 )     ( c0    -s0    0  )\n      // ( 0   c  -s )  X  ( s   c   0 )  =  ( c1s0  c1c0  -s1 )\n      // ( 0   s   c )     ( 0   0   1 )     ( s1s0  s1c0   c1 )\n      // =>\n      // ( c0(-S1S0) - s0(S1C0 )\n      // ( c1c0(-S1S0) + c1c0(S1C0) + s1C1 )\n      // ( s1s0(-S1S0) + s1c0(S1C0) - c1C1 )\n\n      /*\n      relFrontVector =    [\n          (-sinRel1*sinRel0*cosAbs0         - sinRel1*cosRel0*sinAbs0                          ),\n          (-sinRel1*sinRel0*cosAbs1*sinAbs0 + sinRel1*cosRel0*cosAbs1*cosAbs0 + cosRel1*sinAbs1),\n          (-sinRel1*sinRel0*sinAbs1*sinAbs0 + sinRel1*cosRel0*sinAbs1*cosAbs0 - cosRel1*cosAbs1)\n      ];\n      */\n      // Rz(theta0) times Rx(theta1) times Forward [-sinRel1*sinRel0, sinRel1*cosRel0, -cosRel1]\n      // N.B. Plane normal is Rz(theta0).Rx(theta1).(0,0,-1).\n      // Rz(0)             Rx(1)\n      // ( c  -s   0 )     ( 1   0   0 )     ( c0   -s0c1   s0s1 )\n      // ( s   c   0 )  X  ( 0   c  -s )  =  ( s0    c0c1  -c0s1 )\n      // ( 0   0   1 )     ( 0   s   c )     ( 0     s1     c1   )\n      // =>\n      // ( c0(-S1S0) - s0c1(S1C0) - s0s1C1 )\n      // ( s0(-S1S0) + c0c1(S1C0) - c0s1C1 )\n      // ( s1(S1C0) - c1C1 )\n\n      relFrontVector = [-sinRel1 * sinRel0 * cosAbs0 - sinRel1 * cosRel0 * sinAbs0 * cosAbs1 - cosRel1 * sinAbs0 * sinAbs1, -sinRel1 * sinRel0 * sinAbs0 + sinRel1 * cosRel0 * cosAbs0 * cosAbs1 + cosRel1 * cosAbs0 * sinAbs1,\n      /**/\n      sinRel1 * cosRel0 * sinAbs1 - cosRel1 * cosAbs1]; // The norm of this vector should be 1.\n\n      var frontVector3D = [];\n\n      for (var i = 0; i < 3; ++i) {\n        frontVector3D[i] = relFrontVector[i] * factor;\n      }\n\n      return frontVector3D;\n    }\n  }, {\n    key: "getEntityUpVector",\n    value: function getEntityUpVector(entity) {\n      var rotation = entity.r;\n      var cos = Math.cos;\n      var sin = Math.sin;\n      var PI = Math.PI;\n      var PI2 = PI / 2;\n      var relTheta0 = rotation[0];\n      var relTheta1 = rotation[1];\n      var absTheta0 = rotation[2];\n      var absTheta1 = rotation[3];\n      relTheta1 += PI2; // Rz(theta0) times Rx(theta1) times Forward [-sinRel1*sinRel0, sinRel1*cosRel0, -cosRel1]\n\n      var cosAbs0 = cos(absTheta0);\n      var cosRel0 = cos(relTheta0);\n      var cosAbs1 = cos(absTheta1);\n      var cosRel1 = cos(relTheta1);\n      var sinAbs0 = sin(absTheta0);\n      var sinRel0 = sin(relTheta0);\n      var sinAbs1 = sin(absTheta1);\n      var sinRel1 = sin(relTheta1);\n      var upVector = [-sinRel1 * sinRel0 * cosAbs0 - sinRel1 * cosRel0 * sinAbs0 * cosAbs1 - cosRel1 * sinAbs0 * sinAbs1, -sinRel1 * sinRel0 * sinAbs0 + sinRel1 * cosRel0 * cosAbs0 * cosAbs1 + cosRel1 * cosAbs0 * sinAbs1,\n      /**/\n      sinRel1 * cosRel0 * sinAbs1 - cosRel1 * cosAbs1];\n      return upVector;\n    }\n  }]);\n\n  return RigidBodiesPhase1;\n}();\n\n/* harmony default export */ var rigid_bodies_phase_1 = (rigid_bodies_phase_1_RigidBodiesPhase1);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_physics/solver/collision/terrain.js\n/**\n * Refactoring this thing is not a priority.\n * Some array allocs could be avoided, but diving in this (old) code is clearly a loss of time.\n */\n\n\nfunction terrain_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction terrain_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction terrain_createClass(Constructor, protoProps, staticProps) { if (protoProps) terrain_defineProperties(Constructor.prototype, protoProps); if (staticProps) terrain_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction terrain_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar TerrainCollider = /*#__PURE__*/function () {\n  function TerrainCollider() {\n    terrain_classCallCheck(this, TerrainCollider);\n  }\n\n  terrain_createClass(TerrainCollider, null, [{\n    key: "numericClamp",\n    value: function numericClamp(n) {\n      var ie = TerrainCollider.inveps;\n      return Math.round(n * ie) / ie;\n    }\n    /**\n     * Network casting:\n     * 1. Define a 2D network of 1-spaced points on the entity\'s 3 forward-moving faces.\n     * 2. Parallel cast from seeds using Amandites-Woo\'s algorithm.\n     * 3. Crop to nearest resulting positions.\n     *\n     * I know (highly suspect) it can be done way more efficiently.\n     * The first thing to optimise is the BSP lookup phase: world.isFree([x, y, z]).\n     * Suggestion:\n     * - XXX [PERF] flag empty chunks and full chunks\n     * Think of using octrees if scaling up chunks is an option (might depend on network requirements).\n     */\n\n  }, {\n    key: "collideLinearZ",\n    value: function collideLinearZ(entity, world, position, newPosition, doProject) {\n      var p0 = position;\n      var p1 = newPosition;\n      var x0 = p0[0];\n      var y0 = p0[1];\n      var z0 = p0[2];\n      var x1 = p1[0];\n      var y1 = p1[1];\n      var z1 = p1[2];\n      var xW = entity.widthX;\n      var yW = entity.widthY;\n      var zW = entity.widthZ;\n      var epsilon = TerrainCollider.eps;\n      var numClamp = TerrainCollider.numericClamp;\n      var cropX = x1;\n      var cropY = y1;\n      var cropZ = z1;\n      var adx = false;\n      var ady = false;\n      var adz = false;\n      var isProjectile = entity._isProjectile;\n      var it = 0;\n      var itm = 40;\n\n      if (x0 !== x1) {\n        var xStart = [];\n        var xArrival = [];\n\n        if (isProjectile) {\n          xStart.push([x0, y0, z0]);\n          xArrival.push([x1, y1, z1]);\n        } else for (var currentY = numClamp(y0 - yW), lastY = numClamp(y0 + yW);; it < itm) {\n          for (var currentZ = numClamp(z0 - zW), lastZ = numClamp(z0 + zW);; it < itm) {\n            xStart.push([x1 < x0 ? numClamp(x0 - xW) : numClamp(x0 + xW), currentY, currentZ]);\n            xArrival.push([x1 < x0 ? numClamp(x1 - xW) : numClamp(x1 + xW), numClamp(y1 + currentY - y0), numClamp(z1 + currentZ - z0)]);\n            if (currentZ >= lastZ) break;\n            currentZ = currentZ + 1 > lastZ ? lastZ : currentZ + 1;\n            ++it;\n          }\n\n          if (currentY >= lastY) break;\n          currentY = currentY + 1 > lastY ? lastY : currentY + 1;\n          ++it;\n        } // Do intersect.\n\n\n        for (var i = 0; i < xStart.length; ++i) {\n          var newCrops = xArrival[i];\n          var net = xStart[i];\n          var c = TerrainCollider.intersectAmanditesWoo(net, newCrops, world, entity, doProject);\n\n          if (c) {\n            adx = true;\n\n            if (x1 > x0 && numClamp(newCrops[0] - xW) < numClamp(cropX - epsilon)) {\n              cropX = numClamp(newCrops[0] - xW);\n              cropY = numClamp(newCrops[1] + y0 - net[1]);\n              cropZ = numClamp(newCrops[2] + z0 - net[2]);\n            } else if (x1 < x0 && numClamp(newCrops[0] + xW) > numClamp(cropX + epsilon)) {\n              cropX = numClamp(newCrops[0] + xW);\n              cropY = numClamp(newCrops[1] + y0 - net[1]);\n              cropZ = numClamp(newCrops[2] + z0 - net[2]);\n            }\n          }\n        }\n      }\n\n      if (y0 !== y1) {\n        var yStart = [];\n        var yArrival = [];\n\n        if (isProjectile) {\n          yStart.push([x0, y0, z0]);\n          yArrival.push([x1, y1, z1]);\n        } else for (var currentX = numClamp(x0 - xW), lastX = numClamp(x0 + xW);; it < itm) {\n          for (var _currentZ = numClamp(z0 - zW), _lastZ = numClamp(z0 + zW);; it < itm) {\n            yStart.push([currentX, y1 < y0 ? numClamp(y0 - yW) : numClamp(y0 + yW), _currentZ]);\n            yArrival.push([numClamp(x1 + currentX - x0), y1 < y0 ? numClamp(y1 - yW) : numClamp(y1 + yW), numClamp(z1 + _currentZ - z0)]);\n            if (_currentZ >= _lastZ) break;\n            _currentZ = _currentZ + 1 > _lastZ ? _lastZ : _currentZ + 1;\n            ++it;\n          }\n\n          if (currentX >= lastX) break;\n          currentX = currentX + 1 > lastX ? lastX : currentX + 1;\n          ++it;\n        } // Do intersect.\n\n\n        for (var _i = 0; _i < yStart.length; ++_i) {\n          var _newCrops = yArrival[_i];\n          var _net = yStart[_i];\n\n          var _c = TerrainCollider.intersectAmanditesWoo(_net, _newCrops, world, entity, doProject);\n\n          if (_c) {\n            ady = true;\n\n            if (y1 > y0 && numClamp(_newCrops[1] - yW) < numClamp(cropY - epsilon)) {\n              var nx = numClamp(_newCrops[0] + x0 - _net[0]);\n              var ny = numClamp(_newCrops[1] - yW);\n              var nz = numClamp(_newCrops[2] + z0 - _net[2]);\n              if (x1 < x0 && x1 < nx && cropX < nx || x0 < x1 && nx < x1 && nx < cropX || x0 === x1) cropX = nx;\n              cropY = ny;\n              if (z1 < z0 && z1 < nz && cropZ < nz || z0 < z1 && nz < z1 && nz < cropZ || z0 === z1) cropZ = nz;\n            } else if (y1 < y0 && numClamp(_newCrops[1] + yW) > numClamp(cropY + epsilon)) {\n              var _nx = numClamp(_newCrops[0] + x0 - _net[0]);\n\n              var _ny = numClamp(_newCrops[1] + yW);\n\n              var _nz = numClamp(_newCrops[2] + z0 - _net[2]);\n\n              if (x1 < x0 && x1 < _nx && cropX < _nx || x0 < x1 && _nx < x1 && _nx < cropX || x0 === x1) cropX = _nx;\n              cropY = _ny;\n              if (z1 < z0 && z1 < _nz && cropZ < _nz || z0 < z1 && _nz < z1 && _nz < cropZ || z0 === z1) cropZ = _nz;\n            }\n          }\n        }\n      }\n\n      if (z0 !== z1) {\n        var zStart = [];\n        var zArrival = [];\n\n        if (isProjectile) {\n          zStart.push([x0, y0, z0]);\n          zArrival.push([cropX, cropY, z1]);\n        } else for (var _currentX = x0 - xW, _lastX = x0 + xW;; it < itm) {\n          for (var _currentY = y0 - yW, _lastY = y0 + yW;; it < itm) {\n            zStart.push([_currentX, _currentY, z1 < z0 ? numClamp(z0 - zW + epsilon) : numClamp(z0 + zW)]);\n            zArrival.push([numClamp(cropX + _currentX - x0), numClamp(cropY + _currentY - y0), z1 < z0 ? numClamp(z1 - zW) : numClamp(z1 + zW)]);\n            if (_currentY >= _lastY) break;\n            _currentY = _currentY + 1 > _lastY ? _lastY : _currentY + 1;\n            ++it;\n          }\n\n          if (_currentX >= _lastX) break;\n          _currentX = _currentX + 1 > _lastX ? _lastX : _currentX + 1;\n          ++it;\n        } // Do intersect.\n\n\n        for (var _i2 = 0; _i2 < zStart.length; ++_i2) {\n          var _newCrops2 = zArrival[_i2];\n          var _net2 = zStart[_i2];\n\n          var _c2 = TerrainCollider.intersectAmanditesWoo(_net2, _newCrops2, world, entity, doProject);\n\n          if (_c2) {\n            adz = true;\n\n            if (z1 > z0 && numClamp(_newCrops2[2] - zW) < numClamp(cropZ - epsilon)) {\n              var _nx2 = numClamp(_newCrops2[0] + x0 - _net2[0]);\n\n              var _ny2 = numClamp(_newCrops2[1] + y0 - _net2[1]);\n\n              var _nz2 = numClamp(_newCrops2[2] - zW);\n\n              if (x1 < x0 && x1 < _nx2 && cropX < _nx2 || x0 < x1 && _nx2 < x1 && _nx2 < cropX || x0 === x1) cropX = _nx2;\n              if (y1 < y0 && y1 < _ny2 && cropY < _ny2 || y0 < y1 && _ny2 < y1 && _ny2 < cropY || y0 === y1) cropY = _ny2;\n              cropZ = _nz2;\n            } else if (z1 < z0 && numClamp(_newCrops2[2] + zW) > numClamp(cropZ + epsilon)) {\n              var _nx3 = numClamp(_newCrops2[0] + x0 - _net2[0]);\n\n              var _ny3 = numClamp(_newCrops2[1] + y0 - _net2[1]);\n\n              var _nz3 = numClamp(_newCrops2[2] + zW);\n\n              if (x1 < x0 && x1 < _nx3 && cropX < _nx3 || x0 < x1 && _nx3 < x1 && _nx3 < cropX || x0 === x1) cropX = _nx3;\n              if (y1 < y0 && y1 < _ny3 && cropY < _ny3 || y0 < y1 && _ny3 < y1 && _ny3 < cropY || y0 === y1) cropY = _ny3;\n              cropZ = _nz3;\n            }\n          }\n        }\n      }\n\n      if (it === itm) {\n        console.warn(\'[Terrain] Invalid hitbox.\');\n      }\n\n      TerrainCollider.correctAdherence(entity, adx, ady, adz, x0, x1, y0, y1, z0, z1);\n\n      if (cropX !== x1 || cropY !== y1 || cropZ !== z1) {\n        if (!isProjectile) {\n          newPosition[0] = cropX;\n          newPosition[1] = cropY;\n          newPosition[2] = cropZ;\n        }\n\n        return true;\n      } // Intersect on first Non-Free Block\n      // if (TerrainCollider.intersectAmanditesWoo(position, newPosition, world, entity)) return true;\n\n\n      return false;\n    }\n  }, {\n    key: "collideLinearY",\n    value: function collideLinearY(entity, world, position, newPosition, doProject) {\n      var p0 = position;\n      var p1 = newPosition;\n      var x0 = p0[0];\n      var y0 = p0[1];\n      var z0 = p0[2];\n      var x1 = p1[0];\n      var y1 = p1[1];\n      var z1 = p1[2];\n      var xW = entity.widthX;\n      var yW = entity.widthY;\n      var zW = entity.widthZ;\n      var epsilon = TerrainCollider.eps;\n      var numClamp = TerrainCollider.numericClamp;\n      var cropX = x1;\n      var cropY = y1;\n      var cropZ = z1;\n      var adx = false;\n      var ady = false;\n      var adz = false;\n      var isProjectile = entity._isProjectile;\n      var it = 0;\n      var itm = 40;\n\n      if (x0 !== x1) {\n        var xStart = [];\n        var xArrival = [];\n\n        if (isProjectile) {\n          xStart.push([x0, y0, z0]);\n          xArrival.push([x1, y1, z1]);\n        } else for (var currentY = numClamp(y0 - yW), lastY = numClamp(y0 + yW);; it < itm) {\n          for (var currentZ = numClamp(z0 - zW), lastZ = numClamp(z0 + zW);; it < itm) {\n            xStart.push([x1 < x0 ? numClamp(x0 - xW) : numClamp(x0 + xW), currentY, currentZ]);\n            xArrival.push([x1 < x0 ? numClamp(x1 - xW) : numClamp(x1 + xW), numClamp(y1 + currentY - y0), numClamp(z1 + currentZ - z0)]);\n            if (currentZ >= lastZ) break;\n            currentZ = currentZ + 1 > lastZ ? lastZ : currentZ + 1;\n            ++it;\n          }\n\n          if (currentY >= lastY) break;\n          currentY = currentY + 1 > lastY ? lastY : currentY + 1;\n          ++it;\n        } // Do intersect.\n\n\n        for (var i = 0; i < xStart.length; ++i) {\n          var newCrops = xArrival[i];\n          var net = xStart[i];\n          var c = TerrainCollider.intersectAmanditesWoo(net, newCrops, world, entity, doProject);\n\n          if (c) {\n            adx = true;\n\n            if (x1 > x0 && numClamp(newCrops[0] - xW) < numClamp(cropX - epsilon)) {\n              cropX = numClamp(newCrops[0] - xW);\n              cropY = numClamp(newCrops[1] + y0 - net[1]);\n              cropZ = numClamp(newCrops[2] + z0 - net[2]);\n            } else if (x1 < x0 && numClamp(newCrops[0] + xW) > numClamp(cropX + epsilon)) {\n              cropX = numClamp(newCrops[0] + xW);\n              cropY = numClamp(newCrops[1] + y0 - net[1]);\n              cropZ = numClamp(newCrops[2] + z0 - net[2]);\n            }\n          }\n        }\n      }\n\n      if (z0 !== z1) {\n        var zStart = [];\n        var zArrival = [];\n\n        if (isProjectile) {\n          zStart.push([x0, y0, z0]);\n          zArrival.push([x1, y1, z1]);\n        } else for (var currentX = x0 - xW, lastX = x0 + xW;; it < itm) {\n          for (var _currentY2 = y0 - yW, _lastY2 = y0 + yW;; it < itm) {\n            zStart.push([currentX, _currentY2, z1 < z0 ? numClamp(z0 - zW + epsilon) : numClamp(z0 + zW)]);\n            zArrival.push([numClamp(x1 + currentX - x0), numClamp(y1 + _currentY2 - y0), z1 < z0 ? numClamp(z1 - zW) : numClamp(z1 + zW)]);\n            if (_currentY2 >= _lastY2) break;\n            _currentY2 = _currentY2 + 1 > _lastY2 ? _lastY2 : _currentY2 + 1;\n            ++it;\n          }\n\n          if (currentX >= lastX) break;\n          currentX = currentX + 1 > lastX ? lastX : currentX + 1;\n          ++it;\n        } // Do intersect.\n\n\n        for (var _i3 = 0; _i3 < zStart.length; ++_i3) {\n          var _newCrops3 = zArrival[_i3];\n          var _net3 = zStart[_i3];\n\n          var _c3 = TerrainCollider.intersectAmanditesWoo(_net3, _newCrops3, world, entity, doProject);\n\n          if (_c3) {\n            adz = true;\n\n            if (z1 > z0 && numClamp(_newCrops3[2] - zW) < numClamp(cropZ - epsilon)) {\n              var nx = numClamp(_newCrops3[0] + x0 - _net3[0]);\n              var ny = numClamp(_newCrops3[1] + y0 - _net3[1]);\n              var nz = numClamp(_newCrops3[2] - zW);\n              if (x1 < x0 && x1 < nx && cropX < nx || x0 < x1 && nx < x1 && nx < cropX || x0 === x1) cropX = nx;\n              if (y1 < y0 && y1 < ny && cropY < ny || y0 < y1 && ny < y1 && ny < cropY || y0 === y1) cropY = ny;\n              cropZ = nz;\n            } else if (z1 < z0 && numClamp(_newCrops3[2] + zW) > numClamp(cropZ + epsilon)) {\n              var _nx4 = numClamp(_newCrops3[0] + x0 - _net3[0]);\n\n              var _ny4 = numClamp(_newCrops3[1] + y0 - _net3[1]);\n\n              var _nz4 = numClamp(_newCrops3[2] + zW);\n\n              if (x1 < x0 && x1 < _nx4 && cropX < _nx4 || x0 < x1 && _nx4 < x1 && _nx4 < cropX || x0 === x1) cropX = _nx4;\n              if (y1 < y0 && y1 < _ny4 && cropY < _ny4 || y0 < y1 && _ny4 < y1 && _ny4 < cropY || y0 === y1) cropY = _ny4;\n              cropZ = _nz4;\n            }\n          }\n        }\n      }\n\n      if (y0 !== y1) {\n        var yStart = [];\n        var yArrival = [];\n\n        if (isProjectile) {\n          yStart.push([x0, y0, z0]);\n          yArrival.push([cropX, y1, cropZ]);\n        } else for (var _currentX2 = numClamp(x0 - xW), _lastX2 = numClamp(x0 + xW);; it < itm) {\n          for (var _currentZ2 = numClamp(z0 - zW), _lastZ2 = numClamp(z0 + zW);; it < itm) {\n            yStart.push([_currentX2, y1 < y0 ? numClamp(y0 - yW) : numClamp(y0 + yW), _currentZ2]);\n            yArrival.push([numClamp(cropX + _currentX2 - x0), y1 < y0 ? numClamp(y1 - yW) : numClamp(y1 + yW), numClamp(cropZ + _currentZ2 - z0)]);\n            if (_currentZ2 >= _lastZ2) break;\n            _currentZ2 = _currentZ2 + 1 > _lastZ2 ? _lastZ2 : _currentZ2 + 1;\n            ++it;\n          }\n\n          if (_currentX2 >= _lastX2) break;\n          _currentX2 = _currentX2 + 1 > _lastX2 ? _lastX2 : _currentX2 + 1;\n          ++it;\n        } // Do intersect.\n\n\n        for (var _i4 = 0; _i4 < yStart.length; ++_i4) {\n          var _newCrops4 = yArrival[_i4];\n          var _net4 = yStart[_i4];\n\n          var _c4 = TerrainCollider.intersectAmanditesWoo(_net4, _newCrops4, world, entity, doProject);\n\n          if (_c4) {\n            ady = true;\n\n            if (y1 > y0 && numClamp(_newCrops4[1] - yW) < numClamp(cropY - epsilon)) {\n              var _nx5 = numClamp(_newCrops4[0] + x0 - _net4[0]);\n\n              var _ny5 = numClamp(_newCrops4[1] - yW);\n\n              var _nz5 = numClamp(_newCrops4[2] + z0 - _net4[2]);\n\n              if (x1 < x0 && x1 < _nx5 && cropX < _nx5 || x0 < x1 && _nx5 < x1 && _nx5 < cropX || x0 === x1) cropX = _nx5;\n              cropY = _ny5;\n              if (z1 < z0 && z1 < _nz5 && cropZ < _nz5 || z0 < z1 && _nz5 < z1 && _nz5 < cropZ || z0 === z1) cropZ = _nz5;\n            } else if (y1 < y0 && numClamp(_newCrops4[1] + yW) > numClamp(cropY + epsilon)) {\n              var _nx6 = numClamp(_newCrops4[0] + x0 - _net4[0]);\n\n              var _ny6 = numClamp(_newCrops4[1] + yW);\n\n              var _nz6 = numClamp(_newCrops4[2] + z0 - _net4[2]);\n\n              if (x1 < x0 && x1 < _nx6 && cropX < _nx6 || x0 < x1 && _nx6 < x1 && _nx6 < cropX || x0 === x1) cropX = _nx6;\n              cropY = _ny6;\n              if (z1 < z0 && z1 < _nz6 && cropZ < _nz6 || z0 < z1 && _nz6 < z1 && _nz6 < cropZ || z0 === z1) cropZ = _nz6;\n            }\n          }\n        }\n      }\n\n      if (it === itm) {\n        console.warn(\'[Terrain] Invalid hitbox.\');\n      }\n\n      TerrainCollider.correctAdherence(entity, adx, ady, adz, x0, x1, y0, y1, z0, z1);\n\n      if (cropX !== x1 || cropY !== y1 || cropZ !== z1) {\n        if (!isProjectile) {\n          newPosition[0] = cropX;\n          newPosition[1] = cropY;\n          newPosition[2] = cropZ;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: "collideLinearX",\n    value: function collideLinearX(entity, world, position, newPosition, doProject) {\n      var p0 = position;\n      var p1 = newPosition;\n      var x0 = p0[0];\n      var y0 = p0[1];\n      var z0 = p0[2];\n      var x1 = p1[0];\n      var y1 = p1[1];\n      var z1 = p1[2];\n      var xW = entity.widthX;\n      var yW = entity.widthY;\n      var zW = entity.widthZ;\n      var epsilon = TerrainCollider.eps;\n      var numClamp = TerrainCollider.numericClamp;\n      var cropX = x1;\n      var cropY = y1;\n      var cropZ = z1;\n      var adx = false;\n      var ady = false;\n      var adz = false;\n      var isProjectile = entity._isProjectile;\n      var it = 0;\n      var itm = 40;\n\n      if (y0 !== y1) {\n        var yStart = [];\n        var yArrival = [];\n\n        if (isProjectile) {\n          yStart.push([x0, y0, z0]);\n          yArrival.push([x1, y1, z1]);\n        } else for (var currentX = numClamp(x0 - xW), lastX = numClamp(x0 + xW);; it < itm) {\n          for (var currentZ = numClamp(z0 - zW), lastZ = numClamp(z0 + zW);; it < itm) {\n            yStart.push([currentX, y1 < y0 ? numClamp(y0 - yW) : numClamp(y0 + yW), currentZ]);\n            yArrival.push([numClamp(x1 + currentX - x0), y1 < y0 ? numClamp(y1 - yW) : numClamp(y1 + yW), numClamp(z1 + currentZ - z0)]);\n            if (currentZ >= lastZ) break;\n            currentZ = currentZ + 1 > lastZ ? lastZ : currentZ + 1;\n            ++it;\n          }\n\n          if (currentX >= lastX) break;\n          currentX = currentX + 1 > lastX ? lastX : currentX + 1;\n          ++it;\n        } // Do intersect.\n\n\n        for (var i = 0; i < yStart.length; ++i) {\n          var newCrops = yArrival[i];\n          var net = yStart[i];\n          var c = TerrainCollider.intersectAmanditesWoo(net, newCrops, world, entity, doProject);\n\n          if (c) {\n            ady = true;\n\n            if (y1 > y0 && numClamp(newCrops[1] - yW) < numClamp(cropY - epsilon)) {\n              var nx = numClamp(newCrops[0] + x0 - net[0]);\n              var ny = numClamp(newCrops[1] - yW);\n              var nz = numClamp(newCrops[2] + z0 - net[2]);\n              if (x1 < x0 && x1 < nx && cropX < nx || x0 < x1 && nx < x1 && nx < cropX || x0 === x1) cropX = nx;\n              cropY = ny;\n              if (z1 < z0 && z1 < nz && cropZ < nz || z0 < z1 && nz < z1 && nz < cropZ || z0 === z1) cropZ = nz;\n            } else if (y1 < y0 && numClamp(newCrops[1] + yW) > numClamp(cropY + epsilon)) {\n              var _nx7 = numClamp(newCrops[0] + x0 - net[0]);\n\n              var _ny7 = numClamp(newCrops[1] + yW);\n\n              var _nz7 = numClamp(newCrops[2] + z0 - net[2]);\n\n              if (x1 < x0 && x1 < _nx7 && cropX < _nx7 || x0 < x1 && _nx7 < x1 && _nx7 < cropX || x0 === x1) cropX = _nx7;\n              cropY = _ny7;\n              if (z1 < z0 && z1 < _nz7 && cropZ < _nz7 || z0 < z1 && _nz7 < z1 && _nz7 < cropZ || z0 === z1) cropZ = _nz7;\n            }\n          }\n        }\n      }\n\n      if (z0 !== z1) {\n        var zStart = [];\n        var zArrival = [];\n\n        if (isProjectile) {\n          zStart.push([x0, y0, z0]);\n          zArrival.push([x1, y1, z1]);\n        } else for (var _currentX3 = x0 - xW, _lastX3 = x0 + xW;; it < itm) {\n          for (var currentY = y0 - yW, lastY = y0 + yW;; it < itm) {\n            zStart.push([_currentX3, currentY, z1 < z0 ? numClamp(z0 - zW + epsilon) : numClamp(z0 + zW)]);\n            zArrival.push([numClamp(x1 + _currentX3 - x0), numClamp(y1 + currentY - y0), z1 < z0 ? numClamp(z1 - zW) : numClamp(z1 + zW)]);\n            if (currentY >= lastY) break;\n            currentY = currentY + 1 > lastY ? lastY : currentY + 1;\n            ++it;\n          }\n\n          if (_currentX3 >= _lastX3) break;\n          _currentX3 = _currentX3 + 1 > _lastX3 ? _lastX3 : _currentX3 + 1;\n          ++it;\n        } // Do intersect.\n\n\n        for (var _i5 = 0; _i5 < zStart.length; ++_i5) {\n          var _newCrops5 = zArrival[_i5];\n          var _net5 = zStart[_i5];\n\n          var _c5 = TerrainCollider.intersectAmanditesWoo(_net5, _newCrops5, world, entity, doProject);\n\n          if (_c5) {\n            adz = true;\n\n            if (z1 > z0 && numClamp(_newCrops5[2] - zW) < numClamp(cropZ - epsilon)) {\n              var _nx8 = numClamp(_newCrops5[0] + x0 - _net5[0]);\n\n              var _ny8 = numClamp(_newCrops5[1] + y0 - _net5[1]);\n\n              var _nz8 = numClamp(_newCrops5[2] - zW);\n\n              if (x1 < x0 && x1 < _nx8 && cropX < _nx8 || x0 < x1 && _nx8 < x1 && _nx8 < cropX || x0 === x1) cropX = _nx8;\n              if (y1 < y0 && y1 < _ny8 && cropY < _ny8 || y0 < y1 && _ny8 < y1 && _ny8 < cropY || y0 === y1) cropY = _ny8;\n              cropZ = _nz8;\n            } else if (z1 < z0 && numClamp(_newCrops5[2] + zW) > numClamp(cropZ + epsilon)) {\n              var _nx9 = numClamp(_newCrops5[0] + x0 - _net5[0]);\n\n              var _ny9 = numClamp(_newCrops5[1] + y0 - _net5[1]);\n\n              var _nz9 = numClamp(_newCrops5[2] + zW);\n\n              if (x1 < x0 && x1 < _nx9 && cropX < _nx9 || x0 < x1 && _nx9 < x1 && _nx9 < cropX || x0 === x1) cropX = _nx9;\n              if (y1 < y0 && y1 < _ny9 && cropY < _ny9 || y0 < y1 && _ny9 < y1 && _ny9 < cropY || y0 === y1) cropY = _ny9;\n              cropZ = _nz9;\n            }\n          }\n        }\n      }\n\n      if (x0 !== x1) {\n        var xStart = [];\n        var xArrival = [];\n\n        if (isProjectile) {\n          xStart.push([x0, y0, z0]);\n          xArrival.push([x1, cropY, cropZ]);\n        } else for (var _currentY3 = numClamp(y0 - yW), _lastY3 = numClamp(y0 + yW);; it < itm) {\n          for (var _currentZ3 = numClamp(z0 - zW), _lastZ3 = numClamp(z0 + zW);; it < itm) {\n            xStart.push([x1 < x0 ? numClamp(x0 - xW) : numClamp(x0 + xW), _currentY3, _currentZ3]);\n            xArrival.push([x1 < x0 ? numClamp(x1 - xW) : numClamp(x1 + xW), numClamp(cropY + _currentY3 - y0), numClamp(cropZ + _currentZ3 - z0)]);\n            if (_currentZ3 >= _lastZ3) break;\n            _currentZ3 = _currentZ3 + 1 > _lastZ3 ? _lastZ3 : _currentZ3 + 1;\n            ++it;\n          }\n\n          if (_currentY3 >= _lastY3) break;\n          _currentY3 = _currentY3 + 1 > _lastY3 ? _lastY3 : _currentY3 + 1;\n          ++it;\n        } // Do intersect.\n\n\n        for (var _i6 = 0; _i6 < xStart.length; ++_i6) {\n          var _newCrops6 = xArrival[_i6];\n          var _net6 = xStart[_i6];\n\n          var _c6 = TerrainCollider.intersectAmanditesWoo(_net6, _newCrops6, world, entity, doProject);\n\n          if (_c6) {\n            adx = true;\n\n            if (x1 > x0 && numClamp(_newCrops6[0] - xW) < numClamp(cropX - epsilon)) {\n              cropX = numClamp(_newCrops6[0] - xW);\n              cropY = numClamp(_newCrops6[1] + y0 - _net6[1]);\n              cropZ = numClamp(_newCrops6[2] + z0 - _net6[2]);\n            } else if (x1 < x0 && numClamp(_newCrops6[0] + xW) > numClamp(cropX + epsilon)) {\n              cropX = numClamp(_newCrops6[0] + xW);\n              cropY = numClamp(_newCrops6[1] + y0 - _net6[1]);\n              cropZ = numClamp(_newCrops6[2] + z0 - _net6[2]);\n            }\n          }\n        }\n      }\n\n      if (it === itm) {\n        console.warn(\'[Terrain] Invalid hitbox.\');\n      }\n\n      TerrainCollider.correctAdherence(entity, adx, ady, adz, x0, x1, y0, y1, z0, z1);\n\n      if (cropX !== x1 || cropY !== y1 || cropZ !== z1) {\n        if (!isProjectile) {\n          newPosition[0] = cropX;\n          newPosition[1] = cropY;\n          newPosition[2] = cropZ;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: "correctAdherence",\n    value: function correctAdherence(entity, adx, ady, adz, x0, x1, y0, y1, z0, z1) {\n      var adh = entity.adherence;\n      var acc0 = entity.a0;\n\n      if (adx) {\n        adh[x0 > x1 ? 0 : 3] = true;\n        adh[x0 > x1 ? 3 : 0] = false;\n      } else {\n        adh[0] = adh[3] = false;\n      }\n\n      if (ady) {\n        adh[y0 > y1 ? 1 : 4] = true;\n        adh[y0 > y1 ? 4 : 1] = false;\n      } else {\n        adh[1] = adh[4] = false;\n      }\n\n      if (adz) {\n        adh[z0 > z1 ? 2 : 5] = true;\n        adh[z0 > z1 ? 5 : 2] = false;\n      } else {\n        adh[2] = adh[5] = false;\n      }\n\n      if (adh[2] && acc0[2] < 0 || adh[5] && acc0[2] > 0) {\n        entity.v1[0] = 0;\n        entity.v1[1] = 0;\n      }\n\n      if (adh[0] && acc0[0] < 0 || adh[3] && acc0[0] > 0) {\n        entity.v1[1] = 0;\n        entity.v1[2] = 0;\n      }\n\n      if (adh[1] && acc0[1] < 0 || adh[4] && acc0[1] > 0) {\n        entity.v1[0] = 0;\n        entity.v1[2] = 0;\n      }\n    } // Warning: linear raycasting.\n    // Does not account for exact X leapfrog integration\n\n  }, {\n    key: "intersectAmanditesWoo",\n    value: function intersectAmanditesWoo(p1, p2, world, entity, doProject) {\n      var sgn = function sgn(x) {\n        return x > 0 ? 1 : x < 0 ? -1 : 0;\n      };\n\n      var frac0 = function frac0(x) {\n        return x - Math.floor(x);\n      };\n\n      var frac1 = function frac1(x) {\n        return 1.0 - x + Math.floor(x);\n      };\n\n      var min = function min(x, y) {\n        return Math.min(x, y);\n      };\n\n      var x1 = p1[0];\n      var x2 = p2[0];\n      var y1 = p1[1];\n      var y2 = p2[1];\n      var z1 = p1[2];\n      var z2 = p2[2]; // p1p2 is parametrized as p(t) = p1 + (p2-p1)*t\n      // tDeltaX def. how far one has to move, in units of t, s. t. the horiz. comp. of the mvt. eq. the wdth. of a v.\n      // tMaxX def. the value of t at which (p1p2) crosses the first (then nth) vertical boundary.\n\n      var tMaxX;\n      var tMaxY;\n      var tMaxZ;\n      var tDeltaX;\n      var tDeltaY;\n      var tDeltaZ;\n      var ntx = false;\n      var nty = false;\n      var ntz = false;\n      var threshold = 10000000.0;\n      var dx = sgn(x2 - x1);\n      var i = Math.floor(x1);\n      if (dx !== 0) tDeltaX = min(dx / (x2 - x1), threshold);else tDeltaX = threshold;\n      if (dx > 0) tMaxX = tDeltaX * frac1(x1);else tMaxX = tDeltaX * frac0(x1);\n      var dy = sgn(y2 - y1);\n      var j = Math.floor(y1);\n      if (dy !== 0) tDeltaY = min(dy / (y2 - y1), threshold);else tDeltaY = threshold;\n      if (dy > 0) tMaxY = tDeltaY * frac1(y1);else tMaxY = tDeltaY * frac0(y1);\n      var dz = sgn(z2 - z1);\n      var k = Math.floor(z1);\n      if (dz !== 0) tDeltaZ = min(dz / (z2 - z1), threshold);else tDeltaZ = threshold;\n      if (dz > 0) tMaxZ = tDeltaZ * frac1(z1);else tMaxZ = tDeltaZ * frac0(z1);\n\n      if (typeof tMaxX !== \'number\' || typeof tMaxY !== \'number\' || typeof tMaxZ !== \'number\') {\n        console.error(\'[Terrain] Amandites-Woo network error.\');\n        return;\n      }\n\n      while (tMaxX <= 1 || tMaxY <= 1 || tMaxZ <= 1) {\n        if (tMaxX < tMaxY) {\n          if (tMaxX < tMaxZ) {\n            i += dx;\n            tMaxX += tDeltaX;\n            ntx = true;\n            nty = false;\n            ntz = false;\n          } else {\n            k += dz;\n            tMaxZ += tDeltaZ;\n            ntx = false;\n            nty = false;\n            ntz = true;\n          }\n        } else // if (tMaxX >= tMaxY)\n          if (tMaxY < tMaxZ) {\n            j += dy;\n            tMaxY += tDeltaY;\n            ntx = false;\n            nty = true;\n            ntz = false;\n          } else {\n            k += dz;\n            tMaxZ += tDeltaZ;\n            ntx = false;\n            nty = false;\n            ntz = true;\n          }\n\n        if (TerrainCollider.simpleCollide(world, entity, // objects\n        i, j, k, // next voxel coordinates\n        tMaxX, tMaxY, tMaxZ, // current value of t at which p1p2 crosses (x,y,z) orth. comp.\n        tDeltaX, tDeltaY, tDeltaZ, // delta between crosses on orth. comp.\n        dx, dy, dz, // orth. directions of p1p2\n        x1, y1, z1, // starting point\n        x2, y2, z2, // ending point\n        ntx, nty, ntz, // last orth. to be updated (current shift coordinate)\n        p2, // Crop arrival position.\n        doProject // apply projection effect (stable if object is not in an island)\n        )) return true;\n      } // No collision\n\n\n      return false;\n    }\n  }, {\n    key: "simpleCollide",\n    value: function simpleCollide(world, entity, // objects\n    i, j, k, // next voxel coordinates\n    tMaxX, tMaxY, tMaxZ, // current value of t at which p1p2 crosses (x,y,z) orth. comp.\n    tDeltaX, tDeltaY, tDeltaZ, // delta between crosses on orth. comp.\n    dx, dy, dz, // orth. directions of p1p2\n    x1, y1, z1, // starting point\n    x2, y2, z2, // ending point\n    ntx, nty, ntz, // last orth. to be updated (current shift coordinate)\n    newPosition, // position to be cropped to\n    doProject) // use free projection for slippin along cubes\n    {\n      if (world.isFree(i, j, k)) return false; // Collision\n      // Damping on first encountered NFB (collision later on)\n\n      var tol = TerrainCollider.eps; // .00001;\n\n      var nx0 = dx > 0 ? i - tol : i + 1 + tol;\n      var ny0 = dy > 0 ? j - tol : j + 1 + tol;\n      var nz0 = dz > 0 ? k - tol : k + 1 + tol;\n\n      if (ntx) {\n        var t = tMaxX - tDeltaX;\n        var ddx = dx < 0 ? 1 : -1; // Projections\n\n        var nyt = y1 + (y2 - y1) * t;\n        var ny = y1 + (y2 - y1);\n        var dby = Math.abs(Math.floor(ny) - Math.floor(nyt));\n\n        if (doProject && dby < 2) {\n          if (dy < 0) {\n            var free = world.isFree(i + ddx, j - 1, k);\n\n            if (free || dby < 1 && ny > ny0 - 1) {\n              nyt = ny;\n            } else {\n              nyt = ny0 - 1;\n            }\n          }\n\n          if (dy > 0) {\n            var _free = world.isFree(i + ddx, j + 1, k);\n\n            if (_free || dby < 1 && ny < ny0 + 1) {\n              nyt = ny;\n            } else {\n              nyt = ny0 + 1;\n            }\n          }\n        }\n\n        var nzt = z1 + (z2 - z1) * t;\n        var nz = z1 + (z2 - z1);\n        var dbz = Math.abs(Math.floor(nz) - Math.floor(nzt));\n\n        if (doProject && dbz < 2) {\n          if (dz < 0) {\n            var _free2 = world.isFree(i + ddx, j, k - 1);\n\n            if (_free2 || dbz < 1 && nz > nz0 - 1) {\n              nzt = nz;\n            } else {\n              nzt = nz0 - 1;\n            }\n          }\n\n          if (dz > 0) {\n            var _free3 = world.isFree(i + ddx, j, k + 1);\n\n            if (_free3 || dbz < 1 && nz < nz0 + 1) {\n              nzt = nz;\n            } else {\n              nzt = nz0 + 1;\n            }\n          }\n        }\n\n        newPosition[0] = nx0;\n        entity.v1[0] = 0;\n        newPosition[1] = nyt;\n        newPosition[2] = nzt;\n      } else if (nty) {\n        var _t = tMaxY - tDeltaY;\n\n        var ddy = dy < 0 ? 1 : -1; // Projections\n\n        var nxt = x1 + (x2 - x1) * _t;\n        var nx = x1 + (x2 - x1);\n        var dbx = Math.abs(Math.floor(nx) - Math.floor(nxt));\n\n        if (doProject && dbx < 2) {\n          if (dx < 0) {\n            var _free4 = world.isFree(i - 1, j + ddy, k);\n\n            if (_free4 || dbx < 1 && nx > nx0 - 1) {\n              nxt = nx;\n            } else {\n              nxt = nx0 - 1;\n            }\n          }\n\n          if (dx > 0) {\n            var _free5 = world.isFree(i + 1, j + ddy, k);\n\n            if (_free5 || dbx < 1 && nx < nx0 + 1) {\n              nxt = nx;\n            } else {\n              nxt = nx0 + 1;\n            }\n          }\n        }\n\n        var _nzt = z1 + (z2 - z1) * _t;\n\n        var _nz10 = z1 + (z2 - z1);\n\n        var _dbz = Math.abs(Math.floor(_nz10) - Math.floor(_nzt));\n\n        if (doProject && _dbz < 2) {\n          if (dz < 0) {\n            var _free6 = world.isFree(i, j + ddy, k - 1);\n\n            if (_free6 || _dbz < 1 && _nz10 > nz0 - 1) {\n              _nzt = _nz10;\n            } else {\n              _nzt = nz0 - 1;\n            }\n          }\n\n          if (dz > 0) {\n            var _free7 = world.isFree(i, j + ddy, k + 1);\n\n            if (_free7 || _dbz < 1 && _nz10 < nz0 + 1) {\n              _nzt = _nz10;\n            } else {\n              _nzt = nz0 + 1;\n            }\n          }\n        }\n\n        newPosition[0] = nxt;\n        newPosition[1] = ny0;\n        entity.v1[1] = 0;\n        newPosition[2] = _nzt;\n      } else if (ntz) {\n        var _t2 = tMaxZ - tDeltaZ;\n\n        var ddz = dz < 0 ? 1 : -1; // Projections\n\n        var _nxt = x1 + (x2 - x1) * _t2;\n\n        var _nx10 = x1 + (x2 - x1);\n\n        var _dbx = Math.abs(Math.floor(_nx10) - Math.floor(_nxt));\n\n        if (doProject && _dbx < 2) {\n          if (dx < 0) {\n            var _free8 = world.isFree(i - 1, j, k + ddz);\n\n            if (_free8 || _dbx < 1 && _nx10 > nx0 - 1) {\n              _nxt = _nx10;\n            } else {\n              _nxt = nx0 - 1;\n            }\n          }\n\n          if (dx > 0) {\n            var _free9 = world.isFree(i + 1, j, k + ddz);\n\n            if (_free9 || _dbx < 1 && _nx10 < nx0 + 1) {\n              _nxt = _nx10;\n            } else {\n              _nxt = nx0 + 1;\n            }\n          }\n        }\n\n        var _nyt = y1 + (y2 - y1) * _t2;\n\n        var _ny10 = y1 + (y2 - y1);\n\n        var _dby = Math.abs(Math.floor(_ny10) - Math.floor(_nyt));\n\n        if (doProject && _dby < 2) {\n          if (dy < 0) {\n            var _free10 = world.isFree(i, j - 1, k + ddz);\n\n            if (_free10 || _dby < 1 && _ny10 > ny0 - 1) {\n              _nyt = _ny10;\n            } else {\n              _nyt = ny0 - 1;\n            }\n          }\n\n          if (dy > 0) {\n            var _free11 = world.isFree(i, j + 1, k + ddz);\n\n            if (_free11 || _dby < 1 && _ny10 < ny0 + 1) {\n              // || is done last\n              _nyt = _ny10;\n            } else {\n              _nyt = ny0 + 1;\n            }\n          }\n        }\n\n        newPosition[0] = _nxt;\n        newPosition[1] = _nyt;\n        newPosition[2] = nz0;\n        entity.v1[2] = 0;\n      } // Bounce\n      // entity.speed[2] = -(entity.speed[2]-entity._impulseSpeed[2]);\n      // entity.acceleration = [0, 0, 0]; // Use Euler with collisions\n\n\n      return true;\n    }\n  }]);\n\n  return TerrainCollider;\n}();\n\nterrain_defineProperty(TerrainCollider, "eps", 1e-8);\n\nterrain_defineProperty(TerrainCollider, "inveps", 1e8);\n\n/* harmony default export */ var collision_terrain = (TerrainCollider);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_physics/solver/rigid_bodies/rigid_bodies_phase_2.js\nfunction rigid_bodies_phase_2_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rigid_bodies_phase_2_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rigid_bodies_phase_2_createClass(Constructor, protoProps, staticProps) { if (protoProps) rigid_bodies_phase_2_defineProperties(Constructor.prototype, protoProps); if (staticProps) rigid_bodies_phase_2_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Island computation,\n * early terrain collision.\n */\n\n\nvar rigid_bodies_phase_2_RigidBodiesPhase2 = /*#__PURE__*/function () {\n  function RigidBodiesPhase2() {\n    rigid_bodies_phase_2_classCallCheck(this, RigidBodiesPhase2);\n  }\n\n  rigid_bodies_phase_2_createClass(RigidBodiesPhase2, null, [{\n    key: "computeIslands",\n    value: function computeIslands(leapfrogArray, searcher, oxToIslandIndex, islands) {\n      var numberOfEntities = leapfrogArray.length;\n      var islandIndex = 0;\n      oxToIslandIndex.fill(-2); // -2 unaffected, -1 isolated, 0+ index of island\n\n      for (var i = 0; i < numberOfEntities; ++i) {\n        var xIndex = leapfrogArray[i][3];\n        var inheritedIslandIndex = oxToIslandIndex[xIndex];\n        var newIsland = searcher.computeIsland(leapfrogArray, i);\n        var il = newIsland.length;\n\n        if (inheritedIslandIndex !== -2) {\n          if (inheritedIslandIndex === -1) throw Error(\'[RigidBodies] @ islands: I think \' + \'no item present in an 1-island should be rediscovered \' + \'by the algorithm. (?)\');\n\n          switch (il) {\n            case 0:\n              // throw Error(\'[RigidBodies] got a 0-length island.\');\n              break;\n\n            case 1:\n              if (oxToIslandIndex[newIsland[0]] !== inheritedIslandIndex) throw Error(\'[RigidBodies] @ islands: verification failed \' + \'on basic 1-island criterion.\');\n              break;\n\n            default:\n              var toAugmentIsland = islands[inheritedIslandIndex];\n\n              for (var j = 0; j < il; ++j) {\n                var nij = newIsland[j];\n\n                if (toAugmentIsland.indexOf(nij) < 0) {\n                  oxToIslandIndex[nij] = inheritedIslandIndex;\n                  toAugmentIsland.push(nij);\n                }\n              }\n\n              break;\n          }\n        } else {\n          switch (il) {\n            case 0:\n              // console.error(\'[RigidBodies] got a 0-length island.\');\n              break;\n\n            case 1:\n              oxToIslandIndex[newIsland[0]] = -1; // May move freely.\n\n              break;\n\n            default:\n              for (var _j = 0; _j < il; ++_j) {\n                oxToIslandIndex[newIsland[_j]] = islandIndex;\n              }\n\n              islands.push(newIsland);\n              islandIndex++;\n              break;\n          }\n        }\n      } // Merge islands.\n      // This could be optimised but I will drop support for this solver.\n\n\n      for (var _i = 0; _i < islands.length; ++_i) {\n        var islandI = islands[_i];\n\n        for (var _j2 = islands.length - 1; _j2 > _i; --_j2) {\n          var islandJ = islands[_j2];\n\n          for (var k = 0; k < islandI.length; ++k) {\n            if (islandJ.indexOf(islandI[k]) > 0) {\n              // Merge within I and pop.\n              for (var q = 0; q < islandJ.length; ++q) {\n                var ijq = islandJ[q];\n                if (islandI.indexOf(ijq) < 0) islandI.push(ijq);\n              }\n\n              islands.splice(_j2, 1);\n              break;\n            }\n          }\n        }\n      }\n\n      var dbg = false;\n      if (dbg) for (var _i2 = 0; _i2 < islands.length; ++_i2) {\n        islands[_i2].sort();\n      }\n    }\n    /**\n     * Solving terrain collisions globally at the moment.\n     * Not only lonely islands.\n     */\n\n  }, {\n    key: "collideLonelyIslandsWithTerrain",\n    value: function collideLonelyIslandsWithTerrain(oxAxis, entities, oxToIslandIndex, islands, world, rigidBodiesSolver) {\n      for (var oi = 0, ol = oxAxis.length; oi < ol; ++oi) {\n        var currentObject = oxAxis[oi];\n        if (!currentObject || currentObject.kind !== \'e\') continue;\n        var entityIndex = oxAxis[oi].id;\n        var currentEntity = entities[entityIndex];\n        if (!currentEntity) continue;\n        var p0 = currentEntity.p0;\n        var p1 = currentEntity.p1;\n\n        if (!p0 || isNaN(p0[0]) || isNaN(p0[1]) || isNaN(p0[2]) || !p1 || isNaN(p1[0]) || isNaN(p1[1]) || isNaN(p1[2])) {\n          continue;\n        } // Cast on current world to prevent x crossing through matter.\n        // const dtr = currentEntity.dtr; // To use time dilation\n        // Filter here for lonely islands.\n        // let islandId = oxToIslandIndex[oi];\n        // let doProject = islandId === -1 || islandId === -2;\n\n\n        var abs = Math.abs;\n        var g = rigidBodiesSolver.getGravity(world, world.worldId, p0[0], p0[1], p0[2]);\n        var hasCollided = false;\n        if (abs(g[0]) > 0 && abs(g[1]) === 0 && abs(g[2]) === 0) hasCollided = collision_terrain.collideLinearX(currentEntity, world, p0, p1, true);else if (abs(g[1]) > 0 && abs(g[0]) === 0 && abs(g[2]) === 0) hasCollided = collision_terrain.collideLinearY(currentEntity, world, p0, p1, true);else // if (abs(g[2]) > 0 && abs(g[1]) === 0 && abs(g[0]) === 0)\n          hasCollided = collision_terrain.collideLinearZ(currentEntity, world, p0, p1, true);\n\n        if (hasCollided && currentEntity._isProjectile) {\n          currentEntity.p1[0] = currentEntity.p0[0];\n          currentEntity.p1[1] = currentEntity.p0[1];\n          currentEntity.p1[2] = currentEntity.p0[2];\n          currentEntity.collided = true;\n        } // Remember to apply the same kind of changes to the simple entity + terrain solver (just below).\n\n      }\n    }\n  }, {\n    key: "simpleCollideEntitiesWithTerrain",\n    value: function simpleCollideEntitiesWithTerrain(oxAxis, entities, world, rigidBodiesSolver) {\n      for (var oi = 0, ol = oxAxis.length; oi < ol; ++oi) {\n        var currentObject = oxAxis[oi];\n        if (!currentObject || currentObject.kind !== \'e\') continue;\n        var entityIndex = oxAxis[oi].id;\n        var currentEntity = entities[entityIndex];\n        if (!currentEntity) continue;\n        var p0 = currentEntity.p0;\n        var p1 = currentEntity.p1;\n\n        if (!p0 || isNaN(p0[0]) || isNaN(p0[1]) || isNaN(p0[2]) || !p1 || isNaN(p1[0]) || isNaN(p1[1]) || isNaN(p1[2])) {\n          continue;\n        } // Cast on current world to prevent x crossing through matter.\n        // const dtr = currentEntity.dtr;\n\n\n        var abs = Math.abs;\n        var g = rigidBodiesSolver.getGravity(world, world.worldId, p0[0], p0[1], p0[2]);\n        var hasCollided = void 0;\n        if (abs(g[0]) > 0 && abs(g[1]) === 0 && abs(g[2]) === 0) hasCollided = collision_terrain.collideLinearX(currentEntity, world, p0, p1, true);else if (abs(g[1]) > 0 && abs(g[0]) === 0 && abs(g[2]) === 0) hasCollided = collision_terrain.collideLinearY(currentEntity, world, p0, p1, true);else // if (abs(g[2]) > 0 && abs(g[1]) === 0 && abs(g[0]) === 0)\n          hasCollided = collision_terrain.collideLinearZ(currentEntity, world, p0, p1, true);\n        var dbg = false;\n\n        if (dbg && hasCollided) {\n          console.log(entityIndex);\n        }\n\n        if (hasCollided && currentEntity._isProjectile) {\n          currentEntity.p1[0] = currentEntity.p0[0];\n          currentEntity.p1[1] = currentEntity.p0[1];\n          currentEntity.p1[2] = currentEntity.p0[2];\n          currentEntity.collided = true;\n        } // Here bounce components could be reported as the inverse velocity at the impact point.\n\n      }\n    }\n  }]);\n\n  return RigidBodiesPhase2;\n}();\n\n/* harmony default export */ var rigid_bodies_phase_2 = (rigid_bodies_phase_2_RigidBodiesPhase2);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_physics/solver/rigid_bodies/rigid_bodies_phase_3.js\nfunction rigid_bodies_phase_3_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rigid_bodies_phase_3_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rigid_bodies_phase_3_createClass(Constructor, protoProps, staticProps) { if (protoProps) rigid_bodies_phase_3_defineProperties(Constructor.prototype, protoProps); if (staticProps) rigid_bodies_phase_3_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @deprecated\n */\nvar RigidBodiesPhase3 = /*#__PURE__*/function () {\n  function RigidBodiesPhase3() {\n    rigid_bodies_phase_3_classCallCheck(this, RigidBodiesPhase3);\n  }\n\n  rigid_bodies_phase_3_createClass(RigidBodiesPhase3, null, [{\n    key: "solveBabylon",\n\n    /**\n     * @deprecated\n     */\n    value: function solveBabylon(a, b, c, sup) {\n      if (a === 0) {\n        if (b === 0) return sup;else return -c / b;\n      }\n\n      var delta = b * b - 4 * a * c;\n\n      if (delta > 0) {\n        var sd = Math.sqrt(delta);\n        var r1 = (-b - sd) / (2 * a);\n        var r2 = (-b + sd) / (2 * a);\n        if (r1 >= 0 && r2 >= 0) return Math.min(r1, r2);else if (r1 >= 0 || r2 >= 0) return Math.max(Math.max(r1, r2), 0);else return sup;\n      } else if (delta === 0) {\n        // if (debug) console.log(\'delta = 0\');\n        if (a === 0) return sup;else return -b / (2 * a);\n      }\n\n      return 0;\n    }\n    /**\n     * @deprecated\n     */\n\n  }, {\n    key: "solveSecondOrder",\n    value: function solveSecondOrder(a1, a2, b1, b2, p10, p20, p11, p21, // Unnecessary\n    w1, w2, fw, relativeDt) {\n      // Check for snapping on first trajectory.\n      var dbg = false; // There is a farther entity problem.\n\n      var rp1 = RigidBodiesPhase3.solveBabylon(a1, b1, p10 - p11, 2 * relativeDt);\n\n      if (p10 < p11 && a1 * relativeDt * relativeDt + b1 * relativeDt + p10 < p11 || p10 > p11 && p11 < a1 * relativeDt * relativeDt + b1 * relativeDt + p10) {\n        if (dbg) console.log("[SecondOrder] Farther entity (1): ".concat(rp1, " | from ") + "".concat(a1 * relativeDt * relativeDt + b1 * relativeDt + p10, " to ").concat(p11, "."));\n      } // Check for snapping on second trajectory.\n\n\n      var rp2 = RigidBodiesPhase3.solveBabylon(a2, b2, p20 - p21, 2 * relativeDt);\n\n      if (p20 < p21 && a2 * relativeDt * relativeDt + b2 * relativeDt + p20 < p21 || p20 > p21 && p21 < a2 * relativeDt * relativeDt + b2 * relativeDt + p20) {\n        if (dbg) console.log("[SecondOrder] Farther entity (2): ".concat(rp2, " | from ") + "".concat(a2 * relativeDt * relativeDt + b2 * relativeDt + p20, " to ").concat(p21, "."));\n      } // Solve free 2-collision.\n\n\n      var rp12 = RigidBodiesPhase3.solveBabylon(a1 - a2, b1 - b2, fw * w1 + fw * w2 + p10 - p20, 2 * relativeDt); //, true);\n      // let rp12 = 2 * relativeDt;\n      // if (a1 !== a2)\n      // else if (b1 !== b2)\n      //     rp12 = (fw * w1 + fw * w2 + p10 - p20) / (b2 - b1);\n\n      if (rp12 === 0) {\n        if (dbg) console.log(\'[SecondOrder] Unlikely zero output from babylon solver...\');\n      } // Both trajectories should not be snapped at the same time.\n      // if (rp12 > rp1 && relativeDt > rp1 && rp12 > rp2 && relativeDt > rp2)\n      // {\n      //     console.log(\'Two colliding bodies saw their trajectory snapped on the same axis... Think about it.\');\n      // }\n      // In case of (1)-snap.\n\n\n      if ((rp12 > rp1 || rp12 < 0) && relativeDt > rp1 && rp1 >= 0) {\n        // Solve constrained (1)-end-of-line collision.\n        var rp3 = RigidBodiesPhase3.solveBabylon(a2, b2, -fw * w1 - fw * w2 + p20 - p11, 2 * relativeDt); // console.log(`Constrained (1): ${rp3} | ${rp12}`);\n\n        if ((rp12 < 0 || rp12 > rp3) && rp3 >= 0) rp12 = rp3;\n        if (rp3 > relativeDt) rp12 = 0;\n      } // In case of (2)-snap.\n\n\n      if ((rp12 > rp2 || rp12 < 0) && relativeDt > rp2 && rp2 >= 0) {\n        // Solve constrained (2)-end-of-line collision.\n        var rp4 = RigidBodiesPhase3.solveBabylon(a1, b1, fw * w1 + fw * w2 + p10 - p21, 2 * relativeDt); // console.log(`Constrained (2): ${rp4} | ${rp12}`);\n\n        if ((rp12 < 0 || rp12 > rp4) && rp4 >= 0) rp12 = rp4;\n        if (rp4 > relativeDt) rp12 = 0;\n      }\n\n      if (rp12 < 0 || rp12 >= relativeDt) {\n        if (dbg) {\n          console.log(\'r computation error\');\n          console.log("\\tb1, b2 = ".concat(b1, ", ").concat(b2, "\\n") + "\\tw1, w2 = ".concat(w1, ", ").concat(w2, "\\n") + "\\tp01, p02 = ".concat(p10, ", ").concat(p20, "\\n") + "\\tp11, p12 = ".concat(p11, ", ").concat(p21, "\\n") + "\\tfw = ".concat(fw, "\\n"));\n          console.log("r=".concat(rp12, " (z), reldt=").concat(relativeDt));\n        }\n\n        rp12 = 2 * relativeDt;\n      } // if (Math.abs(rp12) < 1e-7) rp12 = 0;\n\n\n      if (rp12 === 0) {\n        if (dbg) console.log(\'[SecondOrder] Zero-collision.\');\n      }\n\n      if (dbg) {\n        // console.log(\'deg 1 \' + (b2-b1) + \', \' + (fw*w1x + fw*w2x+p10x-p20x));\n        console.log(rp12);\n      }\n\n      return rp12;\n    }\n    /**\n     * @deprecated\n     */\n\n  }, {\n    key: "solveLeapfrogPostCollision",\n    value: function solveLeapfrogPostCollision(island, newSubIsland, entityIdsInIslandWhichNeedTerrainPostSolving, oxAxis, entities, relativeDt, mapCollidingPossible) {\n      var islandLength = island.length; // let newSubIslandLength = newSubIsland.length;\n      // Solve in newSubIsland x island\\newSubIsland\n\n      for (var i = 0; i < islandLength; ++i) {\n        var xIndexI = island[i];\n        var id1 = oxAxis[xIndexI].id;\n        var e1 = entities[id1];\n        var p10 = e1.p0;\n        var p10x = p10[0];\n        var p10y = p10[1];\n        var p10z = p10[2];\n        var p11 = e1.p1;\n        var p11x = p11[0];\n        var p11y = p11[1];\n        var p11z = p11[2];\n        var p1adh = e1.adherence;\n        var p1v0 = e1.v0;\n        var p1a0 = e1.a0;\n        var p1n0 = e1.nu1;\n        var w1x = e1.widthX;\n        var w1y = e1.widthY;\n        var w1z = e1.widthZ;\n        var ltd1 = e1.dtr;\n        var newSubIslandIndexI = newSubIsland.indexOf(i);\n        var iInNewSubIsland = newSubIslandIndexI > -1;\n\n        for (var j = i + 1; j < islandLength; ++j) {\n          var xIndexJ = island[j];\n          var newSubIslandIndexJ = newSubIsland.indexOf(j);\n          var jInNewSubIsland = newSubIslandIndexJ > -1; // does this work as expected?\n\n          var goOn = !iInNewSubIsland && jInNewSubIsland || iInNewSubIsland && !jInNewSubIsland;\n\n          if (!goOn) {// Also solve in island x entityIdsInIslandWhichNeedTerrainPostSolving\\{currentInIsland}\n          }\n\n          var id2 = oxAxis[xIndexJ].id;\n          var e2 = entities[id2];\n          var p20 = e2.p0;\n          var p20x = p20[0];\n          var p20y = p20[1];\n          var p20z = p20[2];\n          var p21 = e2.p1;\n          var p21x = p21[0];\n          var p21y = p21[1];\n          var p21z = p21[2];\n          var p2adh = e2.adherence;\n          var p2v0 = e2.v0;\n          var p2a0 = e2.a0;\n          var p2n0 = e2.nu1;\n          var w2x = e2.widthX;\n          var w2y = e2.widthY;\n          var w2z = e2.widthZ;\n          var ltd2 = e2.dtr;\n          var debugFlag = false;\n          if (debugFlag) console.log("\\t\\t\\tTesting ".concat(e1.entityId, " vs ").concat(e2.entityId, "..."));\n          var x0l = p10x + w1x <= p20x - w2x;\n          var y0l = p10y + w1y <= p20y - w2y;\n          var z0l = p10z + w1z <= p20z - w2z;\n          var x1l = p11x + w1x <= p21x - w2x;\n          var y1l = p11y + w1y <= p21y - w2y;\n          var z1l = p11z + w1z <= p21z - w2z;\n          var x0r = p10x - w1x >= p20x + w2x;\n          var y0r = p10y - w1y >= p20y + w2y;\n          var z0r = p10z - w1z >= p20z + w2z;\n          var x1r = p11x - w1x >= p21x + w2x;\n          var y1r = p11y - w1y >= p21y + w2y;\n          var z1r = p11z - w1z >= p21z + w2z;\n          if (x0l && x1l || x0r && x1r || y0l && y1l || y0r && y1r || z0l && z1l || z0r && z1r) continue;\n          var xl = x0l && !x1l;\n          var yl = y0l && !y1l;\n          var zl = z0l && !z1l;\n          var xm = !x0l && !x0r;\n          var ym = !y0l && !y0r;\n          var zm = !z0l && !z0r;\n          var xw = !x1l && !x1r;\n          var yw = !y1l && !y1r;\n          var zw = !z1l && !z1r;\n\n          if (xm && ym && zm) {\n            if (debugFlag) console.warn(\'[Phase III - PostCollision] Full 3D clip detected.\');\n            continue;\n          }\n\n          if (!xm + !ym + !zm !== 1) {\n            if (debugFlag) console.warn(\'[Phase III - PostCollision] Corner 2D clip detected.\');\n          }\n\n          if (!(xw && yw && zw)) continue;\n          var rrel = relativeDt;\n          var axis = \'none\';\n\n          if (!xm) {\n            var fw = xl ? 1 : -1;\n            var adh10 = p1adh[0];\n            var adh11 = p1adh[3];\n            var a1 = ltd1 * ltd1 * .5 * p1a0[0];\n            if (p10x <= p11x && adh11 || p10x >= p11x && adh10) a1 = 0;\n            var adh20 = p2adh[0];\n            var adh21 = p2adh[3];\n            var a2 = ltd2 * ltd2 * .5 * p2a0[0];\n            if (p20x <= p21x && adh21 || p20x >= p21x && adh20) a2 = 0;\n            var b1 = ltd1 * (p1v0[0] + p1n0[0]);\n            var b2 = ltd2 * (p2v0[0] + p2n0[0]);\n            var r = RigidBodiesPhase3.solveSecondOrder(a1, a2, b1, b2, p10x, p20x, p11x, p21x, w1x, w2x, fw, relativeDt);\n\n            if (r >= 0 && r < rrel) {\n              axis = \'x\';\n              rrel = r;\n            }\n          }\n\n          if (!ym) {\n            var _fw = yl ? 1 : -1;\n\n            var _adh = p1adh[1];\n            var _adh2 = p1adh[4];\n\n            var _a = ltd1 * ltd1 * .5 * p1a0[1];\n\n            if (p10y <= p11y && _adh2 || p10y >= p11y && _adh) _a = 0;\n            var _adh3 = p2adh[1];\n            var _adh4 = p2adh[4];\n\n            var _a2 = ltd2 * ltd2 * .5 * p2a0[1];\n\n            if (p20y <= p21y && _adh4 || p20y >= p21y && _adh3) _a2 = 0;\n\n            var _b = ltd1 * (p1v0[1] + p1n0[1]);\n\n            var _b2 = ltd2 * (p2v0[1] + p2n0[1]);\n\n            var _r = RigidBodiesPhase3.solveSecondOrder(_a, _a2, _b, _b2, p10y, p20y, p11y, p21y, w1y, w2y, _fw, relativeDt); // if (abs(r) < 1e-7) r = 0;\n\n\n            if (_r >= 0 && _r < rrel) {\n              axis = \'y\';\n              rrel = _r;\n            }\n          }\n\n          if (!zm) {\n            var _fw2 = zl ? 1 : -1;\n\n            var _adh5 = p1adh[2];\n            var _adh6 = p1adh[5];\n\n            var _a3 = ltd1 * ltd1 * .5 * p1a0[2];\n\n            if (p10z <= p11z && _adh6 || p10z >= p11z && _adh5) _a3 = 0;\n            var _adh7 = p2adh[2];\n            var _adh8 = p2adh[5];\n\n            var _a4 = ltd2 * ltd2 * .5 * p2a0[2];\n\n            if (p20z <= p21z && _adh8 || p20z >= p21z && _adh7) _a4 = 0;\n\n            var _b3 = ltd1 * (p1v0[2] + p1n0[2]);\n\n            var _b4 = ltd2 * (p2v0[2] + p2n0[2]);\n\n            var _r2 = RigidBodiesPhase3.solveSecondOrder(_a3, _a4, _b3, _b4, p10z, p20z, p11z, p21z, w1z, w2z, _fw2, relativeDt);\n\n            if (_r2 >= 0 && _r2 < rrel) {\n              axis = \'z\';\n              rrel = _r2;\n            }\n          }\n\n          if (debugFlag) console.log("\\t\\t\\t\\tGot ".concat(rrel));\n\n          if (rrel < relativeDt) {\n            if (debugFlag) console.log("\\t\\tRe-solving ".concat(e1.entityId, " vs ").concat(e2.entityId, " -> t = ").concat(rrel));\n            mapCollidingPossible.push([i, j, rrel, axis]);\n          }\n        }\n      }\n    } // Does not account for time dilation, but can with minor modifications.\n\n    /**\n     * @deprecated\n     */\n\n  }, {\n    key: "solveLeapfrogQuadratic",\n    value: function solveLeapfrogQuadratic(island, oxAxis, entities, relativeDt, mapCollidingPossible) {\n      var nbI = island.length;\n\n      for (var i = 0; i < nbI; ++i) {\n        var xIndex1 = island[i];\n        var id1 = oxAxis[xIndex1].id;\n        var e1 = entities[id1];\n        var p10 = e1.p0;\n        var p10x = p10[0];\n        var p10y = p10[1];\n        var p10z = p10[2];\n        var p11 = e1.p1;\n        var p11x = p11[0];\n        var p11y = p11[1];\n        var p11z = p11[2];\n        var p1adh = e1.adherence;\n        var p1v0 = e1.v0;\n        var p1a0 = e1.a0;\n        var p1n0 = e1.nu1;\n        var w1x = e1.widthX;\n        var w1y = e1.widthY;\n        var w1z = e1.widthZ;\n        var ltd1 = e1.dtr; // this.getTimeDilation(worldId, p1_0[0], p1_0[1], p1_0[2]);\n        // const dta1 = absoluteDt * ltd1;\n        // const dtr1 = relativeDt * ltd1;\n\n        for (var j = i + 1; j < nbI; ++j) {\n          var xIndex2 = island[j];\n          var id2 = oxAxis[xIndex2].id;\n          var e2 = entities[id2];\n          var p20 = e2.p0;\n          var p20x = p20[0];\n          var p20y = p20[1];\n          var p20z = p20[2];\n          var p21 = e2.p1;\n          var p21x = p21[0];\n          var p21y = p21[1];\n          var p21z = p21[2];\n          var p2adh = e2.adherence;\n          var p2v0 = e2.v0;\n          var p2a0 = e2.a0;\n          var p2n0 = e2.nu1;\n          var w2x = e2.widthX;\n          var w2y = e2.widthY;\n          var w2z = e2.widthZ;\n          var ltd2 = e2.dtr; // this.getTimeDilation(worldId, p2_0[0], p2_0[1], p2_0[2]);\n          // const dta2 = absoluteDt * ltd2;\n          // const dtr2 = relativeDt * ltd2;\n\n          var x0l = p10x + w1x <= p20x - w2x;\n          var y0l = p10y + w1y <= p20y - w2y;\n          var z0l = p10z + w1z <= p20z - w2z;\n          var x1l = p11x + w1x <= p21x - w2x;\n          var y1l = p11y + w1y <= p21y - w2y;\n          var z1l = p11z + w1z <= p21z - w2z;\n          var x0r = p10x - w1x >= p20x + w2x;\n          var y0r = p10y - w1y >= p20y + w2y;\n          var z0r = p10z - w1z >= p20z + w2z;\n          var x1r = p11x - w1x >= p21x + w2x;\n          var y1r = p11y - w1y >= p21y + w2y;\n          var z1r = p11z - w1z >= p21z + w2z;\n\n          if (x0l && x1l || x0r && x1r || y0l && y1l || y0r && y1r || z0l && z1l || z0r && z1r) {\n            continue;\n          }\n\n          var xl = x0l && !x1l;\n          var yl = y0l && !y1l;\n          var zl = z0l && !z1l;\n          var xm = !x0l && !x0r;\n          var ym = !y0l && !y0r;\n          var zm = !z0l && !z0r;\n          var xw = !x1l && !x1r;\n          var yw = !y1l && !y1r;\n          var zw = !z1l && !z1r;\n          var debugCollision = false;\n\n          if (xm && ym && zm) {\n            if (debugCollision) console.log(\'[Phase III - PreCollision] Full 3D clip detected.\');\n            continue;\n          }\n\n          if (!xm + !ym + !zm !== 1) {\n            if (debugCollision) console.log(\'[Phase III - PreCollision] Corner 2D clip detected.\');\n          }\n\n          if (!(xw && yw && zw)) {\n            continue;\n          }\n\n          var rrel = relativeDt;\n          var axis = \'none\'; // Quadratic solve thrice\n\n          if (!xm) {\n            var fw = xl ? 1 : -1;\n            var adh10 = p1adh[0];\n            var adh11 = p1adh[3];\n            var a1 = ltd1 * ltd1 * .5 * p1a0[0];\n            if (p10x <= p11x && adh11 || p10x >= p11x && adh10) a1 = 0;\n            var adh20 = p2adh[0];\n            var adh21 = p2adh[3];\n            var a2 = ltd2 * ltd2 * .5 * p2a0[0];\n            if (p20x <= p21x && adh21 || p20x >= p21x && adh20) a2 = 0;\n            var b1 = ltd1 * (p1v0[0] + p1n0[0]);\n            var b2 = ltd2 * (p2v0[0] + p2n0[0]);\n            var r = RigidBodiesPhase3.solveSecondOrder(a1, a2, b1, b2, p10x, p20x, p11x, p21x, w1x, w2x, fw, relativeDt);\n\n            if (r >= 0 && r < rrel) {\n              axis = \'x\';\n              rrel = r;\n            }\n          }\n\n          if (!ym) {\n            var _fw3 = yl ? 1 : -1;\n\n            var _adh9 = p1adh[1];\n            var _adh10 = p1adh[4];\n\n            var _a5 = ltd1 * ltd1 * .5 * p1a0[1];\n\n            if (p10y <= p11y && _adh10 || p10y >= p11y && _adh9) _a5 = 0;\n            var _adh11 = p2adh[1];\n            var _adh12 = p2adh[4];\n\n            var _a6 = ltd2 * ltd2 * .5 * p2a0[1];\n\n            if (p20y <= p21y && _adh12 || p20y >= p21y && _adh11) _a6 = 0;\n\n            var _b5 = ltd1 * (p1v0[1] + p1n0[1]);\n\n            var _b6 = ltd2 * (p2v0[1] + p2n0[1]);\n\n            var _r3 = RigidBodiesPhase3.solveSecondOrder(_a5, _a6, _b5, _b6, p10y, p20y, p11y, p21y, w1y, w2y, _fw3, relativeDt);\n\n            if (_r3 >= 0 && _r3 < rrel) {\n              axis = \'y\';\n              rrel = _r3;\n            }\n          }\n\n          if (!zm) {\n            var _fw4 = zl ? 1 : -1;\n\n            var _adh13 = p1adh[2];\n            var _adh14 = p1adh[5];\n\n            var _a7 = ltd1 * ltd1 * .5 * p1a0[2];\n\n            if (p10z <= p11z && _adh14 || p10z >= p11z && _adh13) _a7 = 0;\n            var _adh15 = p2adh[2];\n            var _adh16 = p2adh[5];\n\n            var _a8 = ltd2 * ltd2 * .5 * p2a0[2];\n\n            if (p20z <= p21z && _adh16 || p20z >= p21z && _adh15) _a8 = 0;\n\n            var _b7 = ltd1 * (p1v0[2] + p1n0[2]);\n\n            var _b8 = ltd2 * (p2v0[2] + p2n0[2]);\n\n            var _r4 = RigidBodiesPhase3.solveSecondOrder(_a7, _a8, _b7, _b8, p10z, p20z, p11z, p21z, w1z, w2z, _fw4, relativeDt);\n\n            if (_r4 >= 0 && _r4 < rrel) {\n              axis = \'z\';\n              rrel = _r4;\n            }\n          }\n\n          if (rrel < relativeDt) {\n            mapCollidingPossible.push([i, j, rrel, axis]);\n          }\n        }\n      }\n    }\n    /**\n     * @deprecated\n     */\n\n  }, {\n    key: "getSubIsland",\n    value: function getSubIsland(islandIndex, axis, objectIndexInIslandToSubIslandXIndex, objectIndexInIslandToSubIslandYIndex, objectIndexInIslandToSubIslandZIndex, subIslandsX, subIslandsY, subIslandsZ) {\n      var subIslandIndex = -1;\n\n      switch (axis) {\n        case \'x\':\n          subIslandIndex = objectIndexInIslandToSubIslandXIndex[islandIndex];\n          return subIslandIndex === -1 ? null : subIslandsX[subIslandIndex];\n\n        case \'y\':\n          subIslandIndex = objectIndexInIslandToSubIslandYIndex[islandIndex];\n          return subIslandIndex === -1 ? null : subIslandsY[subIslandIndex];\n\n        case \'z\':\n          subIslandIndex = objectIndexInIslandToSubIslandZIndex[islandIndex];\n          return subIslandIndex === -1 ? null : subIslandsZ[subIslandIndex];\n\n        default:\n          console.log(\'[SubIsland] Undefined axis.\');\n          return null;\n      }\n    }\n    /**\n     * @deprecated\n     */\n\n  }, {\n    key: "mergeSubIslands",\n    value: function mergeSubIslands(indexI, indexJ, subIslandI, subIslandJ, objectIndexInIslandToSubIslandXIndex, objectIndexInIslandToSubIslandYIndex, objectIndexInIslandToSubIslandZIndex, subIslandsX, subIslandsY, subIslandsZ, axis) {\n      if (axis !== \'x\' && axis !== \'y\' && axis !== \'z\') {\n        console.log(\'Undefined axis.\');\n        return;\n      }\n\n      var toSubIslandIndex = null;\n      var subIslandArray;\n      var newSubIsland;\n\n      switch (axis) {\n        case \'x\':\n          toSubIslandIndex = objectIndexInIslandToSubIslandXIndex;\n          subIslandArray = subIslandsX;\n          break;\n\n        case \'y\':\n          toSubIslandIndex = objectIndexInIslandToSubIslandYIndex;\n          subIslandArray = subIslandsY;\n          break;\n\n        case \'z\':\n          toSubIslandIndex = objectIndexInIslandToSubIslandZIndex;\n          subIslandArray = subIslandsZ;\n          break;\n\n        default:\n          break;\n      }\n\n      if (subIslandI && subIslandJ) {\n        var li = subIslandI.length;\n        var lj = subIslandJ.length;\n\n        if (li < lj) {\n          newSubIsland = subIslandJ;\n\n          for (var i = li - 1; i >= 0; --i) {\n            var element = subIslandI[i];\n            subIslandJ.push(element);\n            toSubIslandIndex[element] = toSubIslandIndex[indexJ];\n            subIslandI.pop();\n          }\n        } else {\n          newSubIsland = subIslandI;\n\n          for (var j = lj - 1; j >= 0; --j) {\n            var _element = subIslandJ[j];\n            subIslandI.push(_element);\n            toSubIslandIndex[_element] = toSubIslandIndex[indexI];\n            subIslandJ.pop();\n          }\n        }\n      } else if (subIslandI) {\n        newSubIsland = subIslandI;\n        toSubIslandIndex[indexJ] = toSubIslandIndex[indexI];\n        subIslandI.push(indexJ);\n      } else if (subIslandJ) {\n        newSubIsland = subIslandJ;\n        toSubIslandIndex[indexI] = toSubIslandIndex[indexJ];\n        subIslandJ.push(indexI);\n      } else {\n        // Insert new sub island.\n        var newId = subIslandArray.length;\n        newSubIsland = [indexI, indexJ];\n        subIslandArray.push(newSubIsland);\n        toSubIslandIndex[indexI] = newId;\n        toSubIslandIndex[indexJ] = newId;\n      }\n\n      return newSubIsland;\n    }\n    /**\n     * @deprecated\n     */\n\n  }, {\n    key: "applyCollision",\n    value: function applyCollision(i, j, r, axis, island, oxAxis, entities, relativeDt, epsilon) {\n      var xIndex1 = island[i];\n      var id1 = oxAxis[xIndex1].id;\n      var e1 = entities[id1];\n      var p10 = e1.p0;\n      var p10x = p10[0];\n      var p10y = p10[1];\n      var p10z = p10[2];\n      var p11 = e1.p1;\n      var p11x = p11[0];\n      var p11y = p11[1];\n      var p11z = p11[2];\n      var p1v0 = e1.v0;\n      var p1v1 = e1.v1;\n      var p1a0 = e1.a0;\n      var p1a1 = e1.a1;\n      var p1n0 = e1.nu1;\n      var w1x = e1.widthX;\n      var w1y = e1.widthY;\n      var w1z = e1.widthZ;\n      var ltd1 = e1.dtr;\n      var sndtr1 = r; // * ltd1;\n\n      var xIndex2 = island[j];\n      var id2 = oxAxis[xIndex2].id;\n      var e2 = entities[id2];\n      var p20 = e2.p0;\n      var p20x = p20[0];\n      var p20y = p20[1];\n      var p20z = p20[2];\n      var p21 = e2.p1;\n      var p21x = p21[0];\n      var p21y = p21[1];\n      var p21z = p21[2];\n      var p2v0 = e2.v0;\n      var p2v1 = e2.v1;\n      var p2a0 = e2.a0;\n      var p2a1 = e2.a1;\n      var p2n0 = e2.nu1;\n      var w2x = e2.widthX;\n      var w2y = e2.widthY;\n      var w2z = e2.widthZ;\n      var ltd2 = e2.dtr;\n      var sndtr2 = r; // * ltd2;\n      // Snap p1.\n\n      var x0l = p10x + w1x <= p20x - w2x;\n      var y0l = p10y + w1y <= p20y - w2y;\n      var z0l = p10z + w1z <= p20z - w2z;\n      var x1l = p11x + w1x <= p21x - w2x;\n      var y1l = p11y + w1y <= p21y - w2y;\n      var z1l = p11z + w1z <= p21z - w2z;\n      var x0r = p10x - w1x >= p20x + w2x;\n      var y0r = p10y - w1y >= p20y + w2y;\n      var z0r = p10z - w1z >= p20z + w2z;\n      var x1r = p11x - w1x >= p21x + w2x;\n      var y1r = p11y - w1y >= p21y + w2y;\n      var z1r = p11z - w1z >= p21z + w2z;\n\n      if (x0l && x1l || x0r && x1r || y0l && y1l || y0r && y1r || z0l && z1l || z0r && z1r) {\n        // Nothing to collide.\n        return;\n      }\n\n      var xm = !x0l && !x0r;\n      var ym = !y0l && !y0r;\n      var zm = !z0l && !z0r;\n      var xw = !x1l && !x1r;\n      var yw = !y1l && !y1r;\n      var zw = !z1l && !z1r;\n      if (xm && ym && zm) console.warn(\'[RigidBodies/Solve] two bodies clipped.\');\n\n      if (xw && yw && zw) {\n        var m2 = [];\n        var wm1 = [w1x, w1y, w1z];\n        var wm2 = [w2x, w2y, w2z];\n        var nep1 = [];\n        var nep2 = [];\n        var ax = axis === \'x\' ? 0 : axis === \'y\' ? 1 : axis === \'z\' ? 2 : -1;\n\n        if (ax < 0) {\n          console.error(\'[Phase III] Invalid axis.\');\n          return;\n        }\n\n        for (var m = 0; m < 3; ++m) // Account for server congestion / lag with relative dilation.\n        {\n          if (m !== ax) continue;\n          var timestep1 = void 0;\n          var timestep2 = void 0;\n\n          if (m === ax) {\n            timestep1 = sndtr1;\n            timestep2 = sndtr2;\n          } else {\n            timestep1 = ltd1;\n            timestep2 = ltd2;\n          }\n\n          var gamma = epsilon;\n          var e1p1i = p11[m];\n          var e1p0i = p10[m];\n          var e1p1n = e1p0i + (p1v0[m] + p1n0[m]) * timestep1 + .5 * p1a0[m] * timestep1 * timestep1;\n          nep1[m] = e1p1i < e1p0i && e1p1n < e1p0i && e1p1i < e1p1n ? // && e1p1n+e < e1p0i && e1p1i < e1p1n+e\n          e1p1n + gamma : e1p0i < e1p1i && e1p0i < e1p1n && e1p1n < e1p1i ? e1p1n - gamma : e1p1i;\n          var e2p1i = p21[m];\n          var e2p0i = p20[m];\n          var e2p1n = e2p0i + (p2v0[m] + p2n0[m]) * timestep2 + .5 * p2a0[m] * timestep2 * timestep2;\n          nep2[m] = e2p1i < e2p0i && e2p1n < e2p0i && e2p1i < e2p1n ? e2p1n + gamma : e2p0i < e2p1i && e2p0i < e2p1n && e2p1n < e2p1i ? e2p1n - gamma : e2p1i;\n          if (e1p1i <= e1p0i && (nep1[m] < e1p1i || nep1[m] > e1p0i) || e1p0i <= e1p1i && (nep1[m] > e1p1i || nep1[m] < e1p0i)) nep1[m] = e1p0i;\n          if (e2p1i <= e2p0i && (nep2[m] < e2p1i || nep2[m] > e2p0i) || e2p0i <= e2p1i && (nep2[m] > e2p1i || nep2[m] < e2p0i)) nep2[m] = e2p0i; // const eeps = 1e-30; // beware of numerical errors here\n\n          m2[m] = nep1[m] + wm1[m] + epsilon / 2.0 > nep2[m] - wm2[m] - epsilon / 2.0 && nep1[m] - wm1[m] - epsilon / 2.0 < nep2[m] + wm2[m] + epsilon / 2.0;\n        } // Remains to check this "lastR" mechanism...\n        // e1.lastR = r;\n        // e2.lastR = r;\n\n\n        for (var _m = 0; _m < 3; ++_m) {\n          if (_m !== ax) continue; // Check terrain...\n\n          var e1p1 = p11[_m];\n          var e2p1 = p21[_m];\n          var e1p0 = p10[_m];\n          var e2p0 = p20[_m];\n          var ne1p1 = nep1[_m];\n          var ne2p1 = nep2[_m];\n          if (e1p0 < e1p1 && ne1p1 < e1p1 || e1p0 > e1p1 && ne1p1 > e1p1) p11[_m] = nep1[_m];\n          if (e2p0 < e2p1 && ne2p1 < e2p1 || e2p0 > e2p1 && ne2p1 > e2p1) p21[_m] = nep2[_m];\n        } // }\n\n\n        var collidedbg = false;\n        if (collidedbg) console.log(\'collide?\');\n        var abs = Math.abs;\n        var e1a1 = e1.a1[ax];\n        var e1v1 = e1.v1[ax];\n        var e2a1 = e2.a1[ax];\n        var e2v1 = e2.v1[ax];\n        var mv = abs(e1v1) < abs(e2v1) ? e1v1 : e2v1;\n        var ma = abs(e1a1) < abs(e2a1) ? e1a1 : e2a1;\n        if (collidedbg) console.log("".concat(e1v1, " | ").concat(e2v1));\n        p1v1[ax] = mv;\n        p2v1[ax] = mv;\n\n        if (m2[ax]) {\n          if (collidedbg) console.log(\'\\tyes!\'); // console.log(\'Correction.\');\n\n          var _e1p = p10[ax];\n          var _e1p2 = p11[ax];\n          var _e2p = p20[ax];\n          var _e2p2 = p21[ax];\n          var e1w = axis === \'x\' ? w1x : axis === \'y\' ? w1y :\n          /* axis === \'z\' ? */\n          w1z;\n          var e2w = axis === \'x\' ? w2x : axis === \'y\' ? w2y :\n          /* axis === \'z\' ? */\n          w2z;\n          var sgn = Math.sign;\n\n          if (_e1p < _e2p) {\n            p1a1[ax] = sgn(e1v1) !== sgn(e2v1) ? 0 : ma;\n            p2a1[ax] = p1a1[ax];\n            RigidBodiesPhase3.correctCollision(e1, _e1p, _e1p2, e1w, e2, _e2p, _e2p2, e2w, ax, epsilon);\n          } else if (_e1p > _e2p) {\n            p1a1[ax] = sgn(e1v1) !== sgn(e2v1) ? 0 : ma;\n            p2a1[ax] = p1a1[ax];\n            RigidBodiesPhase3.correctCollision(e2, _e2p, _e2p2, e2w, e1, _e1p, _e1p2, e1w, ax, epsilon);\n          } else {\n            console.log(\'[Phase III] - on correction, e1p0 == e2p0; this is worrying.\');\n            p11[ax] = _e1p;\n            p21[ax] = _e2p;\n          } // Reset this if there are collision stability problems.\n          // e1.p1[ax] = e1p0;\n          // e2.p1[ax] = e2p0;\n\n        }\n\n        var debug = false;\n\n        if (debug) {\n          console.log("\\tz = ".concat(e1.p0[2], " -> ").concat(e1.p1[2], " , ").concat(e2.p0[2], " -> ").concat(e2.p1[2]));\n        }\n      }\n    } // We have that e1p0 < e2p0.\n\n    /**\n     * @deprecated\n     */\n\n  }, {\n    key: "correctCollision",\n    value: function correctCollision(e1, e1p0, e1p1, e1w, e2, e2p0, e2p1, e2w, ax, epsilon) {\n      var seps = 1e-6;\n      var min = Math.min;\n      var max = Math.max;\n      var overlap = min(e1p0, e1p1) + e1w + e2w + epsilon + seps;\n\n      if (overlap >= max(e2p0, e2p1)) {\n        e1.p1[ax] = e1p0;\n        e2.p1[ax] = e2p0;\n      } else {\n        var den = e1p1 - e1p0 - e2p1 + e2p0;\n\n        if (den === 0) {\n          e1.p1[ax] = e1p0;\n          e2.p1[ax] = e2p0;\n          return;\n        }\n\n        var alpha = e1p1 - e1p0;\n        var beta = e2p1 - e2p0;\n        var num = e2p0 - e1p0 - e1w - e2w - epsilon - seps;\n        var e1t = e1p0 + num / den * alpha;\n        var e2t = e2p0 + num / den * beta;\n\n        if (e1t <= max(e1p0, e1p1) && e1t >= min(e1p0, e1p1) && e2t <= max(e2p0, e2p1) && e2t >= min(e2p0, e1p1) && e1t + e1w + e2w + epsilon + seps <= e2t) {\n          e1.p1[ax] = e1t;\n          e2.p1[ax] = e2t;\n        } else {\n          e1.p1[ax] = e1p0;\n          e2.p1[ax] = e2p0;\n        }\n      }\n    }\n  }]);\n\n  return RigidBodiesPhase3;\n}();\n\n/* harmony default export */ var rigid_bodies_phase_3 = (RigidBodiesPhase3);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_physics/solver/rigid_bodies/rigid_bodies_phase_4.js\nfunction rigid_bodies_phase_4_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rigid_bodies_phase_4_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rigid_bodies_phase_4_createClass(Constructor, protoProps, staticProps) { if (protoProps) rigid_bodies_phase_4_defineProperties(Constructor.prototype, protoProps); if (staticProps) rigid_bodies_phase_4_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Integration.\n */\n\n\n\nvar rigid_bodies_phase_4_RigidBodiesPhase4 = /*#__PURE__*/function () {\n  function RigidBodiesPhase4() {\n    rigid_bodies_phase_4_classCallCheck(this, RigidBodiesPhase4);\n  }\n\n  rigid_bodies_phase_4_createClass(RigidBodiesPhase4, null, [{\n    key: "solve",\n    value: function solve(dr, v, nu, a, dtr) {\n      var deltaT = dr * dtr;\n      var vec = [0, 0, 0];\n\n      for (var k = 0; k < 3; ++k) {\n        vec[k] = (v[k] + nu[k]) * deltaT + .5 * a[k] * deltaT * deltaT;\n      }\n\n      return vec;\n    }\n  }, {\n    key: "minimize",\n    value: function minimize(delta, p0, p1, a) {\n      if (p0[a] < p1[a] && p0[a] + delta[a] >= p1[a] || p0[a] > p1[a] && p0[a] + delta[a] <= p1[a]) delta[a] = p1[a] - p0[a];\n    }\n    /**\n     * @deprecated\n     */\n\n  }, {\n    key: "solveIslandStepLinear",\n    value: function solveIslandStepLinear(mapCollidingPossible, i, // island 1 index\n    j, // island 2 index\n    r, // time got by solver\n    axis, // \'x\', \'y\', \'z\' or \'none\'\n    subIslandI, subIslandJ, entities, objectIndexInIslandToSubIslandXIndex, objectIndexInIslandToSubIslandYIndex, objectIndexInIslandToSubIslandZIndex, oxAxis, island, world, relativeDt) {\n      mapCollidingPossible.shift();\n      if (!subIslandI || subIslandI.length === 0) subIslandI = [i];\n      if (!subIslandJ || subIslandJ.length === 0) subIslandJ = [j]; // Get axis.\n\n      var ax = axis === \'x\' ? 0 : axis === \'y\' ? 1 : axis === \'z\' ? 2 : -1;\n\n      if (ax < 0) {\n        console.error(\'[Phase IV] [BAD] invalid axis.\');\n        return;\n      } // Compute island properties.\n\n\n      var sub1Mass = 0;\n      var sub2Mass = 0;\n      var newMass;\n      var newVel = [0, 0, 0];\n      var newAcc = [0, 0, 0]; // Sum mass.\n\n      for (var idInSub1 = 0, sub1Length = subIslandI.length; idInSub1 < sub1Length; ++idInSub1) {\n        sub1Mass += entities[oxAxis[island[subIslandI[idInSub1]]].id].mass;\n      }\n\n      for (var idInSub2 = 0, sub2Length = subIslandJ.length; idInSub2 < sub2Length; ++idInSub2) {\n        sub2Mass += entities[oxAxis[island[subIslandJ[idInSub2]]].id].mass;\n      }\n\n      newMass = sub1Mass + sub2Mass; // Compute uniform speed.\n\n      {\n        var e1 = entities[oxAxis[island[subIslandI[0]]].id];\n        var vel1 = e1.v0;\n        var acc1 = e1.a0;\n        var e2 = entities[oxAxis[island[subIslandJ[0]]].id];\n        var vel2 = e2.v0;\n        var acc2 = e2.a0;\n\n        for (var t = 0; t < 3; ++t) {\n          newVel[t] = (sub1Mass * vel1[t] + sub2Mass * vel2[t]) / newMass;\n          newAcc[t] = (sub1Mass * acc1[t] + sub2Mass * acc2[t]) / newMass;\n        }\n      }\n      var abs = Math.abs; // Concat indexes form both islands into newSubIsland\n\n      var newSubIsland = Array.from(subIslandI).concat(subIslandJ); // 2. compute new p1 (projected)\n      // (force sum > integration)\n      // For time dilation => take the smallest delta t.\n      //\n      // (*) compute v_newIsland and a_newIsland (add).\n      // (*) then, v0(entity) = v_newIsland and a0(entity) = a_newIsland\n      // dtr(entity) = (t1-t) \\times min(ldt)\n      //\n      // (*) finally, p1(entity) = p0(entity) + solve(t1-r, v_newIsland, a_newIsland).\n      // for all elements of the new island\n\n      var correctionDelta = 0;\n      var entityIdsInIslandWhichNeedTerrainPostSolving = [];\n\n      for (var idInNewSub = 0, newSubLength = newSubIsland.length; idInNewSub < newSubLength; ++idInNewSub) {\n        var entityIdInIsland = newSubIsland[idInNewSub];\n        if (entityIdInIsland === i || entityIdInIsland === j) continue;\n        var entityId = oxAxis[island[entityIdInIsland]].id;\n        var currentEntity = entities[entityId];\n        var nu = currentEntity.nu;\n        var v0 = currentEntity.v0;\n        var a0 = currentEntity.a0;\n\n        for (var k = 0; k < 3; ++k) {\n          v0[k] = newVel[k];\n          a0[k] = newAcc[k];\n        }\n\n        var p0 = currentEntity.p0;\n        var p1 = currentEntity.p1; // let lastR = currentEntity.lastR;\n\n        var deltaR = r; // lastR > 0 ? relativeDt - lastR : relativeDt;\n\n        if (deltaR === 0) {\n          continue;\n        }\n\n        var dtr = currentEntity.dtr; // Should be extracted from time dilation field instead\n\n        var newP1 = RigidBodiesPhase4.solve(deltaR, v0, nu, a0, dtr);\n        var hasCollided = collision_terrain.collideLinearZ(currentEntity, world, p0, p1, true);\n\n        if (hasCollided) {\n          var currentDelta = p1[ax] - newP1[ax];\n          if (abs(currentDelta) > abs(correctionDelta)) correctionDelta = currentDelta; // For later recorrection\n          // for (let k = 0; k < 3; ++k) p1[k] = newP1Test[k];\n\n          entityIdsInIslandWhichNeedTerrainPostSolving.push(entityIdInIsland);\n          console.log("\\t[Phase IV] Entity ".concat(currentEntity.entityId, " needs resolving ") + \'within its island because of a fixed terrain collision.\');\n        }\n\n        currentEntity.lastR = r;\n      } // Collision correction.\n      // for (let idInNewSub = 0, newSubLength = newSubIsland.length; idInNewSub < newSubLength; ++idInNewSub)\n      // {\n      //     let entityIdInIsland = newSubIsland[idInNewSub];\n      //     if (entityIdInIsland === i || entityIdInIsland === j) continue;\n      //     let entityId = oxAxis[island[entityIdInIsland]].id;\n      //     let currentEntity = entities[entityId];\n      //     let p1 = currentEntity.p1;\n      //     p1[ax] += correctionDelta;\n      // }\n      // (*) remove every member of newIsland from mapCollidingPossible\n      // 2.1. remove the collision couple from the collidingPossible map\n      // 4. invalidate collisions betwixt the current entity and other entities (not in the same sub-island).\n      // Outdated\n      // 4.1. shift collisions for all other entities (r)\n      // integrate the quadratic solution delta\n\n\n      var mcpSize = mapCollidingPossible.length;\n\n      for (var _k = mcpSize - 1; _k >= 0; --_k) {\n        var current = mapCollidingPossible[_k];\n        var island1Index = current[0];\n        var island2Index = current[1];\n        var currentAxis = current[3];\n        var subIslandIndex1 = void 0;\n        var subIslandIndex2 = void 0;\n\n        switch (currentAxis) {\n          case \'x\':\n            subIslandIndex1 = objectIndexInIslandToSubIslandXIndex[island1Index];\n            subIslandIndex2 = objectIndexInIslandToSubIslandXIndex[island2Index];\n            break;\n\n          case \'y\':\n            subIslandIndex1 = objectIndexInIslandToSubIslandYIndex[island1Index];\n            subIslandIndex2 = objectIndexInIslandToSubIslandYIndex[island2Index];\n            break;\n\n          case \'z\':\n            subIslandIndex1 = objectIndexInIslandToSubIslandZIndex[island1Index];\n            subIslandIndex2 = objectIndexInIslandToSubIslandZIndex[island2Index];\n            break;\n\n          default:\n            console.error(\'\\t[RBP4] Invalid axis entry in map colliding possible.\');\n        }\n\n        var currentIsInvalid = false;\n\n        for (var _idInSub = 0, subLength = subIslandI.length; _idInSub < subLength; ++_idInSub) {\n          var entityIdInSubIslands = subIslandI[_idInSub];\n\n          if (subIslandIndex1 === entityIdInSubIslands || subIslandIndex2 === entityIdInSubIslands) // check if currentAxis === axis?\n            {\n              mapCollidingPossible.splice(_k, 1);\n              currentIsInvalid = true;\n              break;\n            }\n        }\n\n        if (!currentIsInvalid) for (var _idInSub2 = 0, _subLength = subIslandJ.length; _idInSub2 < _subLength; ++_idInSub2) {\n          var _entityIdInSubIslands = subIslandJ[_idInSub2];\n\n          if (subIslandIndex1 === _entityIdInSubIslands || subIslandIndex2 === _entityIdInSubIslands) // check if currentAxis === axis?\n            {\n              mapCollidingPossible.splice(_k, 1);\n              break;\n            }\n        }\n      } // 3. solve from p0 to p1 (terrain + x)\n      // (for all entities in newSubIsland) <- Approximation (explicit solving)\n      // 5. solve from p0 to p1\' (for all entities in the island but not in the sub-island)\n      //\n      // (*) apply leapfrog on:\n      // (NewIsland \\cross Complementaire(NewIsland)) \\union\n      // (TerrainK(NewIsland) \\cross Complementaire(TerrainK(NewIsland)) \\intersect NewIsland)\n\n\n      var mapCollidingPossibleNew = [];\n      var debug = false;\n\n      if (debug) {\n        console.log("\\t\\tProcessing post-collision: \\n                ".concat(entities[oxAxis[island[subIslandI[0]]].id].entityId, " \\n                [").concat(subIslandI, "] vs ").concat(entities[oxAxis[island[subIslandJ[0]]].id].entityId, " \\n                [").concat(subIslandJ, "] || [").concat(newSubIsland, "]"));\n      }\n\n      rigid_bodies_phase_3.solveLeapfrogPostCollision(island, newSubIsland, entityIdsInIslandWhichNeedTerrainPostSolving, oxAxis, entities, relativeDt, mapCollidingPossibleNew); // append the result with r unchanged in mapCollidingPossible\n\n      for (var _k2 = 0, l = mapCollidingPossibleNew.length; _k2 < l; ++_k2) {\n        mapCollidingPossible.push(mapCollidingPossibleNew[_k2]);\n      }\n\n      mapCollidingPossible.sort(function (a, b) {\n        return a[2] - b[2];\n      });\n    } // 6. loop back\n\n  }]);\n\n  return RigidBodiesPhase4;\n}();\n\n/* harmony default export */ var rigid_bodies_phase_4 = (rigid_bodies_phase_4_RigidBodiesPhase4);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_physics/solver/collision/x.js\n\n\nfunction x_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { x_typeof = function _typeof(obj) { return typeof obj; }; } else { x_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return x_typeof(obj); }\n\nfunction x_toConsumableArray(arr) { return x_arrayWithoutHoles(arr) || x_iterableToArray(arr) || x_unsupportedIterableToArray(arr) || x_nonIterableSpread(); }\n\nfunction x_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction x_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return x_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return x_arrayLikeToArray(o, minLen); }\n\nfunction x_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction x_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return x_arrayLikeToArray(arr); }\n\nfunction x_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction x_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction x_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction x_createClass(Constructor, protoProps, staticProps) { if (protoProps) x_defineProperties(Constructor.prototype, protoProps); if (staticProps) x_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar XCollider = /*#__PURE__*/function () {\n  function XCollider() {\n    x_classCallCheck(this, XCollider);\n  }\n\n  x_createClass(XCollider, null, [{\n    key: "xCollide",\n    value: function xCollide(oldPosition, newPosition, world, xModel) {\n      var chk = world.getChunkByCoordinates.apply(world, x_toConsumableArray(oldPosition));\n      if (!chk) return;\n      var xs = xModel.getPortalsFromChunk(world.worldId, chk.chunkId);\n      if (!xs || xs.size < 1) return;\n      var portals = xModel.portals; // XXX [PORTAL] collide with head instead of entity center.\n\n      var op = oldPosition;\n      var np = newPosition;\n      var arr = [];\n      xs.forEach(function (xId) {\n        return arr.push(xId);\n      });\n\n      for (var i = 0, l = arr.length; i < l; ++i) {\n        var xId = arr[i];\n        var portal = portals.get(xId); // [...this._block1, ...this._block2, this._position, this._orientation]\n\n        var state = portal.state;\n        var x0 = state[0];\n        var y0 = state[1];\n        var z0 = state[2];\n        var x1 = state[3];\n        var y1 = state[4];\n        var z1 = state[5];\n        var p = state[6]; // Ratio towards +\n\n        var o = state[7]; // Orientation if ambiguous.\n\n        var sum = 0 + (x1 === x0) + (y1 === y0) + (z1 === z0);\n        var opx = op[0];\n        var opy = op[1];\n        var opz = op[2];\n        var npx = np[0];\n        var npy = np[1];\n        var npz = np[2];\n\n        if (sum === 2) {\n          var _ret = function () {\n            var axis = x1 !== x0 ? \'x\' : y1 !== y0 ? \'y\' : z1 !== z0 ? \'z\' : \'?\'; // x1 = cos alpha  ;  x2 = cos (alpha + beta) = cos alpha cos beta - sin alpha sin beta\n            // y1 = sin alpha  ;  y2 = sin (alpha + beta) = sin alpha cos beta + cos alpha sin beta\n            // x2 = x1 cos beta - y1 sin beta\n            // y2 = y1 cos beta + x1 sin beta\n\n            var beta = -parseFloat(o);\n            if (axis === \'x\') beta += Math.PI / 2;\n            if (axis === \'y\') beta = -beta + Math.PI / 2;\n            var cosBeta = Math.cos(beta);\n            var sinBeta = Math.sin(beta);\n\n            var transform = function transform(inputX, inputY, inputZ) {\n              return [inputX * cosBeta - inputY * sinBeta, inputY * cosBeta + inputX * sinBeta, inputZ];\n            };\n\n            var fx0 = void 0;\n            var fx1 = void 0;\n            var fy0 = void 0;\n            var fy1 = void 0;\n            var fz0 = void 0;\n            var fz1 = void 0;\n            var cosAlphaO = void 0;\n            var sinAlphaO = void 0;\n            var cosAlphaN = void 0;\n            var sinAlphaN = void 0;\n            var oT = void 0;\n            var nT = void 0; // Perform rotation with the sine sum formula to simplify collision.\n\n            switch (axis) {\n              case \'x\':\n                // Warn! for \'x\', \'first\' is z.\n                cosAlphaO = opz - (z0 + 0.5);\n                sinAlphaO = opy - (y0 + 0.5);\n                cosAlphaN = npz - (z0 + 0.5);\n                sinAlphaN = npy - (y0 + 0.5);\n                oT = transform(cosAlphaO, sinAlphaO, opx);\n                nT = transform(cosAlphaN, sinAlphaN, npx);\n                oT[0] += z0 + 0.5;\n                nT[0] += z0 + 0.5;\n                oT[1] += y0 + 0.5;\n                nT[1] += y0 + 0.5;\n                fx0 = z0 + 0.5;\n                fx1 = fx0;\n                fy0 = Math.min(y0, y1);\n                fy1 = Math.max(y0, y1) + 1;\n                fz0 = Math.min(x0, x1) + 0.5;\n                fz1 = Math.max(x0, x1) + 1.5; // if (oT[0] > fx0 && nT[0] < fx1 || oT[0] < fx0 && nT[0] > fx1) {\n                //     console.log(\'[XXX] Normal breached\');\n                // }\n\n                break;\n\n              case \'y\':\n                cosAlphaO = opx - (x0 + 0.5);\n                sinAlphaO = opz - (z0 + 0.5);\n                cosAlphaN = npx - (x0 + 0.5);\n                sinAlphaN = npz - (z0 + 0.5);\n                oT = transform(cosAlphaO, sinAlphaO, opy);\n                nT = transform(cosAlphaN, sinAlphaN, npy);\n                oT[0] += x0 + 0.5;\n                nT[0] += x0 + 0.5;\n                oT[1] += z0 + 0.5;\n                nT[1] += z0 + 0.5;\n                fx0 = x0 + 0.5;\n                fx1 = fx0;\n                fy0 = Math.min(z0, z1);\n                fy1 = Math.max(z0, z1) + 1;\n                fz0 = Math.min(y0, y1) + 0.5;\n                fz1 = Math.max(y0, y1) + 1.5; // if (oT[0] > fx0 && nT[0] < fx1 || oT[0] < fx0 && nT[0] > fx1) {\n                //     console.log(\'[YYYY] Normal breached\');\n                // }\n\n                break;\n\n              case \'z\':\n                cosAlphaO = opx - (x0 + 0.5);\n                sinAlphaO = opy - (y0 + 0.5);\n                cosAlphaN = npx - (x0 + 0.5);\n                sinAlphaN = npy - (y0 + 0.5);\n                oT = transform(cosAlphaO, sinAlphaO, opz);\n                nT = transform(cosAlphaN, sinAlphaN, npz);\n                oT[0] += x0 + 0.5;\n                nT[0] += x0 + 0.5;\n                oT[1] += y0 + 0.5;\n                nT[1] += y0 + 0.5;\n                fx0 = x0 + 0.5;\n                fx1 = fx0;\n                fy0 = Math.min(y0, y1);\n                fy1 = Math.max(y0, y1) + 1;\n                fz0 = Math.min(z0, z1) + 0.5;\n                fz1 = Math.max(z0, z1) + 1.5; // if (oT[0] > fx0 && nT[0] < fx1 || oT[0] < fx0 && nT[0] > fx1) {\n                //     console.log(\'[DEBUG/XCollision] Normal breached\');\n                // }\n\n                break;\n\n              default:\n                console.log(\'[XCollide] Unmanaged portal orientation.\');\n                return {\n                  v: void 0\n                };\n            } // Perform collision\n\n\n            if ((oT[0] > fx0 && nT[0] < fx1 || oT[0] < fx0 && nT[0] > fx1) && oT[1] > fy0 && oT[1] < fy1 && nT[1] > fy0 && nT[1] < fy1 && oT[2] + .5 > fz0 && oT[2] + .5 < fz1 && nT[2] + .5 > fz0 && nT[2] + .5 < fz1) return {\n              v: xModel.getOtherSide(xId)\n            };\n          }();\n\n          if (x_typeof(_ret) === "object") return _ret.v;\n        } // Big portals\n        // [PORTAL] Think about very big portals.\n        else if (sum === 1) {\n            var axis = x1 === x0 ? \'x\' : y1 === y0 ? \'y\' : z1 === z0 ? \'z\' : \'?\';\n            var fx0 = void 0;\n            var fx1 = void 0;\n            var fy0 = void 0;\n            var fy1 = void 0;\n            var fz0 = void 0;\n            var fz1 = void 0;\n\n            switch (axis) {\n              case \'x\':\n                fx0 = x0 + p;\n                fx1 = fx0;\n                fy0 = Math.min(y0, y1);\n                fy1 = Math.max(y0, y1) + 1;\n                fz0 = Math.min(z0, z1);\n                fz1 = Math.max(z0, z1) + 1;\n\n                if ((opx > fx0 && npx < fx1 || opx < fx0 && npx > fx1) && opy > fy0 && opy < fy1 && npy > fy0 && npy < fy1 && opz + .5 > fz0 && opz + .5 < fz1 && npz + .5 > fz0 && npz + .5 < fz1) {\n                  // Do collide & change world\n                  // XXX [PORTAL] Manage collisions with things on the other side.\n                  return xModel.getOtherSide(xId);\n                }\n\n                break;\n\n              case \'y\':\n                fx0 = Math.min(x0, x1);\n                fx1 = Math.max(x0, x1);\n                fy0 = y0 + p;\n                fy1 = fy0;\n                fz0 = Math.min(z0, z1);\n                fz1 = Math.max(z0, z1);\n\n                if (opx > fx0 && opx < fx1 && npx > fx0 && npx < fx1 && (opy > fy0 && npy < fy1 || opy < fy0 && npy > fy1) && opz + .5 > fz0 && opz + .5 < fz1 && npz + .5 > fz0 && npz + .5 < fz1) {\n                  return xModel.getOtherSide(xId);\n                }\n\n                break;\n\n              case \'z\':\n                fx0 = Math.min(x0, x1);\n                fx1 = Math.max(x0, x1);\n                fy0 = Math.min(y0, y1);\n                fy1 = Math.max(y0, y1);\n                fz0 = z0 + p;\n                fz1 = fz0;\n\n                if (opx > fx0 && opx < fx1 && npx > fx0 && npx < fx1 && opy > fy0 && opy < fy1 && npy > fy0 && npy < fy1 && (opz + .5 < fz0 && npz + .5 > fz1 || opz + .5 > fz0 && npz + .5 < fz1)) {\n                  return xModel.getOtherSide(xId);\n                }\n\n                break;\n\n              default:\n                console.log(\'[XCollide] Unmanaged portal orientation.\');\n            }\n          } else {\n            console.log("[XCollide] Error: portal orientation could not be determined: ".concat(sum));\n          }\n      }\n\n      return false;\n    }\n  }]);\n\n  return XCollider;\n}();\n\n/* harmony default export */ var collision_x = (XCollider);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_physics/solver/rigid_bodies/rigid_bodies_phase_5.js\nfunction rigid_bodies_phase_5_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rigid_bodies_phase_5_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rigid_bodies_phase_5_createClass(Constructor, protoProps, staticProps) { if (protoProps) rigid_bodies_phase_5_defineProperties(Constructor.prototype, protoProps); if (staticProps) rigid_bodies_phase_5_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Integration.\n */\n\n\n\nvar rigid_bodies_phase_5_RigidBodiesPhase5 = /*#__PURE__*/function () {\n  function RigidBodiesPhase5() {\n    rigid_bodies_phase_5_classCallCheck(this, RigidBodiesPhase5);\n  }\n\n  rigid_bodies_phase_5_createClass(RigidBodiesPhase5, null, [{\n    key: "applyGravityRotation",\n    value: function applyGravityRotation(entity, gravity) {\n      var rot = entity.rotation;\n      if (rot === null) return; // Represents self rotation.\n\n      var relPitch = rot[0];\n      var relYaw = rot[1]; // Represents gravity.\n\n      var pi = Math.PI;\n      var x = gravity[0];\n      var y = gravity[1];\n      var z = gravity[2];\n      var v1;\n      var v2;\n\n      if (y > 0) {\n        v1 = Math.atan(-x / y);\n      } else if (y < 0) {\n        v1 = x < 0 ? pi - Math.atan(x / y) : x > 0 ? -pi + Math.atan(-x / y) :\n        /*x === 0 ?*/\n        pi;\n      } else\n        /*if (y === 0)*/\n        {\n          v1 = x < 0 ? pi / 2 : x > 0 ? -pi / 2 :\n          /*x === 0*/\n          0;\n        }\n\n      if (z < 0) {\n        v2 = -Math.atan(Math.sqrt(x * x + y * y) / z);\n      } else if (z > 0) {\n        v2 = pi - Math.atan(Math.sqrt(x * x + y * y) / z);\n      } else\n        /*if (z === 0)*/\n        {\n          v2 = pi / 2;\n        }\n\n      var absPitch = v1;\n      var absYaw = v2;\n      var oldAbsPitch = rot[2];\n      var deltaAbsPitch = absPitch - oldAbsPitch;\n\n      if (relPitch !== rot[0] || relYaw !== rot[1] || absPitch !== rot[2] || absYaw !== rot[3]) {\n        var deltaP = absYaw < Math.PI / 4 ? relPitch - deltaAbsPitch : absYaw > 3 * Math.PI / 4 ? relPitch + deltaAbsPitch : relPitch;\n        entity.rotate(deltaP, relYaw, absPitch, absYaw);\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: "applyIntegration",\n    value: function applyIntegration(entities, worldId, oxAxis, world, xm, objectOrderer, searcher, o, rigidBodiesSolver) {\n      entities.forEach(function (currentEntity) {\n        if (!currentEntity) return;\n        var oldWorldId = currentEntity.worldId;\n        if (oldWorldId !== worldId) return;\n        var oi = currentEntity.indexX;\n        var entityIndex = currentEntity.entityId;\n        var currentObject = oxAxis[oi];\n        if (!currentObject || currentObject.kind !== \'e\') return; // Reset stamped collision.\n\n        currentEntity.lastR = -1; // Temporarily discard insulated objects.\n        // if (oxToIslandIndex[oi] !== -1) return;\n        //let entityIndex = oxAxis[oi].id;\n\n        var p0 = currentEntity.p0;\n        var p1 = currentEntity.p1;\n        var v0 = currentEntity.v0;\n        var v1 = currentEntity.v1;\n        var a0 = currentEntity.a0;\n        var a1 = currentEntity.a1; // Cast through potential x.\n\n        var xCrossed = collision_x.xCollide(p0, p1, world, xm); // if (oldWorldId == -1) {\n        //    console.log(`Position: ${p0} -> ${p1}`);\n        // }\n        // For cross-w collision one can do the following:\n        //  1. if free (pyr, terrain) at gate, switch wld, else snap to gate\n        //  2. cast from gate to transform(p1)\n        //  3. think recursion\n        //currentEntity.metaX = xCrossed;\n        //let xCrossed = currentEntity.metaX;\n\n        var entityUpdated = false;\n\n        if (xCrossed) {\n          var newWorldId = xCrossed.worldId;\n          objectOrderer.switchEntityToWorld(currentEntity, newWorldId, p1); // To collide with terrain on the other side, do the following:\n          // REMEMBER to TRANSLATE [p0, p1] to [x.position, x.transform(p1, newWorldId)]\n          // let hasCollidedAfterwards =\n          //   TerrainCollider.linearCollide(currentEntity, wm.getWorld(newWorldId), p0, p1, dtr);\n\n          entityUpdated = true;\n        }\n\n        if (p0[0] !== p1[0] || p0[1] !== p1[1] || p0[2] !== p1[2]) {\n          currentEntity.p0 = p1;\n          currentEntity.p1 = p0;\n\n          if (!xCrossed) {\n            searcher.updateObjectAxis(entityIndex);\n            objectOrderer.moveObject(currentEntity);\n          } else {// Here one should call a function objectOrderer.switchEntityToWorld(...)\n          }\n\n          entityUpdated = true;\n        } // Rotate entity\n\n\n        if (!xCrossed) {\n          var gravity = rigidBodiesSolver.getGravity(world, worldId, p0[0], p0[1], p0[2]);\n\n          if (RigidBodiesPhase5.applyGravityRotation(currentEntity, gravity)) {\n            entityUpdated = true;\n            var gx = gravity[0];\n            var gy = gravity[1];\n            var gz = gravity[2];\n            var gx0 = gx !== 0;\n            var gy0 = gy !== 0;\n            var gz0 = gz !== 0;\n\n            if (gx0 ^ gy0 ^ gz0) {\n              if (gz0) {\n                currentEntity.widthX = 0.25;\n                currentEntity.widthY = 0.25;\n                currentEntity.widthZ = 0.9;\n              } else if (gx0) {\n                currentEntity.widthX = 0.9;\n                currentEntity.widthY = 0.25;\n                currentEntity.widthZ = 0.25;\n              } else if (gy0) {\n                currentEntity.widthX = 0.25;\n                currentEntity.widthY = 0.9;\n                currentEntity.widthZ = 0.25;\n              }\n            }\n          }\n        }\n\n        if (v0[0] !== v1[0] || v0[1] !== v1[1] || v0[2] !== v1[2]) {\n          currentEntity.v0 = v1;\n          currentEntity.v1 = v0; // Velocity updates not visible by clients.\n\n          entityUpdated = true;\n        }\n\n        for (var axis = 0; axis < 3; ++axis) {\n          if (currentEntity.v0[axis] !== 0 && p0[axis] === p1[axis]) currentEntity.v0[axis] = 0;\n        }\n\n        if (a0[0] !== a1[0] || a0[1] !== a1[1] || a0[2] !== a1[2]) {\n          currentEntity.a0 = a1;\n          currentEntity.a1 = a0; // Acceleration updates not visible by clients.\n\n          entityUpdated = true;\n        }\n\n        if (entityUpdated) {\n          o.entityUpdated(entityIndex);\n        } // Swap\n\n\n        p1 = currentEntity.p1;\n        p0 = currentEntity.p0;\n        v1 = currentEntity.v1;\n        a1 = currentEntity.a1;\n\n        for (var i = 0; i < 3; ++i) {\n          p1[i] = p0[i];\n          v1[i] = 0;\n          a1[i] = 0;\n        } // To reset adherence:\n        // currentEntity.adherence = [!1, !1, !1, !1, !1, !1];\n\n\n        currentEntity.metaX = 0;\n      });\n    }\n  }, {\n    key: "collidePair",\n    value: function collidePair(snapper, snappee) {\n      var eps = 2 * collision_terrain.eps; // let numClamp = TerrainCollider.numericClamp;\n\n      var abs = Math.abs;\n      var pn0 = snapper.p0;\n      var p0 = snappee.p0;\n      var p1 = snappee.p1;\n      var dwx = snappee.widthX + snapper.widthX + eps;\n      var endsInX = abs(p1[0] - pn0[0]) < dwx;\n      if (!endsInX) return;\n      var dwy = snappee.widthY + snapper.widthY + eps;\n      var endsInY = abs(p1[1] - pn0[1]) < dwy;\n      if (!endsInY) return;\n      var dwz = snappee.widthZ + snapper.widthZ + eps;\n      var endsInZ = abs(p1[2] - pn0[2]) < dwz;\n      if (!endsInZ) return;\n      var startsInX = abs(p0[0] - pn0[0]) < dwx;\n      var startsInY = abs(p0[1] - pn0[1]) < dwy;\n      var startsInZ = abs(p0[2] - pn0[2]) < dwz;\n\n      if (startsInX && startsInY && startsInZ) {\n        // console.warn(\'[P5] A collision could not be prevented.\');\n        return;\n      }\n\n      if (!startsInX && endsInX) {\n        p1[0] = p0[0] < pn0[0] ? pn0[0] - dwx - eps : pn0[0] + dwx + eps;\n        return;\n      }\n\n      if (!startsInY && endsInY) {\n        p1[1] = p0[1] < pn0[1] ? pn0[1] - dwy - eps : pn0[1] + dwy + eps;\n        return;\n      }\n\n      if (!startsInZ && endsInZ) {\n        p1[2] = p0[2] < pn0[2] ? pn0[2] - dwz - eps : pn0[2] + dwz + eps; // return;\n      }\n    }\n  }, {\n    key: "collideProjectile",\n    value: function collideProjectile(entity, projectile, gravity) {\n      if (projectile.collided) return;\n      var abs = Math.abs;\n      var ep = entity.p0;\n      var pp = projectile.p0;\n      var px = projectile.p1;\n      var pm = [(pp[0] + px[0]) * 0.5, (pp[1] + px[1]) * 0.5, (pp[2] + px[2]) * 0.5];\n      var pwx = abs(px[0] - pp[0]) * 0.5 + projectile.widthX;\n      var pwy = abs(px[1] - pp[1]) * 0.5 + projectile.widthY;\n      var pwz = abs(px[2] - pp[2]) * 0.5 + projectile.widthZ;\n      var dwx = entity.widthX + pwx;\n      var dx = ep[0] - pm[0];\n      var endsInX = abs(dx) < dwx;\n      if (!endsInX) return;\n      var dwy = projectile.widthY + pwy;\n      var dy = ep[1] - pm[1];\n      var endsInY = abs(dy) < dwy;\n      if (!endsInY) return;\n      var dwz = entity.widthZ + pwz;\n      var dz = ep[2] - pm[2];\n      var endsInZ = abs(dz) < dwz;\n      if (!endsInZ) return; // After these tests, the projectile is considered collided.\n      // Normalize and clamp\n\n      dx = px[0] - pp[0];\n      dy = px[1] - pp[1];\n      dz = px[2] - pp[2];\n      var norm = Math.sqrt(dx * dx + dy * dy + dz * dz);\n      var fx = dx / norm;\n      fx = Math.max(-1, Math.min(fx, 1));\n      var fy = dy / norm;\n      fy = Math.max(-1, Math.min(fy, 1));\n      var fz = dz / norm;\n      fz = Math.max(-1, Math.min(fz, 1));\n      if (isNaN(fx)) fx = 0;\n      if (isNaN(fy)) fy = 0;\n      if (isNaN(fz)) fz = 0;\n      var slh = entity.sinceLastHit(); // console.log(slh);\n\n      var strength = 0.5;\n      var nx = abs(gravity[0]) > 0 ? slh > 40 ? -35 * gravity[0] : 0 : strength * fx;\n      var ny = abs(gravity[1]) > 0 ? slh > 40 ? -35 * gravity[1] : 0 : strength * fy;\n      var nz = abs(gravity[2]) > 0 ? slh > 40 ? -35 * gravity[2] : 0 : strength * fz;\n      entity.setHitVector(nx, ny, nz);\n      entity.hit = true;\n      if (slh > 40) entity.wasHit();\n      projectile.collided = true;\n    }\n  }, {\n    key: "collideMelee",\n    value: function collideMelee(hitter, hittee, gravity) {\n      var o = hitter.p0;\n      var d = hittee.p0;\n      var abs = Math.abs;\n      var meleeRange = 2 * 0.9; // Detect hit\n\n      var dwx = hittee.widthX + meleeRange;\n      var dx = d[0] - o[0];\n      var inX = abs(dx) < dwx;\n      if (!inX) return;\n      var dwy = hittee.widthY + meleeRange;\n      var dy = d[1] - o[1];\n      var inY = abs(dy) < dwy;\n      if (!inY) return;\n      var dwz = hittee.widthZ + meleeRange;\n      var dz = d[2] - o[2];\n      var inZ = abs(dz) < dwz;\n      if (!inZ) return; // Perform hit.\n\n      var norm = Math.sqrt(dx * dx + dy * dy + dz * dz);\n      var x = dx / norm;\n      x = Math.max(-1, Math.min(x, 1));\n      var y = dy / norm;\n      y = Math.max(-1, Math.min(y, 1));\n      var z = dz / norm;\n      z = Math.max(-1, Math.min(z, 1));\n      if (isNaN(x)) x = 0;\n      if (isNaN(y)) y = 0;\n      if (isNaN(z)) z = 0;\n      var forwardVector = hitter.getForwardActionVector();\n      var fx = forwardVector[0];\n      var fy = forwardVector[1];\n      var fz = forwardVector[2];\n      var dotProduct = fx * x + fy * y + fz * z;\n\n      if (dotProduct > 0.7) {\n        // console.log(\'melee hit\');\n        var strength = 0.5;\n\n        if (!hittee.isParrying) {\n          var slh = hittee.sinceLastHit(); // console.log(slh);\n\n          var nx = abs(gravity[0]) > 0 ? slh > 40 ? -35 * gravity[0] : 0 : strength * fx;\n          var ny = abs(gravity[1]) > 0 ? slh > 40 ? -35 * gravity[1] : 0 : strength * fy;\n          var nz = abs(gravity[2]) > 0 ? slh > 40 ? -35 * gravity[2] : 0 : strength * fz;\n          hittee.setHitVector(nx, ny, nz); // console.log(hittee.hitVector);\n\n          hittee.hit = true;\n          if (slh > 40) hittee.wasHit();\n        } else {\n          var of = hittee.getForwardActionVector();\n          var dot2 = of[0] * fx + of[1] * fy + of[2] * fz;\n\n          if (dot2 < 0.7) {\n            var _slh = hittee.sinceLastHit();\n\n            hittee.setHitVector(abs(gravity[0]) > 0 ? _slh > 40 ? -35 * gravity[0] : 0 : strength * fx, abs(gravity[1]) > 0 ? _slh > 40 ? -35 * gravity[1] : 0 : strength * fy, abs(gravity[2]) > 0 ? _slh > 40 ? -35 * gravity[2] : 0 : strength * fz);\n            hittee.hit = true;\n            if (_slh > 40) hittee.wasHit();\n          }\n        }\n      }\n    }\n  }, {\n    key: "simpleCollideIntegrate",\n    value: function simpleCollideIntegrate(entities, worldId, oxAxis, world, xm, objectOrderer, searcher, o, rigidBodiesSolver) {\n      var eps = collision_terrain.eps;\n      entities.forEach(function (currentEntity) {\n        if (!currentEntity) return;\n        if (currentEntity._isProjectile) currentEntity.ageProjectile();else {\n          currentEntity.countSinceLastHit();\n          if (currentEntity._isAvatar) currentEntity.countSinceLoadStart();\n        }\n        var oldWorldId = currentEntity.worldId;\n        if (oldWorldId !== worldId) return;\n        var oi = currentEntity.indexX;\n        var entityIndex = currentEntity.entityId;\n        var currentObject = oxAxis[oi];\n        if (!currentObject || currentObject.kind !== \'e\') return; // Reset stamped collision.\n\n        currentEntity.lastR = -1; // Temporarily discard insulated objects.\n        // if (oxToIslandIndex[oi] !== -1) return;\n        //let entityIndex = oxAxis[oi].id;\n\n        var p0 = currentEntity.p0;\n        var p1 = currentEntity.p1;\n        var v0 = currentEntity.v0;\n        var v1 = currentEntity.v1;\n        var a0 = currentEntity.a0;\n        var a1 = currentEntity.a1; // Cast through potential x.\n\n        var xCrossed = collision_x.xCollide(p0, p1, world, xm); // if (oldWorldId == -1) {\n        //    console.log(`Position: ${p0} -> ${p1}`);\n        // }\n        // For cross-w collision one can do the following:\n        //  1. if free (pyr, terrain) at gate, switch wld, else snap to gate\n        //  2. cast from gate to transform(p1)\n        //  3. think recursion\n        //currentEntity.metaX = xCrossed;\n        //let xCrossed = currentEntity.metaX;\n\n        var entityUpdated = false;\n\n        if (xCrossed) {\n          var newWorldId = xCrossed.worldId;\n          objectOrderer.switchEntityToWorld(currentEntity, newWorldId, p1); // To collide with terrain on the other side, do the following:\n          // REMEMBER to TRANSLATE [p0, p1] to [x.position, x.transform(p1, newWorldId)]\n          // let hasCollidedAfterwards =\n          //   TerrainCollider.linearCollide(currentEntity, wm.getWorld(newWorldId), p0, p1, dtr);\n\n          entityUpdated = true;\n        }\n\n        var hasMeleed = currentEntity.hasJustMeleed;\n        var hasMoved = p0[0] !== p1[0] || p0[1] !== p1[1] || p0[2] !== p1[2];\n\n        if (hasMeleed || hasMoved) {\n          if (hasMeleed) {\n            entityUpdated = true;\n            currentEntity._isHitting = true;\n          }\n\n          var gravity = rigidBodiesSolver.getGravity(world, worldId, p0[0], p0[1], p0[2]);\n          var isProjectile = currentEntity._isProjectile;\n          var rangeCollision = currentEntity.widthX + 2 * eps;\n          var rangeMelee = 2 * 0.9; // Detect collision and collide.\n\n          var oii;\n\n          for (oii = oi + 1; oii < oxAxis.length; ++oii) // Right\n          {\n            var nid = oxAxis[oii].id;\n            var n = entities[nid];\n            var isOtherEntityProjectile = n._isProjectile;\n            if (isProjectile && currentEntity.collided) break;\n            if (isProjectile && isOtherEntityProjectile || isOtherEntityProjectile && n.collided) continue;\n            var dx = Math.abs(n.p0[0] - p1[0]);\n            var outCollisionRange = dx > n.widthX + rangeCollision;\n            if (!hasMeleed && outCollisionRange) break;\n\n            if (hasMoved && !outCollisionRange) {\n              if (!isProjectile && !isOtherEntityProjectile) RigidBodiesPhase5.collidePair(n, currentEntity);else {\n                RigidBodiesPhase5.collideProjectile(isProjectile ? n : currentEntity, isProjectile ? currentEntity : n, gravity);\n              }\n            }\n\n            if (hasMeleed) {\n              var outMeleeRange = dx > n.widthX + rangeMelee;\n              if (outMeleeRange && outCollisionRange) break;\n              RigidBodiesPhase5.collideMelee(currentEntity, n, gravity);\n            }\n          }\n\n          for (oii = oi - 1; oii >= 0; --oii) // Left\n          {\n            var _nid = oxAxis[oii].id;\n            var _n = entities[_nid];\n            var _isOtherEntityProjectile = _n._isProjectile;\n            if (isProjectile && currentEntity.collided) break;\n            if (isProjectile && _isOtherEntityProjectile || _isOtherEntityProjectile && _n.collided) continue;\n\n            var _dx = Math.abs(_n.p0[0] - p1[0]);\n\n            var _outCollisionRange = _dx > _n.widthX + rangeCollision;\n\n            if (!hasMeleed && _outCollisionRange) break;\n\n            if (hasMoved && !_outCollisionRange) {\n              if (!isProjectile && !_isOtherEntityProjectile) RigidBodiesPhase5.collidePair(_n, currentEntity);else {\n                RigidBodiesPhase5.collideProjectile(isProjectile ? _n : currentEntity, isProjectile ? currentEntity : _n, gravity);\n              }\n            }\n\n            if (hasMeleed) {\n              var _outMeleeRange = _dx > _n.widthX + rangeMelee;\n\n              if (_outMeleeRange && _outCollisionRange) break;\n              RigidBodiesPhase5.collideMelee(currentEntity, _n, gravity);\n            }\n          }\n\n          currentEntity.hasJustMeleed = false;\n        }\n\n        if (p0[0] !== p1[0] || p0[1] !== p1[1] || p0[2] !== p1[2]) {\n          currentEntity.p0 = p1;\n          currentEntity.p1 = p0;\n\n          if (!xCrossed) {\n            searcher.updateObjectAxis(entityIndex);\n            objectOrderer.moveObject(currentEntity);\n          } else {// Here one should call a function objectOrderer.switchEntityToWorld(...)\n          }\n\n          entityUpdated = true;\n          if (currentEntity._isProjectile) currentEntity.hasMoved();\n        } // Rotate entity\n\n\n        if (!xCrossed) {\n          var _gravity = rigidBodiesSolver.getGravity(world, worldId, p0[0], p0[1], p0[2]);\n\n          if (RigidBodiesPhase5.applyGravityRotation(currentEntity, _gravity)) {\n            entityUpdated = true;\n            var gx = _gravity[0];\n            var gy = _gravity[1];\n            var gz = _gravity[2];\n            var gx0 = gx !== 0;\n            var gy0 = gy !== 0;\n            var gz0 = gz !== 0;\n\n            if (gx0 ^ gy0 ^ gz0) {\n              if (gz0) {\n                currentEntity.widthX = 0.25;\n                currentEntity.widthY = 0.25;\n                currentEntity.widthZ = 0.9;\n              } else if (gx0) {\n                currentEntity.widthX = 0.9;\n                currentEntity.widthY = 0.25;\n                currentEntity.widthZ = 0.25;\n              } else if (gy0) {\n                currentEntity.widthX = 0.25;\n                currentEntity.widthY = 0.9;\n                currentEntity.widthZ = 0.25;\n              }\n            }\n          }\n        }\n\n        if (v0[0] !== v1[0] || v0[1] !== v1[1] || v0[2] !== v1[2]) {\n          currentEntity.v0 = v1;\n          currentEntity.v1 = v0; // Velocity updates not visible by clients.\n\n          entityUpdated = true;\n        }\n\n        for (var axis = 0; axis < 3; ++axis) {\n          if (currentEntity.v0[axis] !== 0 && p0[axis] === p1[axis]) currentEntity.v0[axis] = 0;\n        }\n\n        if (a0[0] !== a1[0] || a0[1] !== a1[1] || a0[2] !== a1[2]) {\n          currentEntity.a0 = a1;\n          currentEntity.a1 = a0; // Acceleration updates not visible by clients.\n\n          entityUpdated = true;\n        }\n\n        if (entityUpdated) {\n          o.entityUpdated(entityIndex);\n        } // Swap\n\n\n        p1 = currentEntity.p1;\n        p0 = currentEntity.p0;\n        v1 = currentEntity.v1;\n        a1 = currentEntity.a1;\n\n        for (var i = 0; i < 3; ++i) {\n          p1[i] = p0[i];\n          v1[i] = 0;\n          a1[i] = 0;\n        } // To reset adherence:\n        // currentEntity.adherence = [!1, !1, !1, !1, !1, !1];\n\n\n        currentEntity.metaX = 0;\n\n        if (currentEntity._isProjectile) {\n          if (currentEntity.collided || currentEntity.howLongSinceLastMoved() > 180) {\n            rigidBodiesSolver._physicsEngine._ai.pushProjectileForDespawn(currentEntity.entityId);\n          }\n        }\n      });\n    }\n  }]);\n\n  return RigidBodiesPhase5;\n}();\n\n/* harmony default export */ var rigid_bodies_phase_5 = (rigid_bodies_phase_5_RigidBodiesPhase5);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_physics/solver/rigid_bodies/rigid_bodies.js\n/**\n *\n */\n\n\nfunction rigid_bodies_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction rigid_bodies_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction rigid_bodies_createClass(Constructor, protoProps, staticProps) { if (protoProps) rigid_bodies_defineProperties(Constructor.prototype, protoProps); if (staticProps) rigid_bodies_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction rigid_bodies_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\nvar rigid_bodies_RigidBodies = /*#__PURE__*/function () {\n  // THIS ACTIVATES CROSS-COLLISION, EXPERIMENTAL\n  // THIS REMOVES GRAVITY INTEGRATION (but not rotation changes)\n  function RigidBodies(refreshRate, physicsEngine) {\n    rigid_bodies_classCallCheck(this, RigidBodies);\n\n    this._physicsEngine = physicsEngine; // "constants"\n\n    this._gravity = [0, 0, RigidBodies.gravityConstant];\n    this._gravityWater = [0, 0, 0.1 * RigidBodies.gravityConstant];\n    this._globalTimeDilation = 25; // this._globalTimeDilation = 0.05;\n\n    this._refreshRate = refreshRate;\n    this._variableGravity = true;\n    this._worldCenter = [0, 0, -100];\n  }\n\n  rigid_bodies_createClass(RigidBodies, [{\n    key: "getGravity",\n    // Advanced gravity management.\n    value: function getGravity(world, worldId, x, y, z) {\n      if (!this._variableGravity || world.worldInfo.type !== model_WorldType.CUBE) {\n        return this._gravity; // world.isWater(x, y, z) ? this._gravityWater : this._gravity;\n      }\n\n      var center = world.worldInfo.center;\n      var radius = parseFloat(world.worldInfo.radius);\n      var abs = Math.abs;\n      var max = Math.max;\n      var min = Math.min;\n      var sX = world.xSize;\n      var sY = world.ySize;\n      var sZ = world.zSize;\n      var cX = sX * center.x + sX / 2;\n      var cY = sY * center.y + sY / 2;\n      var cZ = sZ * center.z + sZ / 2;\n      var dX = abs(x - cX);\n      var dY = abs(y - cY);\n      var dZ = abs(z - cZ);\n      var xPlus = x > cX;\n      var yPlus = y > cY;\n      var zPlus = z > cZ; // Clamp on main faces to keep camera rotation updates to a minimum.\n\n      var squaredWithSmoothBorders = true;\n      var squaredRadius = 2; // Should this equal 1.6, the entity height?\n\n      var gravityNorm = (world.isWater(x, y, z) ? 0.1 : 1) * RigidBodies.gravityConstant;\n\n      if (squaredWithSmoothBorders) {\n        if (dX > max(dY, dZ) + squaredRadius) return [(xPlus ? 1 : -1) * gravityNorm, 0, 0];else if (dY > max(dX, dZ) + squaredRadius) return [0, (yPlus ? 1 : -1) * gravityNorm, 0];else if (dZ > max(dX, dY) + squaredRadius) return [0, 0, (zPlus ? 1 : -1) * gravityNorm];\n      } // take at -2 (under feet and not only on raw border)\n\n\n      var rad = max(max(radius * sX, radius * sY), radius * sZ) - 1;\n      if (abs(cX - x) < radius * sX && abs(cY - y) < radius * sY && abs(cZ - z) < radius * sZ) rad = min(min(abs(cX - x), abs(cY - y)), abs(cZ - z)) - 1;\n      var rsxm = cX - rad;\n      var rsxp = cX + rad;\n      cX = x < rsxm ? rsxm : x > rsxp ? rsxp : x;\n      var rsym = cY - rad;\n      var rsyp = cY + rad;\n      cY = y < rsym ? rsym : y > rsyp ? rsyp : y;\n      var rszm = cZ - rad;\n      var rszp = cZ + rad;\n      cZ = z < rszm ? rszm : z > rszp ? rszp : z;\n      var power = 4.0;\n      var ddx = parseFloat(cX) - parseFloat(x);\n      var ddy = parseFloat(cY) - parseFloat(y);\n      var ddz = parseFloat(cZ) - parseFloat(z);\n      var dd = Math.pow(Math.pow(ddx, power) + Math.pow(ddy, power) + Math.pow(ddz, power), 1 / power);\n      var direction = [ddx !== 0 ? Math.pow(Math.abs(ddx), power + 1) / (ddx * dd) : 0, ddy !== 0 ? Math.pow(Math.abs(ddy), power + 1) / (ddy * dd) : 0, ddz !== 0 ? Math.pow(Math.abs(ddz), power + 1) / (ddz * dd) : 0];\n      var norm = Math.sqrt(Math.pow(direction[0], 2) + Math.pow(direction[1], 2) + Math.pow(direction[2], 2));\n      direction[0] *= -gravityNorm / norm;\n      direction[1] *= -gravityNorm / norm;\n      direction[2] *= -gravityNorm / norm;\n      return direction;\n    } // Advanced time flow customization.\n\n  }, {\n    key: "getTimeDilation",\n    value: function getTimeDilation(worldId, x, y, z) {\n      if (worldId === 666) {\n        return 1 + Math.abs(x * y * z);\n      }\n\n      return 1;\n    }\n  }, {\n    key: "solve",\n    value: function solve(objectOrderer, eventOrderer, em, wm, xm, o, relativeDtMs) {\n      var _this = this;\n\n      var passId = Math.random();\n      var timeDilation = this.globalTimeDilation;\n      var absoluteDt = this.refreshRate / timeDilation;\n      var relativeDt = relativeDtMs / timeDilation; // if (relativeDt !== 0.64) console.log(relativeDt);\n      // let relativeDt = absoluteDt;\n      // let maxSpeed = Entity.maxSpeed;\n      // let maxSpeed2 = maxSpeed * maxSpeed;\n\n      if (relativeDt > 3 * absoluteDt) {\n        console.log(\'Warn: lagging at \' + "".concat(Math.floor(100 * relativeDt / absoluteDt), "%."));\n        relativeDt = 3 * absoluteDt;\n      } // Decouple entities from worlds.\n      // A given entity can span across multiple worlds.\n\n\n      var entities = em.entities;\n      var events = eventOrderer.events; // For each world,\n\n      var eventUniverseAxes = eventOrderer.axes;\n      var objectUniverseAxes = objectOrderer.axes;\n      objectUniverseAxes.forEach(function (objectWorldAxes, worldId) {\n        var world = wm.getWorld(worldId);\n        var eventWorldAxes = eventUniverseAxes.get(world);\n        var oxAxis = objectWorldAxes[0];\n        var oyAxis = objectWorldAxes[1];\n        var ozAxis = objectWorldAxes[2];\n        var searcher = new Searcher(entities, oxAxis, oyAxis, ozAxis);\n        if (oxAxis.length !== oyAxis.length || oxAxis.length !== ozAxis.length) throw Error(\'Inconsistent lengths among axes.\'); // 1. Sum inputs/impulses, fields.\n        // 2. Compute (x_i+1, a_i+1, v_i+1), order Leapfrog\'s incremental term.\n        //    Computation takes into account local time dilation.\n        // Summing constraints is done by summing globals (i.e. global gravity)\n        // with local functional events (i.e. position-dependant gravity)\n        // with local custom events (applied from the events array).\n        // LOCAL EVENTS.\n\n        if (eventWorldAxes) rigid_bodies_phase_1.processLocalEvents(eventOrderer, entities, events, worldId, eventWorldAxes, oxAxis); // GLOBAL EVENTS, INPUTS & COMPUTATIONS.\n\n        var leapfrogArray = new Array(oxAxis.length);\n        rigid_bodies_phase_1.processGlobalEvents(entities, world, worldId, relativeDt, oxAxis, leapfrogArray, passId, _this);\n\n        if (RigidBodies.crossEntityCollision) {\n          RigidBodies.solveIntegrateAABB(oxAxis, entities, world, worldId, searcher, xm, objectOrderer, o, _this);\n        } else {\n          rigid_bodies_phase_2.simpleCollideEntitiesWithTerrain(oxAxis, entities, world, _this);\n          rigid_bodies_phase_5.applyIntegration(entities, worldId, oxAxis, world, xm, objectOrderer, searcher, o, _this);\n        }\n      });\n    }\n  }, {\n    key: "gravity",\n    get: function get() {\n      return this._gravity;\n    },\n    set: function set(g) {\n      this._gravity = g;\n    }\n  }, {\n    key: "globalTimeDilation",\n    get: function get() {\n      return this._globalTimeDilation;\n    }\n  }, {\n    key: "refreshRate",\n    get: function get() {\n      return this._refreshRate;\n    }\n  }], [{\n    key: "solveIntegrateAABB",\n    value: function solveIntegrateAABB(oxAxis, entities, world, worldId, searcher, xm, objectOrderer, o, rigidBodiesSolver) {\n      rigid_bodies_phase_2.simpleCollideEntitiesWithTerrain(oxAxis, entities, world, rigidBodiesSolver);\n      rigid_bodies_phase_5.simpleCollideIntegrate(entities, worldId, oxAxis, world, xm, objectOrderer, searcher, o, rigidBodiesSolver);\n    }\n    /**\n     * @deprecated\n     */\n\n  }, {\n    key: "solveCrossEntityHardCollision",\n    value: function solveCrossEntityHardCollision(world, entities, leapfrogArray, searcher, oxAxis, relativeDt, rigidBodiesSolver) {\n      var abs = Math.abs; // Sort entities according to incremental term.\n      // Remember leapfrogs within objects, reordering them within islands\n      // is probably better than sorting a potentially huge array.\n\n      var inf = function inf(x) {\n        return Math.max(abs(x[0]), abs(x[1]), abs(x[2]));\n      };\n\n      leapfrogArray.sort(function (a, b) {\n        return inf(b) - inf(a);\n      }); // Note: a - b natural order, b - a reverse order\n      // abs(b[0]) + abs(b[1]) + abs(b[2]) - abs(a[0]) - abs(a[1]) - abs(a[2])\n      // Rebuild mapping after having sorted leapfrogs.\n\n      var reverseLeapfrogArray = new Int32Array(leapfrogArray.length);\n\n      for (var i = 0, l = leapfrogArray.length; i < l; ++i) {\n        reverseLeapfrogArray[leapfrogArray[i][3]] = i;\n      } // 4. Compute islands, cross world, by axis order.\n\n\n      var numberOfEntities = leapfrogArray.length;\n      var oxToIslandIndex = new Int32Array(numberOfEntities);\n      var islands = [];\n      rigid_bodies_phase_2.computeIslands(leapfrogArray, searcher, oxToIslandIndex, islands); // 3. Snap x_i+1 with terrain collide, save non-integrated residuals\n      // as bounce components with coefficient & threshold (heat).\n\n      rigid_bodies_phase_2.collideLonelyIslandsWithTerrain(oxAxis, entities, oxToIslandIndex, islands, world, rigidBodiesSolver); // add leapfrog term\n      // get array of all xs sorted by axis\n      // 5. Broad phase: in every island, recurse from highest to lowest leapfrog\'s term\n      //    check neighbours for min distance in linearized trajectory\n      //    detect and push PROBABLY COLLIDING PAIRS.\n      // 6. Narrow phase, part 1: for all probably colliding pairs,\n      //    solve X leapfrog, save first all valid Ts\n      //    keep list of ordered Ts across pairs.\n      // if (islands.length > 0) {\n      //     console.log(islands);\n      // }\n\n      for (var currentIslandIndex = 0, il = islands.length; currentIslandIndex < il; ++currentIslandIndex) {\n        var island = islands[currentIslandIndex]; // island.sort((a,b) => reverseLeapfrogArray[b] - reverseLeapfrogArray[a]);\n\n        var mapCollidingPossible = []; // 1. Sort colliding possible.\n        // Solve leapfrog and sort according to time.\n\n        rigid_bodies_phase_3.solveLeapfrogQuadratic(island, oxAxis, entities, relativeDt, mapCollidingPossible);\n        if (mapCollidingPossible.length < 1) continue; // Narrow phase, part 2: for all Ts in order,\n        //    set bodies as \'in contact\' or \'terminal\' (terrain),\n        //    compute new paths (which )are not more than common two previous) while compensating forces\n        //    so as to project the result into directions that are not occluded\n        //      -> bouncing will be done in next iteration to ensure convergence\n        //      -> possible to keep track of the energy as unsatisfied work of forces\n        //    solve X leapfrog for impacted trajectories and insert new Ts in the list (map?)\n        //    End when there is no more collision to be solved.\n\n        mapCollidingPossible.sort(function (a, b) {\n          return a[2] - b[2];\n        }); // 2. First colliding ->\n        //      join\n        //      move to collision point\n        //      compute new trajectory (leapfrog)\n        //      collide again with terrain\n        //      compute colliding possible with all others\n        //      (invalidate collision with others) -> optional (discarded afterwards anyway)\n\n        var subIslandsX = []; // For sub-sampled physics, must be sorted and\n\n        var subIslandsY = []; // kept coherent before every pass in the I/J collider.\n\n        var subIslandsZ = [];\n        var objectIndexInIslandToSubIslandXIndex = new Int16Array(island.length);\n        var objectIndexInIslandToSubIslandYIndex = new Int16Array(island.length);\n        var objectIndexInIslandToSubIslandZIndex = new Int16Array(island.length);\n        objectIndexInIslandToSubIslandXIndex.fill(-1);\n        objectIndexInIslandToSubIslandYIndex.fill(-1);\n        objectIndexInIslandToSubIslandZIndex.fill(-1); // For each entity in current island\n\n        var complicatedFlag = mapCollidingPossible.length > 1;\n        var solverPassId = 1;\n        var debugFlag = false;\n\n        if (debugFlag) {\n          if (complicatedFlag) console.log("Complicated collision solving: ".concat(island));else console.log("Collision solving: island ".concat(island, ", map ").concat(mapCollidingPossible));\n          console.log(\'New island pass\');\n          console.log(island);\n        }\n\n        var dbg = false;\n\n        if (dbg) {\n          var eids = [];\n\n          for (var isl = 0; isl < island.length; ++isl) {\n            eids.push(oxAxis[island[isl]].id);\n          }\n\n          console.log(eids);\n        }\n\n        var reloop = false;\n\n        while (mapCollidingPossible.length > 0) {\n          if (dbg) {\n            console.log("\\t".concat(mapCollidingPossible[0], " ") + "| ".concat(reloop ? \'stacked\' : \'shifted\', " | ").concat(mapCollidingPossible.length));\n          }\n\n          reloop = false;\n          var ii = mapCollidingPossible[0][0]; // island 1 index\n\n          var jj = mapCollidingPossible[0][1]; // island 2 index\n\n          var rr = mapCollidingPossible[0][2]; // time got by solver\n\n          var axis = mapCollidingPossible[0][3]; // \'x\', \'y\', \'z\' or \'none\'\n\n          if (debugFlag && complicatedFlag) {\n            var msg = "\\tPass ".concat(solverPassId++, " : ").concat(mapCollidingPossible.length, " elements to process ");\n\n            for (var m = 0; m < mapCollidingPossible.length; ++m) {\n              msg += "(".concat(mapCollidingPossible[m][0], ", ").concat(mapCollidingPossible[m][1], "); ");\n            }\n\n            var xIndex1 = island[ii];\n            var xIndex2 = island[jj];\n            var id1 = oxAxis[xIndex1].id;\n            var id2 = oxAxis[xIndex2].id;\n            var e1 = entities[id1];\n            var e2 = entities[id2];\n            msg += "\\n\\tEntity ".concat(e1.entityId, " : ").concat(e1.p0[2].toFixed(5), " -> ").concat(e1.p1[2].toFixed(5));\n            msg += "\\n\\tEntity ".concat(e2.entityId, " : ").concat(e2.p0[2].toFixed(5), " -> ").concat(e2.p1[2].toFixed(5));\n            msg += "\\n\\tColliding on ".concat(axis, " axis, at t = ").concat(rr.toFixed(10));\n            console.log(msg);\n          } // \\DEBUG\n\n\n          var subIslandI = rigid_bodies_phase_3.getSubIsland(ii, axis, objectIndexInIslandToSubIslandXIndex, objectIndexInIslandToSubIslandYIndex, objectIndexInIslandToSubIslandZIndex, subIslandsX, subIslandsY, subIslandsZ);\n          var subIslandJ = rigid_bodies_phase_3.getSubIsland(jj, axis, objectIndexInIslandToSubIslandXIndex, objectIndexInIslandToSubIslandYIndex, objectIndexInIslandToSubIslandZIndex, subIslandsX, subIslandsY, subIslandsZ);\n          if (debugFlag && complicatedFlag) console.log(\'\\tApplying collision...\');\n          var eps = 1e-6;\n          rigid_bodies_phase_3.applyCollision(ii, jj, rr, axis, island, oxAxis, entities, relativeDt, eps); // 1. apply step to newSubIsland\n          // 2.1. invalidate for each (newSubIslandMember)\n          // 2.2. resolve for each (newSubIslandMember x anyother)\n          // 3. update mapCollidingPossible\n\n          if (debugFlag && complicatedFlag) console.log(\'\\tSolving the island step...\');\n          var oldLength = mapCollidingPossible.length;\n          rigid_bodies_phase_4.solveIslandStepLinear(mapCollidingPossible, ii, jj, rr, axis, subIslandI, subIslandJ, entities, objectIndexInIslandToSubIslandXIndex, objectIndexInIslandToSubIslandYIndex, objectIndexInIslandToSubIslandZIndex, oxAxis, island, world, relativeDt);\n          if (mapCollidingPossible.length >= oldLength) reloop = true;\n\n          if (debugFlag && complicatedFlag) {\n            var _xIndex = island[ii];\n            var _xIndex2 = island[jj];\n            var _id = oxAxis[_xIndex].id;\n            var _id2 = oxAxis[_xIndex2].id;\n            var _e = entities[_id];\n            var _e2 = entities[_id2];\n\n            var _msg = "\\t\\t/Entity ".concat(_e.entityId, " : ").concat(_e.p0[2].toFixed(5), " -> ").concat(_e.p1[2].toFixed(5));\n\n            _msg += "\\n\\t\\t/Entity ".concat(_e2.entityId, " : ").concat(_e2.p0[2].toFixed(5), " -> ").concat(_e2.p1[2].toFixed(5));\n            console.log(_msg);\n          }\n\n          if (debugFlag && complicatedFlag) console.log(\'\\tMerging sub-islands...\');\n          rigid_bodies_phase_3.mergeSubIslands(ii, jj, subIslandI, subIslandJ, objectIndexInIslandToSubIslandXIndex, objectIndexInIslandToSubIslandYIndex, objectIndexInIslandToSubIslandZIndex, subIslandsX, subIslandsY, subIslandsZ, axis);\n          if (debugFlag && complicatedFlag) console.log(\'\\tMerged!\');\n        } // Solved!\n\n      }\n    }\n  }, {\n    key: "add",\n    value: function add(result, toAdd) {\n      result[0] += toAdd[0];\n      result[1] += toAdd[1];\n      result[2] += toAdd[2];\n    }\n  }]);\n\n  return RigidBodies;\n}();\n\nrigid_bodies_defineProperty(rigid_bodies_RigidBodies, "eps", .00000001);\n\nrigid_bodies_defineProperty(rigid_bodies_RigidBodies, "gravityConstant", 2 * -0.00980665);\n\nrigid_bodies_defineProperty(rigid_bodies_RigidBodies, "crossEntityCollision", true);\n\nrigid_bodies_defineProperty(rigid_bodies_RigidBodies, "creativeMode", false);\n\n/* harmony default export */ var rigid_bodies = (rigid_bodies_RigidBodies);\n// CONCATENATED MODULE: ./server/app/engine/game3d/model_x/portal.js\n/**\n *\n */\n\n\nfunction portal_toConsumableArray(arr) { return portal_arrayWithoutHoles(arr) || portal_iterableToArray(arr) || portal_unsupportedIterableToArray(arr) || portal_nonIterableSpread(); }\n\nfunction portal_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction portal_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return portal_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return portal_arrayLikeToArray(o, minLen); }\n\nfunction portal_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction portal_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return portal_arrayLikeToArray(arr); }\n\nfunction portal_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction portal_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction portal_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction portal_createClass(Constructor, protoProps, staticProps) { if (protoProps) portal_defineProperties(Constructor.prototype, protoProps); if (staticProps) portal_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar portal_Portal = /*#__PURE__*/function () {\n  /**\n   * @param worldId origin world.\n   * @param id identifier in XModel\n   * @param c1 first 3-array position in specified world\n   * @param c2 second 3-array block position in specified world\n   * @param offset (ratio of advancement in the + coordinate direction)\n   * @param orientation (looking at \'first\' or \'next\')\n   * @param chunk origin chunk (portals are fixed ATM)\n   */\n  function Portal(worldId, id, c1, c2, offset, orientation, chunk) {\n    portal_classCallCheck(this, Portal);\n\n    this._portalId = id;\n    this._worldId = worldId;\n    this._block1 = c1;\n    this._block2 = c2;\n    this._offset = offset; // Ratio.\n\n    this._orientation = orientation;\n    this._chunk = chunk; // Physics properties and optimization.\n\n    this._indexX = -1;\n    this._indexY = -1;\n    this._indexZ = -1;\n  }\n\n  portal_createClass(Portal, [{\n    key: "portalId",\n    get: function get() {\n      return this._portalId;\n    }\n  }, {\n    key: "worldId",\n    get: function get() {\n      return this._worldId;\n    }\n  }, {\n    key: "chunkId",\n    get: function get() {\n      return this._chunk.chunkId;\n    }\n  }, {\n    key: "chunk",\n    get: function get() {\n      return this._chunk;\n    }\n  }, {\n    key: "state",\n    get: function get() {\n      return [].concat(portal_toConsumableArray(this._block1), portal_toConsumableArray(this._block2), [this._offset, this._orientation]);\n    } // Physics.\n\n  }, {\n    key: "indexX",\n    set: function set(indexX) {\n      this._indexX = indexX;\n    },\n    get: function get() {\n      return this._indexX;\n    }\n  }, {\n    key: "indexY",\n    set: function set(indexY) {\n      this._indexY = indexY;\n    },\n    get: function get() {\n      return this._indexY;\n    }\n  }, {\n    key: "indexZ",\n    set: function set(indexZ) {\n      this._indexZ = indexZ;\n    },\n    get: function get() {\n      return this._indexZ;\n    } // Position! Not ratio!\n\n  }, {\n    key: "position",\n    get: function get() {\n      var b1 = this._block1;\n      var b2 = this._block2;\n      if (!b1 || !b2) return;\n      var p = [0, 0, 0];\n\n      for (var i = 0; i < 3; ++i) {\n        p[i] = (b1[i] + b2[i]) * .5;\n      }\n\n      return p;\n    }\n  }]);\n\n  return Portal;\n}();\n\n/* harmony default export */ var model_x_portal = (portal_Portal);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_physics/solver/rigid_bodies/orderer_objects.js\n/**\n *\n */\n\n\nfunction orderer_objects_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction orderer_objects_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction orderer_objects_createClass(Constructor, protoProps, staticProps) { if (protoProps) orderer_objects_defineProperties(Constructor.prototype, protoProps); if (staticProps) orderer_objects_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar orderer_objects_ObjectOrderer = /*#__PURE__*/function () {\n  function ObjectOrderer(entityModel, xModel) {\n    orderer_objects_classCallCheck(this, ObjectOrderer);\n\n    // Model.\n    this._entityModel = entityModel;\n    this._xModel = xModel; // Internals.\n\n    this._axes = new Map(); // world id -> [ [{k,v,i}]x, []y, []z ]\n    // this._islands = []; // 1 island: [entity/x id, ...]\n    // this._isEntity = []; // 1 island: [is entity or x]\n  }\n\n  orderer_objects_createClass(ObjectOrderer, [{\n    key: "orderObjects",\n    // Compute sorted axes from scratch entity arrays.\n    // Xs are taken into account to achieve efficient physics.\n    //  N.B. Chunk caches and specific x storage has nothing\n    //  to do with physics specifically.\n    //  Warning: inefficient, but done at startup.\n    value: function orderObjects() {\n      var portals = this._xModel.portals;\n      var entities = this._entityModel.entities;\n      var axes = this._axes;\n      var orderCache = ObjectOrderer.orderCache; // Fill axes with entities.\n\n      for (var i = 0, l = entities.length; i < l; ++i) {\n        if (!entities) continue;\n        var e = entities[i];\n        var wid = e.worldId;\n        var p = e.p0;\n        var axis = axes.get(wid); // Most inefficient call.\n\n        if (!axis) axes.set(wid, [[{\n          kind: \'e\',\n          id: i,\n          val: p[0]\n        }], [{\n          kind: \'e\',\n          id: i,\n          val: p[1]\n        }], [{\n          kind: \'e\',\n          id: i,\n          val: p[2]\n        }]]);else {\n          axis[0].push({\n            kind: \'e\',\n            id: i,\n            val: p[0]\n          });\n          axis[1].push({\n            kind: \'e\',\n            id: i,\n            val: p[1]\n          });\n          axis[2].push({\n            kind: \'e\',\n            id: i,\n            val: p[2]\n          });\n        }\n      } // XXX [PORTAL] [PERF] Fill axes with portals.\n\n\n      portals.forEach(function (portal, i) {\n        var wid = portal.worldId;\n        var p = portal.position;\n        var axis = axes.get(wid); // Most inefficient call.\n\n        if (!axis) axes.set(wid, [[{\n          kind: \'x\',\n          id: i,\n          val: p[0]\n        }], [{\n          kind: \'x\',\n          id: i,\n          val: p[1]\n        }], [{\n          kind: \'x\',\n          id: i,\n          val: p[2]\n        }]]);else {\n          axis[0].push({\n            kind: \'x\',\n            id: i,\n            val: p[0]\n          });\n          axis[1].push({\n            kind: \'x\',\n            id: i,\n            val: p[1]\n          });\n          axis[2].push({\n            kind: \'x\',\n            id: i,\n            val: p[2]\n          });\n        }\n      }); // Order axes.\n\n      axes.forEach(function (xyzEntities\n      /*, wid)*/\n      ) {\n        var xAxis = xyzEntities[0];\n        var yAxis = xyzEntities[1];\n        var zAxis = xyzEntities[2];\n\n        if (!xAxis || !yAxis || !zAxis || xAxis.length !== yAxis.length || xAxis.length !== zAxis.length) {\n          throw Error(\'[Physics/Orderer]: axis inconsistency.\');\n        } // Perform ordering.\n\n\n        xAxis.sort(function (a, b) {\n          return a.val > b.val;\n        });\n        yAxis.sort(function (a, b) {\n          return a.val > b.val;\n        });\n        zAxis.sort(function (a, b) {\n          return a.val > b.val;\n        }); // Write position in objects.\n        // Using reflection.\n\n        orderCache(xAxis, entities, portals, 0, \'indexX\');\n        orderCache(yAxis, entities, portals, 0, \'indexY\');\n        orderCache(zAxis, entities, portals, 0, \'indexZ\');\n      });\n    } // [Thought] could be optimised by axis prealloc, dichotomy insertion,\n    // keeping track of active elements, and realloc when necessary (gc).\n\n  }, {\n    key: "addObject",\n    value: function addObject(object) {\n      var kind = object instanceof model_entity_entity ? \'e\' : object instanceof model_x_portal ? \'x\' : null;\n      if (!kind) throw Error(\'[Physics/Orderer]: invalid object kind.\'); // Get properties.\n\n      var p = object.p0;\n\n      if (typeof p[0] !== \'number\') {\n        console.error(\'Invalid entity position.\');\n        return;\n      }\n\n      var x = p[0];\n      var y = p[1];\n      var z = p[2];\n      var eid = kind === \'e\' ? object.entityId : object.portalId;\n      var wid = object.worldId;\n      var portals = this._xModel.portals;\n      var entities = this._entityModel.entities;\n\n      var axis = this._axes.get(wid);\n\n      if (!axis) {\n        this._axes.set(wid, [[{\n          kind: kind,\n          id: eid,\n          val: x\n        }], [{\n          kind: kind,\n          id: eid,\n          val: y\n        }], [{\n          kind: kind,\n          id: eid,\n          val: z\n        }]]);\n\n        object.indexX = 0;\n        object.indexY = 0;\n        object.indexZ = 0;\n      } else {\n        var dichotomyLowerBound = ObjectOrderer.dichotomyLowerBound;\n        var orderCache = ObjectOrderer.orderCache;\n        var xAxis = axis[0];\n        var yAxis = axis[1];\n        var zAxis = axis[2]; // Dichotomy search, insert after.\n\n        var indexX = dichotomyLowerBound(xAxis, x, \'val\');\n        var indexY = dichotomyLowerBound(yAxis, y, \'val\');\n        var indexZ = dichotomyLowerBound(zAxis, z, \'val\');\n        if (!xAxis[indexX] && indexX !== xAxis.length) // Not found\n          throw Error("[Physics/Orderer]: element not found. ".concat(indexX));\n\n        while (xAxis[indexX] && xAxis[indexX].val <= x) {\n          ++indexX;\n        }\n\n        xAxis.splice(indexX, 0, {\n          kind: kind,\n          id: eid,\n          val: x\n        });\n\n        while (yAxis[indexY] && yAxis[indexY].val <= y) {\n          ++indexY;\n        }\n\n        yAxis.splice(indexY, 0, {\n          kind: kind,\n          id: eid,\n          val: y\n        });\n\n        while (zAxis[indexZ] && zAxis[indexZ].val <= z) {\n          ++indexZ;\n        }\n\n        zAxis.splice(indexZ, 0, {\n          kind: kind,\n          id: eid,\n          val: z\n        }); // Reorder last entities.\n\n        orderCache(xAxis, entities, portals, indexX, \'indexX\');\n        orderCache(yAxis, entities, portals, indexY, \'indexY\');\n        orderCache(zAxis, entities, portals, indexZ, \'indexZ\');\n      }\n    }\n  }, {\n    key: "moveObject",\n    value: function moveObject(object) {\n      var kind = object instanceof model_entity_entity ? \'e\' : object instanceof model_x_portal ? \'x\' : null;\n      if (!kind) throw Error(\'[Physics/Orderer]: invalid object kind.\'); // Get properties.\n\n      var p0 = object.p0; //let eid = kind === \'e\' ? object.entityId : object.portalId;\n\n      var wid = object.worldId; //let portals = this._xModel.portals;\n      //let entities = this._entityModel.entities;\n\n      var axis = this._axes.get(wid);\n\n      var x = p0[0];\n      var y = p0[1];\n      var z = p0[2];\n      var indexX = object.indexX;\n      var indexY = object.indexY;\n      var indexZ = object.indexZ;\n      var axisX = axis[0];\n      var axisY = axis[1];\n      var axisZ = axis[2];\n      axisX[indexX].val = x;\n      axisY[indexY].val = y;\n      axisZ[indexZ].val = z;\n    } // [Thought] could be optimised by garbage collection.\n    // Keeping a list of active objects for each axis.\n\n  }, {\n    key: "removeObject",\n    value: function removeObject(object) {\n      var kind = object instanceof model_entity_entity ? \'e\' : object instanceof model_x_portal ? \'x\' : null;\n\n      if (!kind) {\n        throw Error(\'[Physics/Orderer]: invalid object kind.\');\n      }\n\n      var portals = this._xModel.portals;\n      var entities = this._entityModel.entities;\n      var wid = object.worldId;\n\n      var axis = this._axes.get(wid);\n\n      var indexX = object.indexX;\n      var indexY = object.indexY;\n      var indexZ = object.indexZ;\n      var xAxis = axis[0];\n      var yAxis = axis[1];\n      var zAxis = axis[2];\n      xAxis.splice(indexX, 1);\n      yAxis.splice(indexY, 1);\n      zAxis.splice(indexZ, 1); // 1 shift -> O(n)\n\n      if (xAxis.length > 0) {\n        var orderCache = ObjectOrderer.orderCache;\n        orderCache(xAxis, entities, portals, indexX, \'indexX\');\n        orderCache(yAxis, entities, portals, indexY, \'indexY\');\n        orderCache(zAxis, entities, portals, indexZ, \'indexZ\');\n      } else {\n        this._axes["delete"](wid);\n      }\n    }\n  }, {\n    key: "switchEntityToWorld",\n    value: function switchEntityToWorld(entity, newWorldId, coordinates) {\n      var portals = this._xModel.portals;\n      var entities = this._entityModel.entities;\n      var oldWorldId = entity.worldId;\n      var eid = entity.entityId; //entity.position = coordinates;\n\n      var x = coordinates[0];\n      var y = coordinates[1];\n      var z = coordinates[2];\n      var xid = entity.indexX;\n      var yid = entity.indexY;\n      var zid = entity.indexZ; // Old axes?\n\n      var oldAxis = this._axes.get(oldWorldId);\n\n      if (oldAxis) {\n        // Remove from old set of axes.\n        oldAxis[0].splice(xid, 1);\n        oldAxis[1].splice(yid, 1);\n        oldAxis[2].splice(zid, 1);\n        if (oldAxis[0].length < 1) this._axes["delete"](oldWorldId);else {\n          var orderCache = ObjectOrderer.orderCache;\n          orderCache(oldAxis[0], entities, portals, xid, \'indexX\');\n          orderCache(oldAxis[1], entities, portals, yid, \'indexY\');\n          orderCache(oldAxis[2], entities, portals, zid, \'indexZ\');\n        }\n      } else console.log(\'ERROR\'); // Insert into new set of axes.\n\n\n      var newAxis = this._axes.get(newWorldId);\n\n      if (!newAxis) {\n        this._axes.set(newWorldId, [[{\n          kind: \'e\',\n          id: eid,\n          val: x\n        }], [{\n          kind: \'e\',\n          id: eid,\n          val: y\n        }], [{\n          kind: \'e\',\n          id: eid,\n          val: z\n        }]]);\n\n        entity.indexX = 0;\n        entity.indexY = 0;\n        entity.indexZ = 0;\n      } else {\n        var xAxis = newAxis[0];\n        var xLow;\n        var yAxis = newAxis[1];\n        var yLow;\n        var zAxis = newAxis[2];\n        var zLow;\n        var dichotomyLowerBound = ObjectOrderer.dichotomyLowerBound;\n        xLow = dichotomyLowerBound(xAxis, x, \'val\');\n        yLow = dichotomyLowerBound(yAxis, y, \'val\');\n        zLow = dichotomyLowerBound(zAxis, z, \'val\');\n        if (xLow >= 0) xAxis.splice(xLow\n        /* + 1*/\n        , 0, {\n          kind: \'e\',\n          id: eid,\n          val: x\n        });\n        if (yLow >= 0) yAxis.splice(yLow\n        /* + 1*/\n        , 0, {\n          kind: \'e\',\n          id: eid,\n          val: y\n        });\n        if (zLow >= 0) zAxis.splice(zLow\n        /* + 1*/\n        , 0, {\n          kind: \'e\',\n          id: eid,\n          val: z\n        }); // 1 shift -> O(n)\n\n        var _orderCache = ObjectOrderer.orderCache;\n\n        _orderCache(xAxis, entities, portals, xLow, \'indexX\');\n\n        _orderCache(yAxis, entities, portals, yLow, \'indexY\');\n\n        _orderCache(zAxis, entities, portals, zLow, \'indexZ\');\n      } // Set new world.\n\n\n      entity.worldId = newWorldId;\n    }\n  }, {\n    key: "axes",\n    get: function get() {\n      return this._axes;\n    }\n  }], [{\n    key: "dichotomyLowerBound",\n    value: function dichotomyLowerBound(a, value, prop) {\n      var lo = 0;\n      var hi = a.length - 1;\n      var mid;\n\n      while (lo <= hi) {\n        mid = lo + hi >> 1; // floor((lo+hi)/2)\n        // priority \'+\' > priority \'>>\'\n\n        if (a[mid][prop] > value) hi = mid - 1;else if (a[mid][prop] < value) lo = mid + 1;else return mid;\n      }\n\n      return lo;\n    } // Impact entities cached indices.\n    // Each entity knows its position in axis arrays.\n\n  }, {\n    key: "orderCache",\n    value: function orderCache(array, entities, portals, start, prop) {\n      for (var i = start, l = array.length; i < l; ++i) {\n        var id = parseInt(array[i].id, 10);\n        if (array[i].kind === \'e\') entities[id][prop] = i; // Array.\n        else if (array[i].kind === \'x\') portals.get(id)[prop] = i; // Map.\n      }\n    }\n  }]);\n\n  return ObjectOrderer;\n}();\n\n/* harmony default export */ var orderer_objects = (orderer_objects_ObjectOrderer);\n// EXTERNAL MODULE: ./server/app/engine/math/time.js\nvar math_time = __webpack_require__(4);\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_physics/solver/frontend.js\n/**\n *\n */\n\n\nfunction frontend_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction frontend_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction frontend_createClass(Constructor, protoProps, staticProps) { if (protoProps) frontend_defineProperties(Constructor.prototype, protoProps); if (staticProps) frontend_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar frontend_FrontEnd = /*#__PURE__*/function () {\n  function FrontEnd(physicsEngine, refreshRate) {\n    frontend_classCallCheck(this, FrontEnd);\n\n    // Model access.\n    this._physicsEngine = physicsEngine;\n    var entityModel = physicsEngine.entityModel;\n    var xModel = physicsEngine.xModel; // Internals.\n\n    this._rigidBodies = new rigid_bodies(refreshRate, physicsEngine);\n    this._objectOrderer = new orderer_objects(entityModel, xModel);\n    this._eventOrderer = new orderer_events();\n    this._stamp = math_time["a" /* default */].getTimeSecNano(); // Note! this must be done before the first physics pass,\n    // when entities are just loaded from the disk during a (to be implemented) resume.\n\n    this._objectOrderer.orderObjects();\n\n    this._variableDt = false;\n  }\n\n  frontend_createClass(FrontEnd, [{\n    key: "solve",\n    value: function solve() {\n      var physicsEngine = this._physicsEngine;\n      var rigidBodies = this._rigidBodies;\n      var objectOrderer = this._objectOrderer;\n      var eventOrderer = this._eventOrderer;\n      var em = physicsEngine.entityModel;\n      var wm = physicsEngine.worldModel;\n      var xm = physicsEngine.xModel;\n      var ob = physicsEngine.outputBuffer; // Compute adaptive time step.\n      // Activate lag correction here.\n      // let relativeDt = 16;\n\n      var relativeDt = math_time["a" /* default */].getTimeSecNano(this._stamp)[1] / 1e6; // Solve physics constraints with basic ordering optimization.\n\n      var maxTimeStepDuration = rigidBodies.refreshRate;\n      var numberOfEntirePasses = relativeDt > maxTimeStepDuration ? Math.floor(relativeDt / maxTimeStepDuration) : 1;\n\n      for (var t = 0; t < numberOfEntirePasses; ++t) {\n        rigidBodies.solve(objectOrderer, eventOrderer, em, wm, xm, ob, maxTimeStepDuration);\n      }\n\n      var remainder = relativeDt - numberOfEntirePasses * maxTimeStepDuration;\n\n      if (remainder > relativeDt * .5 && this._variableDt) {\n        rigidBodies.solve(objectOrderer, eventOrderer, em, wm, xm, ob, remainder);\n        ++numberOfEntirePasses;\n      } // console.log(`######### Current physics passes: ${numberOfEntirePasses} ############`);\n      // Stamp.\n\n\n      this._stamp = math_time["a" /* default */].getTimeSecNano();\n    } // Can be triggered to change physics behaviour.\n\n  }, {\n    key: "shuffleGravity",\n    value: function shuffleGravity() {\n      var rigidBodies = this._rigidBodies;\n      var g = rigidBodies.gravity;\n      rigidBodies.gravity = [g[2], g[0], g[1]];\n    }\n  }, {\n    key: "objectOrderer",\n    get: function get() {\n      return this._objectOrderer;\n    }\n  }, {\n    key: "eventOrderer",\n    get: function get() {\n      return this._eventOrderer;\n    }\n  }]);\n\n  return FrontEnd;\n}();\n\n/* harmony default export */ var frontend = (frontend_FrontEnd);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_physics/updater/updater.js\n/**\n *\n */\n\n\nfunction updater_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction updater_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction updater_createClass(Constructor, protoProps, staticProps) { if (protoProps) updater_defineProperties(Constructor.prototype, protoProps); if (staticProps) updater_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar updater_Updater = /*#__PURE__*/function () {\n  function Updater(physicsEngine) {\n    updater_classCallCheck(this, Updater);\n\n    //\n    this._physicsEngine = physicsEngine;\n  }\n\n  updater_createClass(Updater, [{\n    key: "update",\n    value: function update(inputBuffer) {\n      var _this = this;\n\n      // Process incoming actions.\n      inputBuffer.forEach(function (array, avatar) // value, key\n      {\n        // XXX [PERF] compute means or filter some events.\n        array.forEach(function (e) {\n          if (e.action === \'move\' && typeof e.meta === \'string\') Updater.move(e.meta, avatar);else if (e.action === \'rotate\' && e.meta instanceof Array) _this.rotate(e.meta, avatar);else if (e.action === \'action\' && typeof e.meta === \'string\') _this.action(e.meta, avatar);else if (e.action === \'use\' && e.meta instanceof Array) _this.use(e.meta, avatar);\n        });\n      });\n    } // Constrained => forward border effect to physics solver.\n\n  }, {\n    key: "rotate",\n    // Unconstrained => direct update, then notify output.\n    value: function rotate(meta, avatar) {\n      var rotation = avatar.rotation;\n      if (rotation === null) return;\n      var outputBuffer = this._physicsEngine.outputBuffer;\n      var relPitch = meta[0]; // Represents self rotation.\n\n      var relYaw = meta[1];\n      var absPitch = meta[2]; // Represents gravity.\n\n      var absYaw = meta[3];\n\n      if (relPitch !== rotation[0] || relYaw !== rotation[1] || absPitch !== rotation[2] || absYaw !== rotation[3]) {\n        avatar.rotate(relPitch, relYaw, absPitch, absYaw);\n        outputBuffer.entityUpdated(avatar.entityId);\n      }\n    } // Unconstrained actions API.\n\n  }, {\n    key: "action",\n    value: function action(meta\n    /*, avatar*/\n    ) {\n      if (meta === \'g\') {\n        this._physicsEngine.shuffleGravity();\n      }\n    }\n  }, {\n    key: "use",\n    value: function use(meta, avatar) {\n      // XXX [GAMEPLAY] validate item in inventory\n      // XXX [GAMEPLAY] give inventory state to players\n      // console.warn(\'[Physics/Updater] Player wants to use item. To implement.\');\n      // console.log(meta);\n      if (meta.length !== 10) {\n        console.warn("[Physics/Updater] A player wants to use an item, \\n                but the server does not understand which one or how.");\n        return;\n      } // console.log(avatar.entityId);\n\n\n      var px = parseFloat(meta[0]);\n      var py = parseFloat(meta[1]);\n      var pz = parseFloat(meta[2]);\n      var fx = parseFloat(meta[3]);\n      var fy = parseFloat(meta[4]);\n      var fz = parseFloat(meta[5]);\n      var isButtonDown = !meta[6];\n      var isPrimaryButton = !meta[7];\n      var itemType = meta[8]; // \'melee\' or \'ranged\'\n      // const itemID = meta[9];\n\n      switch (itemType) {\n        case \'melee\':\n          if (!isButtonDown) {\n            avatar.unParry();\n            avatar.unLoadRanged();\n            break;\n          }\n\n          if (isPrimaryButton && !avatar.hasJustMeleed && !avatar.hasJustFired) // Prevent spam\n            {\n              avatar.unParry();\n              avatar.unLoadRanged();\n              avatar.melee(px, py, pz, fx, fy, fz);\n            }\n\n          if (!isPrimaryButton) {\n            avatar.unLoadRanged();\n            avatar.parry(px, py, pz, fx, fy, fz);\n          }\n\n          break;\n\n        case \'ranged\':\n          if (!isPrimaryButton) break;\n\n          if (isButtonDown) {\n            avatar.unParry();\n            avatar.loadRanged();\n          } else if (avatar.loadingRanged) {\n            avatar.unParry();\n            var power = avatar.unLoadRanged(); // avatar.fire(\n            //     px, py, pz,\n            //     fx, fy, fz\n            // );\n\n            var upv = rigid_bodies_phase_1.getEntityUpVector(avatar);\n\n            if (power > 20) {\n              this._physicsEngine._ai.pushProjectileForSpawn([px, py, pz, fx, fy, fz, avatar.worldId, power, upv[0], upv[1], upv[2] // avatar.widthY, avatar.widthY, avatar.widthZ\n              ]);\n            }\n          }\n\n          break;\n\n        default:\n          console.warn(\'[Physics/Updater] Invalid item type.\');\n          break;\n      }\n    }\n  }], [{\n    key: "move",\n    value: function move(meta, avatar) {\n      // let hasMoved = true;\n      switch (meta) {\n        case \'f\':\n          avatar.goForward();\n          break;\n\n        case \'r\':\n          avatar.goRight();\n          break;\n\n        case \'l\':\n          avatar.goLeft();\n          break;\n\n        case \'b\':\n          avatar.goBackwards();\n          break;\n\n        case \'u\':\n          avatar.goUp();\n          break;\n\n        case \'d\':\n          avatar.goDown();\n          break;\n\n        case \'fx\':\n          avatar.stopForward();\n          break;\n\n        case \'rx\':\n          avatar.stopRight();\n          break;\n\n        case \'lx\':\n          avatar.stopLeft();\n          break;\n\n        case \'bx\':\n          avatar.stopBackwards();\n          break;\n\n        case \'ux\':\n          avatar.stopUp();\n          break;\n\n        case \'dx\':\n          avatar.stopDown();\n          break;\n\n        case \'xx\':\n          avatar.stop();\n          break;\n\n        case \'run\':\n          avatar.startRunning();\n          break;\n\n        case \'runx\':\n          avatar.stopRunning();\n          break;\n\n        default: // hasMoved = false;\n\n      }\n    }\n  }]);\n\n  return Updater;\n}();\n\n/* harmony default export */ var updater = (updater_Updater);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_physics/physics.js\n/**\n *\n */\n\n\nfunction physics_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction physics_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction physics_createClass(Constructor, protoProps, staticProps) { if (protoProps) physics_defineProperties(Constructor.prototype, protoProps); if (staticProps) physics_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar physics_PhysicsEngine = /*#__PURE__*/function () {\n  function PhysicsEngine(game) {\n    physics_classCallCheck(this, PhysicsEngine);\n\n    // Models.\n    this._entityModel = game.entityModel;\n    this._worldModel = game.worldModel;\n    this._xModel = game.xModel;\n    this._ai = game.ai; // Buffers.\n\n    this._inputBuffer = new input_buffer();\n    this._outputBuffer = new output_buffer(); // Engine.\n\n    this._updater = new updater(this); // Parses input and updates model constraints.\n\n    this._frontend = new frontend(this, game.refreshRate); // Updates physical model.\n  }\n\n  physics_createClass(PhysicsEngine, [{\n    key: "addInput",\n\n    /** ######################## **/\n    value: function addInput(meta, avatar) {\n      this._inputBuffer.addInput(meta, avatar);\n    }\n  }, {\n    key: "update",\n    value: function update() {\n      var input = this._inputBuffer.getInput();\n\n      this._updater.update(input);\n\n      this._frontend.solve();\n\n      this._inputBuffer.flush();\n    }\n  }, {\n    key: "getOutput",\n    value: function getOutput() {\n      return this._outputBuffer.getOutput();\n    }\n    /** ######################## **/\n\n  }, {\n    key: "flushOutput",\n    value: function flushOutput() {\n      this._outputBuffer.flushOutput();\n    }\n  }, {\n    key: "shuffleGravity",\n    value: function shuffleGravity() {\n      this._frontend.shuffleGravity();\n    }\n    /** **/\n\n  }, {\n    key: "spawnPlayer",\n    value: function spawnPlayer(player) {\n      this._frontend.objectOrderer.addObject(player.avatar);\n    }\n  }, {\n    key: "removePlayer",\n    value: function removePlayer(playerId) {\n      var entity = this._entityModel.entities[playerId];\n\n      this._frontend.objectOrderer.removeObject(entity);\n    }\n  }, {\n    key: "spawnEntity",\n    value: function spawnEntity(entity) {\n      this._frontend.objectOrderer.addObject(entity);\n    }\n  }, {\n    key: "removeEntity",\n    value: function removeEntity(entityId) {\n      var entity = this._entityModel.entities[entityId];\n\n      this._frontend.objectOrderer.removeObject(entity);\n    }\n  }, {\n    key: "entityModel",\n    get: function get() {\n      return this._entityModel;\n    }\n  }, {\n    key: "worldModel",\n    get: function get() {\n      return this._worldModel;\n    }\n  }, {\n    key: "xModel",\n    get: function get() {\n      return this._xModel;\n    }\n  }, {\n    key: "outputBuffer",\n    get: function get() {\n      return this._outputBuffer;\n    }\n  }]);\n\n  return PhysicsEngine;\n}();\n\n/* harmony default export */ var physics = (physics_PhysicsEngine);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_topology/input_buffer.js\n/**\n * Manage input transactions.\n * Specialized for world model.\n */\n\n\nfunction engine_topology_input_buffer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction engine_topology_input_buffer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction engine_topology_input_buffer_createClass(Constructor, protoProps, staticProps) { if (protoProps) engine_topology_input_buffer_defineProperties(Constructor.prototype, protoProps); if (staticProps) engine_topology_input_buffer_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar input_buffer_InputBuffer = /*#__PURE__*/function () {\n  function InputBuffer() {\n    engine_topology_input_buffer_classCallCheck(this, InputBuffer);\n\n    this._buffer = [];\n  }\n\n  engine_topology_input_buffer_createClass(InputBuffer, [{\n    key: "addInput",\n    value: function addInput(avatar, meta) {\n      this._buffer.push([avatar, meta]);\n    }\n  }, {\n    key: "getInput",\n    value: function getInput() {\n      return this._buffer;\n    }\n  }, {\n    key: "flush",\n    value: function flush() {\n      this._buffer = [];\n    }\n  }]);\n\n  return InputBuffer;\n}();\n\n/* harmony default export */ var engine_topology_input_buffer = (input_buffer_InputBuffer);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_topology/output_buffer.js\n/**\n * Aggregate updates.\n * Specialized for world model.\n */\n\n\nfunction engine_topology_output_buffer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction engine_topology_output_buffer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction engine_topology_output_buffer_createClass(Constructor, protoProps, staticProps) { if (protoProps) engine_topology_output_buffer_defineProperties(Constructor.prototype, protoProps); if (staticProps) engine_topology_output_buffer_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar output_buffer_OutputBuffer = /*#__PURE__*/function () {\n  function OutputBuffer() {\n    engine_topology_output_buffer_classCallCheck(this, OutputBuffer);\n\n    // Contains ids of updated chunks.\n    // Chunks themselves hold information about their being updated.\n    // XXX [PERF] concentrate chunk updates in this buffer.\n    // world id => Set(... chunk ids)\n    this._buffer = new Map();\n  }\n\n  engine_topology_output_buffer_createClass(OutputBuffer, [{\n    key: "chunkUpdated",\n    value: function chunkUpdated(worldId, chunkId) {\n      var worldSet = this._buffer.get(worldId);\n\n      if (worldSet) {\n        worldSet.add(chunkId);\n      } else {\n        var chunkIdSet = new Set();\n        chunkIdSet.add(chunkId);\n\n        this._buffer.set(worldId, chunkIdSet);\n      }\n    } // Shallow copy.\n\n  }, {\n    key: "getOutput",\n    value: function getOutput() {\n      return new Map(this._buffer);\n    }\n  }, {\n    key: "flushOutput",\n    value: function flushOutput(worldModel) {\n      var buffer = this._buffer;\n      buffer.forEach(function (chunkSet, worldId) {\n        var chunks = worldModel.getWorld(worldId).allChunks;\n        chunkSet.forEach(function (id) {\n          return chunks.get(id).flushUpdates();\n        });\n      });\n      this._buffer = new Map();\n    }\n  }]);\n\n  return OutputBuffer;\n}();\n\n/* harmony default export */ var engine_topology_output_buffer = (output_buffer_OutputBuffer);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_topology/selector/selector.js\n/**\n * Ensure player model consistency.\n */\n\n\nfunction selector_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction selector_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction selector_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction selector_createClass(Constructor, protoProps, staticProps) { if (protoProps) selector_defineProperties(Constructor.prototype, protoProps); if (staticProps) selector_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Selector = /*#__PURE__*/function () {\n  function Selector() {\n    selector_classCallCheck(this, Selector);\n  }\n\n  selector_createClass(Selector, [{\n    key: "selectUpdatedChunksForPlayer",\n    value: function selectUpdatedChunksForPlayer(player, worldModel, consistencyModel, modelUpdatedChunks, // topology output      Map(world id -> set of updtd chks)\n    addedOrDeletedChunks // consistency output   {world id => {cid => [fc, fcids]} }\n    ) {\n      if (!this.playerConcernedByUpdatedChunks(player, modelUpdatedChunks)) return;\n      var chunksForPlayer = {};\n      var aid = player.avatar.entityId;\n      modelUpdatedChunks.forEach(function (chunkIdSet, worldId) {\n        var world = worldModel.getWorld(worldId);\n        var addedOrDeletedChunksInWorld;\n        if (addedOrDeletedChunks) addedOrDeletedChunksInWorld = addedOrDeletedChunks[worldId];\n        chunkIdSet.forEach(function (chunkId) {\n          if (!world.hasChunkById(chunkId)) return;\n\n          if (!consistencyModel.hasChunk(aid, worldId, chunkId) || // not null, has {chunkId: !null}\n          addedOrDeletedChunksInWorld && addedOrDeletedChunksInWorld.hasOwnProperty(chunkId) && addedOrDeletedChunksInWorld[chunkId]) {\n            // At this point, topology output is being accessed.\n            // So, topology engine has updated and its topology model is up-to-date.\n            // Therefore, there is no need to access updates concerning non-loaded chunks,\n            // for full, up-to-date, extracted surfaces are available to consistencyEngine.\n            // (reminder: updates are kept for lazy server-client communication)\n            // (reminder: consistencyEngine does not update before topologyEngine performs model transactions)\n            return;\n          }\n\n          var currentChunk = world.getChunkById(chunkId);\n\n          if (chunksForPlayer.hasOwnProperty(worldId)) {\n            chunksForPlayer[worldId][currentChunk.chunkId] = currentChunk.updates;\n          } else {\n            chunksForPlayer[worldId] = selector_defineProperty({}, currentChunk.chunkId, currentChunk.updates);\n          }\n        });\n      });\n      return chunksForPlayer;\n    }\n  }, {\n    key: "playerConcernedByUpdatedChunks",\n    value: function playerConcernedByUpdatedChunks(player, chunks) {\n      return chunks.size > 0;\n    }\n  }]);\n\n  return Selector;\n}();\n\n/* harmony default export */ var selector = (Selector);\n// CONCATENATED MODULE: ./server/app/engine/math/geometry.js\n/**\n *\n */\n\n\nfunction geometry_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction geometry_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction geometry_createClass(Constructor, protoProps, staticProps) { if (protoProps) geometry_defineProperties(Constructor.prototype, protoProps); if (staticProps) geometry_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar GeometryUtils = /*#__PURE__*/function () {\n  function GeometryUtils() {\n    geometry_classCallCheck(this, GeometryUtils);\n  }\n\n  geometry_createClass(GeometryUtils, null, [{\n    key: "infiniteNormDistance",\n\n    /** Common topology distances **/\n    value: function infiniteNormDistance(pos1, pos2) {\n      var d = 0;\n\n      for (var i = 0; i < 3; ++i) {\n        d = Math.max(d, Math.abs(parseInt(pos1[i], 10) - parseInt(pos2[i], 10)));\n      }\n\n      return d;\n    }\n  }, {\n    key: "chunkSquaredEuclideanDistance",\n    value: function chunkSquaredEuclideanDistance(pos1, pos2) {\n      var result = 0;\n      var d;\n\n      for (var i = 0; i < 3; ++i) {\n        d = pos1[i] - pos2[i];\n        result += d * d;\n      }\n\n      return result;\n    }\n  }, {\n    key: "entitySquaredTransEuclideanDistance",\n    value: function entitySquaredTransEuclideanDistance(entityX, entityY) {\n      // Every world is a parallel leaf.\n      var result = 0;\n      var d;\n      var pX = entityX.position;\n      var pY = entityY.position;\n\n      for (var i = 0; i < 3; ++i) {\n        d = pX[i] - pY[i];\n        result += d * d;\n      }\n\n      return result;\n    }\n  }, {\n    key: "entitySquaredEuclideanDistance",\n    value: function entitySquaredEuclideanDistance(entityX, entityY) {\n      // Two entities on different worlds are considered infinitely far.\n      if (entityX.worldId !== entityY.worldId) return Number.POSITIVE_INFINITY; // Else return regular Euclidean distance.\n\n      var result = 0;\n      var d;\n      var pX = entityX.position;\n      var pY = entityY.position;\n\n      for (var i = 0; i < 3; ++i) {\n        d = pX[i] - pY[i];\n        result += d * d;\n      }\n\n      return result;\n    }\n  }, {\n    key: "euclideanDistance3",\n    value: function euclideanDistance3(v1, v2) {\n      var x = v1[0] - v2[0];\n      x *= x;\n      var y = v1[1] - v2[1];\n      y *= y;\n      var z = v1[2] - v2[2];\n      z *= z;\n      return Math.sqrt(x + y + z);\n    }\n  }]);\n\n  return GeometryUtils;\n}();\n\n/* harmony default export */ var math_geometry = (GeometryUtils);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_topology/updater/updater_access.js\n/**\n *\n */\n\n\nfunction updater_access_toConsumableArray(arr) { return updater_access_arrayWithoutHoles(arr) || updater_access_iterableToArray(arr) || updater_access_unsupportedIterableToArray(arr) || updater_access_nonIterableSpread(); }\n\nfunction updater_access_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction updater_access_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return updater_access_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return updater_access_arrayLikeToArray(o, minLen); }\n\nfunction updater_access_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction updater_access_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return updater_access_arrayLikeToArray(arr); }\n\nfunction updater_access_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction updater_access_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction updater_access_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction updater_access_createClass(Constructor, protoProps, staticProps) { if (protoProps) updater_access_defineProperties(Constructor.prototype, protoProps); if (staticProps) updater_access_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar updater_access_UpdaterAccess = /*#__PURE__*/function () {\n  function UpdaterAccess() {\n    updater_access_classCallCheck(this, UpdaterAccess);\n  }\n\n  updater_access_createClass(UpdaterAccess, null, [{\n    key: "requestAddBlock",\n    value: function requestAddBlock(originEntity, x, y, z, world, entityModel) {\n      var dimX = world.xSize;\n      var dimY = world.ySize;\n      var dimZ = world.zSize;\n      var chunkCoordinates = world.getChunkCoordinates(x, y, z);\n      var chunk = world.getChunk.apply(world, updater_access_toConsumableArray(chunkCoordinates));\n      var worldId = world.worldId;\n      var xOnChunk = (x >= 0 ? x : dimX - -x % dimX) % dimX;\n      var yOnChunk = (y >= 0 ? y : dimY - -y % dimY) % dimY;\n      var zOnChunk = (z >= 0 ? z : dimZ - -z % dimZ) % dimZ;\n      var coordsOnChunk = [xOnChunk, yOnChunk, zOnChunk];\n\n      function failure(reason) {\n        console.log("[UpdaterAccess/AddBlock] Request denied: ".concat(reason));\n      }\n\n      if (!UpdaterAccess.validateBlockEdition(originEntity, x, y, z)) {\n        failure(\'Requested location is too far away.\');\n        return;\n      }\n\n      if (chunk.what.apply(chunk, coordsOnChunk) !== 0) {\n        failure(\'Cannot add a block on a non-empty block.\');\n        return;\n      }\n\n      if (entityModel.anEntityIsPresentOn(worldId, x, y, z)) {\n        failure(\'An entity is present on the block.\');\n        return false;\n      }\n\n      return [chunk].concat(coordsOnChunk);\n    }\n  }, {\n    key: "requestDelBlock",\n    value: function requestDelBlock(originEntity, x, y, z, world) {\n      // Translate.\n      var dimX = world.xSize;\n      var dimY = world.ySize;\n      var dimZ = world.zSize;\n      var chunkCoordinates = world.getChunkCoordinates(x, y, z);\n      var chunk = world.getChunk.apply(world, updater_access_toConsumableArray(chunkCoordinates));\n      var xOnChunk = (x >= 0 ? x : dimX - -x % dimX) % dimX;\n      var yOnChunk = (y >= 0 ? y : dimY - -y % dimY) % dimY;\n      var zOnChunk = (z >= 0 ? z : dimZ - -z % dimZ) % dimZ;\n      var coordsOnChunk = [xOnChunk, yOnChunk, zOnChunk]; // Validate.\n\n      function failure(reason) {\n        console.log("[UpdaterAccess/DelBlock] Request denied: ".concat(reason));\n      }\n\n      if (!UpdaterAccess.validateBlockEdition(originEntity, x, y, z)) {\n        failure(\'Requested location is too far away.\');\n        return;\n      }\n\n      var oldBlock = chunk.what.apply(chunk, coordsOnChunk);\n\n      if (oldBlock === BlockType.AIR) {\n        failure(\'Cannot delete an empty block.\');\n        return;\n      }\n\n      if (oldBlock === BlockType.OBSIDIAN) {\n        failure(\'Cannot delete an obsidian block.\');\n        return;\n      }\n\n      return [chunk].concat(coordsOnChunk);\n    }\n  }, {\n    key: "validateBlockEdition",\n    value: function validateBlockEdition(originEntity, x, y, z) {\n      // 10 blocks maximum range for block editing.\n      var d3 = math_geometry.euclideanDistance3(originEntity.position, [x + .5, y + .5, z + .5]);\n      return d3 < 10;\n    }\n  }]);\n\n  return UpdaterAccess;\n}();\n\n/* harmony default export */ var updater_access = (updater_access_UpdaterAccess);\n// CONCATENATED MODULE: ./server/app/engine/game3d/model_world/chunk.js\n/**\n *\n */\n\n\nfunction chunk_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction chunk_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction chunk_createClass(Constructor, protoProps, staticProps) { if (protoProps) chunk_defineProperties(Constructor.prototype, protoProps); if (staticProps) chunk_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction chunk_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nvar chunk_Chunk = /*#__PURE__*/function () {\n  function Chunk(xSize, ySize, zSize, chunkId, world) {\n    chunk_classCallCheck(this, Chunk);\n\n    // App.\n    this._world = world; // Dimensions, coordinates\n\n    this._xSize = xSize;\n    this._ySize = ySize;\n    this._zSize = zSize;\n    this._capacity = this._xSize * this._ySize * this._zSize;\n    this._chunkId = chunkId;\n    var ijk = chunkId.split(\',\');\n    this._chunkI = parseInt(ijk[0], 10);\n    this._chunkJ = parseInt(ijk[1], 10);\n    this._chunkK = parseInt(ijk[2], 10); // Blocks.\n\n    /** Flat array. x, then y, then z. */\n\n    this._blocks = new Uint8Array(xSize * ySize * zSize);\n    /** Nested z-array. (each z -> ij layer, without primary offset) */\n\n    this._surfaceBlocks = [];\n    /** Each face -> index of its connected component. */\n\n    this._connectedComponents = new Uint8Array();\n    /**  Each connected component -> (sorted) list of face indices. */\n\n    this._fastConnectedComponents = {};\n    this._fastConnectedComponentsIds = {}; // Signed.\n\n    this._neighborBlocksReady = false;\n    this._blocksReady = false;\n    this._ready = false;\n    this.isEmpty = false;\n    this.isFull = false; // Events.\n\n    this._lastUpdated = math_time["a" /* default */].getTimeSecNano();\n    this._updates = [{}, {}, {}];\n  } // Getters\n\n\n  chunk_createClass(Chunk, [{\n    key: "_toIdUnsafe",\n    // Do not use! Used for getting blocks that might exceed capacity.\n    value: function _toIdUnsafe(x, y, z) {\n      return x + y * this._xSize + z * this._xSize * this._ySize;\n    }\n  }, {\n    key: "_toId",\n    value: function _toId(x, y, z) {\n      var id = x + y * this._xSize + z * this._xSize * this._ySize;\n\n      if (id >= this._capacity) {\n        console.log("chunk._toId: invalid request coordinates: ".concat(x, ",").concat(y, ",").concat(z, " -> ").concat(id));\n        var e = new Error();\n        console.log(e.stack);\n      }\n\n      return id;\n    }\n  }, {\n    key: "what",\n    value: function what(x, y, z) {\n      if (!this._blocksReady) return -1;\n\n      var id = this._toId(x, y, z);\n\n      if (id >= this._capacity || id < 0) return 0;\n      return this._blocks[id];\n    }\n    /**\n     * Do not use outside updater_block or updater_face.\n     * Only queries Manhattan neighborhood, only with max offset of 1.\n     */\n\n  }, {\n    key: "queryBlock",\n    value: function queryBlock(x, y, z) {\n      if (!this.blocksReady) return -1;\n\n      if (x >= 0 && y >= 0 && z >= 0 && x < this._xSize && y < this._ySize && z < this._zSize) {\n        var id = this._toId(x, y, z);\n\n        if (id < this._capacity && id >= 0) return this._blocks[id];\n      }\n\n      var nc;\n\n      if (x < 0) {\n        // x-\n        nc = builder_chunks.getNeighboringChunk(this, 1);\n\n        if (!nc || !nc.blocksReady) {\n          console.error(\'[QueryBlock] invalid rec.\');\n          return -1;\n        }\n\n        return nc.queryBlock(x + this._xSize, y, z);\n      } else if (x >= this._xSize) {\n        // x+\n        nc = builder_chunks.getNeighboringChunk(this, 0);\n\n        if (!nc || !nc.blocksReady) {\n          console.error(\'[QueryBlock] invalid rec.\');\n          return -1;\n        }\n\n        return nc.queryBlock(x - this._xSize, y, z);\n      } else if (y < 0) {\n        // y-\n        nc = builder_chunks.getNeighboringChunk(this, 3);\n\n        if (!nc || !nc.blocksReady) {\n          console.error(\'[QueryBlock] invalid rec.\');\n          return -1;\n        }\n\n        return nc.queryBlock(x, y + this._ySize, z);\n      } else if (y >= this._ySize) {\n        // y+\n        nc = builder_chunks.getNeighboringChunk(this, 2);\n\n        if (!nc || !nc.blocksReady) {\n          console.error(\'[QueryBlock] invalid rec.\');\n          return -1;\n        }\n\n        return nc.queryBlock(x, y - this._ySize, z);\n      } else if (z < 0) {\n        // z-\n        nc = builder_chunks.getNeighboringChunk(this, 5);\n\n        if (!nc || !nc.blocksReady) {\n          console.error(\'[QueryBlock] invalid rec.\');\n          return -1;\n        }\n\n        return nc.queryBlock(x, y, z + this._zSize);\n      } else if (z >= this._zSize) {\n        // z+\n        nc = builder_chunks.getNeighboringChunk(this, 4);\n\n        if (!nc || !nc.blocksReady) {\n          console.error(\'[QueryBlock] invalid rec.\');\n          return -1;\n        }\n\n        return nc.queryBlock(x, y, z - this._zSize);\n      }\n    }\n  }, {\n    key: "queryChunk",\n    value: function queryChunk(x, y, z) {\n      if (x >= 0 && y >= 0 && z >= 0 && x < this._xSize && y < this._ySize && z < this._zSize) {\n        var id = this._toId(x, y, z);\n\n        if (id < this._capacity && id >= 0) return [this, x, y, z];\n      }\n\n      var nc;\n\n      if (x < 0) {\n        // x-\n        nc = builder_chunks.getNeighboringChunk(this, 1);\n\n        if (!nc) {\n          console.error(\'[QueryBlock] invalid rec.\');\n          return;\n        }\n\n        return [nc, x + this._xSize, y, z];\n      } else if (x >= this._xSize) {\n        // x+\n        nc = builder_chunks.getNeighboringChunk(this, 0);\n\n        if (!nc) {\n          console.error(\'[QueryBlock] invalid rec.\');\n          return;\n        }\n\n        return [nc, x - this._xSize, y, z];\n      } else if (y < 0) {\n        // y-\n        nc = builder_chunks.getNeighboringChunk(this, 3);\n\n        if (!nc) {\n          console.error(\'[QueryBlock] invalid rec.\');\n          return;\n        }\n\n        return [nc, x, y + this._ySize, z];\n      } else if (y >= this._ySize) {\n        // y+\n        nc = builder_chunks.getNeighboringChunk(this, 2);\n\n        if (!nc) {\n          console.error(\'[QueryBlock] invalid rec.\');\n          return;\n        }\n\n        return [nc, x, y - this._ySize, z];\n      } else if (z < 0) {\n        // z-\n        nc = builder_chunks.getNeighboringChunk(this, 5);\n\n        if (!nc) {\n          console.error(\'[QueryBlock] invalid rec.\');\n          return;\n        }\n\n        return [nc, x, y, z + this._zSize];\n      } else if (z >= this._zSize) {\n        // z+\n        nc = builder_chunks.getNeighboringChunk(this, 4);\n\n        if (!nc) {\n          console.error(\'[QueryBlock] invalid rec.\');\n          return;\n        }\n\n        return [nc, x, y, z - this._zSize];\n      }\n    }\n  }, {\n    key: "contains",\n    value: function contains(x, y, z) {\n      return this.what(x, y, z) !== 0;\n    }\n  }, {\n    key: "getNeighbourChunkFromRelativeCoordinates",\n    value: function getNeighbourChunkFromRelativeCoordinates(x, y, z) {\n      var neighbourChunkI;\n      var neighbourChunkJ;\n      var neighbourChunkK;\n      var xS = this._xSize;\n      var yS = this._ySize;\n      var zS = this._zSize;\n      var ci = this._chunkI;\n      var cj = this._chunkJ;\n      var ck = this._chunkK;\n      var world = this._world;\n      if (x < 0) neighbourChunkI = ci - 1;else if (x >= xS) neighbourChunkI = ci + 1;else neighbourChunkI = ci;\n      if (y < 0) neighbourChunkJ = cj - 1;else if (y >= yS) neighbourChunkJ = cj + 1;else neighbourChunkJ = cj;\n      if (z < 0) neighbourChunkK = ck - 1;else if (z >= zS) neighbourChunkK = ck + 1;else neighbourChunkK = ck;\n      return world.getChunk(neighbourChunkI, neighbourChunkJ, neighbourChunkK);\n    } // Mustn\'t exceed negative [xyz] Size\n\n  }, {\n    key: "neighbourWhat",\n    value: function neighbourWhat(x, y, z) {\n      var localX;\n      var localY;\n      var localZ;\n      var xS = this._xSize;\n      var yS = this._ySize;\n      var zS = this._zSize;\n      if (x < 0) localX = xS + x;else if (x >= xS) localX = x % xS;else localX = x;\n      if (y < 0) localY = yS + y;else if (y >= yS) localY = y % yS;else localY = y;\n      if (z < 0) localZ = zS + z;else if (z >= zS) localZ = z % zS;else localZ = z;\n      var nChunk = this.getNeighbourChunkFromRelativeCoordinates(x, y, z);\n      return nChunk.what(localX, localY, localZ);\n    }\n  }, {\n    key: "neighbourContains",\n    value: function neighbourContains(x, y, z) {\n      return this.neighbourWhat(x, y, z) !== 0;\n    }\n  }, {\n    key: "add",\n    value: function add(x, y, z, blockId) {\n      var id = this._toId(x, y, z);\n\n      if (id >= this._capacity) return; // Update blocks, surface blocks, then surface faces.\n\n      this._blocks[id] = blockId;\n      return id;\n    }\n  }, {\n    key: "del",\n    value: function del(x, y, z) {\n      var id = this._toId(x, y, z);\n\n      if (id >= this._capacity) return; // Update blocks, surface blocks, then surface faces.\n\n      this._blocks[id] = 0;\n      return id;\n    }\n  }, {\n    key: "flushUpdates",\n    value: function flushUpdates() {\n      this._updates = [{}, {}, {}];\n    }\n  }, {\n    key: "chunkI",\n    get: function get() {\n      return this._chunkI;\n    }\n  }, {\n    key: "chunkJ",\n    get: function get() {\n      return this._chunkJ;\n    }\n  }, {\n    key: "chunkK",\n    get: function get() {\n      return this._chunkK;\n    }\n  }, {\n    key: "chunkId",\n    get: function get() {\n      return this._chunkId;\n    }\n  }, {\n    key: "dimensions",\n    get: function get() {\n      return [this._xSize, this._ySize, this._zSize];\n    }\n  }, {\n    key: "capacity",\n    get: function get() {\n      return this._capacity;\n    }\n  }, {\n    key: "blocks",\n    get: function get() {\n      return this._blocks;\n    },\n    // Setters\n    set: function set(newBlocks) {\n      this._blocks = newBlocks;\n    }\n  }, {\n    key: "surfaceBlocks",\n    get: function get() {\n      return this._surfaceBlocks;\n    },\n    set: function set(newSurfaceBlocks) {\n      this._surfaceBlocks = newSurfaceBlocks;\n    }\n  }, {\n    key: "fastComponents",\n    get: function get() {\n      return this._fastConnectedComponents;\n    },\n    set: function set(newFastComponents) {\n      this._fastConnectedComponents = newFastComponents;\n    }\n  }, {\n    key: "fastComponentsIds",\n    get: function get() {\n      return this._fastConnectedComponentsIds;\n    },\n    set: function set(newFastComponentsIds) {\n      this._fastConnectedComponentsIds = newFastComponentsIds;\n    }\n  }, {\n    key: "connectedComponents",\n    get: function get() {\n      return this._connectedComponents;\n    },\n    set: function set(newConnectedComponents) {\n      this._connectedComponents = newConnectedComponents;\n    }\n  }, {\n    key: "updates",\n    get: function get() {\n      return this._updates;\n    },\n    set: function set(newUpdates) {\n      this._updates = newUpdates;\n    }\n  }, {\n    key: "world",\n    get: function get() {\n      return this._world;\n    }\n  }, {\n    key: "ready",\n    get: function get() {\n      return this._ready;\n    },\n    set: function set(newReady) {\n      this._ready = newReady;\n    }\n  }, {\n    key: "blocksReady",\n    get: function get() {\n      return this._blocksReady;\n    },\n    set: function set(newReady) {\n      this._blocksReady = newReady;\n    }\n  }, {\n    key: "neighborBlocksReady",\n    get: function get() {\n      return this._neighborBlocksReady;\n    },\n    set: function set(newReady) {\n      this._neighborBlocksReady = newReady;\n    }\n  }]);\n\n  return Chunk;\n}();\n\nchunk_defineProperty(chunk_Chunk, "debug", false);\n\n/* harmony default export */ var model_world_chunk = (chunk_Chunk);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/generator/generator_simple_perlin.js\n/**\n *\n */\n\n\nfunction generator_simple_perlin_slicedToArray(arr, i) { return generator_simple_perlin_arrayWithHoles(arr) || generator_simple_perlin_iterableToArrayLimit(arr, i) || generator_simple_perlin_unsupportedIterableToArray(arr, i) || generator_simple_perlin_nonIterableRest(); }\n\nfunction generator_simple_perlin_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction generator_simple_perlin_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return generator_simple_perlin_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return generator_simple_perlin_arrayLikeToArray(o, minLen); }\n\nfunction generator_simple_perlin_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction generator_simple_perlin_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction generator_simple_perlin_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction generator_simple_perlin_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction generator_simple_perlin_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction generator_simple_perlin_createClass(Constructor, protoProps, staticProps) { if (protoProps) generator_simple_perlin_defineProperties(Constructor.prototype, protoProps); if (staticProps) generator_simple_perlin_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction generator_simple_perlin_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nvar generator_simple_perlin_SimplePerlin = /*#__PURE__*/function () {\n  function SimplePerlin() {\n    generator_simple_perlin_classCallCheck(this, SimplePerlin);\n  }\n\n  generator_simple_perlin_createClass(SimplePerlin, null, [{\n    key: "fade",\n    value: function fade(t) {\n      return t * t * t * (t * (t * 6 - 15) + 10);\n    }\n  }, {\n    key: "lerp",\n    value: function lerp(t, a, b) {\n      return a + t * (b - a);\n    }\n  }, {\n    key: "grad",\n    value: function grad(hash, x, y, z) {\n      var h = hash & 15;\n      var u = h < 8 ? x : y;\n      var v = h < 4 ? y : h === 12 || h === 14 ? x : z;\n      return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);\n    }\n  }, {\n    key: "noise",\n    value: function noise(x, y, z) {\n      var fade = SimplePerlin.fade;\n      var lerp = SimplePerlin.lerp;\n      var grad = SimplePerlin.grad;\n      var p = SimplePerlin.p;\n      var floorX = Math.floor(x);\n      var floorY = Math.floor(y);\n      var floorZ = Math.floor(z);\n      var X = floorX & 255;\n      var Y = floorY & 255;\n      var Z = floorZ & 255;\n      x -= floorX;\n      y -= floorY;\n      z -= floorZ;\n      var xMinus1 = x - 1;\n      var yMinus1 = y - 1;\n      var zMinus1 = z - 1;\n      var u = fade(x);\n      var v = fade(y);\n      var w = fade(z);\n      var A = p[X] + Y;\n      var AA = p[A] + Z;\n      var AB = p[A + 1] + Z;\n      var B = p[X + 1] + Y;\n      var BA = p[B] + Z;\n      var BB = p[B + 1] + Z;\n      return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), grad(p[BA], xMinus1, y, z)), lerp(u, grad(p[AB], x, yMinus1, z), grad(p[BB], xMinus1, yMinus1, z))), lerp(v, lerp(u, grad(p[AA + 1], x, y, zMinus1), grad(p[BA + 1], xMinus1, y, z - 1)), lerp(u, grad(p[AB + 1], x, yMinus1, zMinus1), grad(p[BB + 1], xMinus1, yMinus1, zMinus1))));\n    }\n  }, {\n    key: "addTree2D",\n    value: function addTree2D(blocks, x, y, bl, dx, dz, xy, normalSize, wood, leaves) {\n      if (x < 2 || x >= dx - 2 || y < 2 || y >= dx - 2) return; // square chunks!\n\n      for (var zz = Math.min(bl + 3, dz); zz < Math.min(bl + 7, dz); ++zz) {\n        var off = normalSize * zz;\n\n        for (var ox = -2; ox <= 2; ox++) {\n          for (var oy = -2; oy <= 2; oy++) {\n            var d = ox * ox + oy * oy + (zz - (bl + 4)) * (zz - (bl + 4));\n\n            if (d < 11) {\n              var currentBlock = ox + x + (oy + y) * dx + off;\n              blocks[currentBlock] = leaves;\n            }\n          }\n        }\n      }\n\n      for (var _zz = bl; _zz < Math.min(bl + 4, dz); ++_zz) {\n        var _currentBlock = xy + normalSize * _zz;\n\n        blocks[_currentBlock] = wood;\n      }\n    }\n  }, {\n    key: "getRandomOre",\n    value: function getRandomOre(seed) {\n      if (seed > 0.9) return BlockType.ORE_DIAMOND;else if (seed > 0.5) return BlockType.ORE_GOLD;else return BlockType.IRON;\n    }\n  }, {\n    key: "getMainBlock",\n    value: function getMainBlock(worldId) {\n      if (worldId === -1) return BlockType.GRASS;else {\n        var mod = worldId % 24;\n        return 32 + mod;\n      }\n    }\n  }, {\n    key: "simpleGeneration2D",\n    value: function simpleGeneration2D(chunk, worldId, worldInfo, perlinIntensity, shuffleChunks, blocks) {\n      var dims = chunk.dimensions;\n      var dx = dims[0];\n      var dy = dims[1];\n      var dz = dims[2];\n      var ci = chunk.chunkI;\n      var cj = chunk.chunkJ;\n      var ck = chunk.chunkK;\n      var offsetX = dx * ci;\n      var offsetY = dy * cj;\n      var offsetZ = dz * ck;\n      var stone = BlockType.STONE;\n      var water = BlockType.WATER;\n      var sand = BlockType.SAND;\n      var wood = BlockType.WOOD;\n      var leaves = BlockType.LEAVES; // Fill with grass on main world, sand everywhere else.\n\n      var widInt = parseInt(worldId, 10);\n      var isMainWorld = widInt === -1;\n      var mainBlockId = SimplePerlin.getMainBlock(widInt);\n      var normalSize = dx * dy;\n      var data = [];\n      var quality = 2; // const z = shuffleChunks ? Math.random() * 100 : 50;\n\n      var z = 4 * (shuffleChunks ? Math.random() * dz : Math.floor(dz / 2));\n      var hasTrees = worldInfo.trees === TreeType.SOME_TREES;\n\n      for (var i = 0; i < normalSize; ++i) {\n        data[i] = 0;\n      }\n\n      for (var iteration = 0; iteration < 4; ++iteration) {\n        for (var _i = 0; _i < normalSize; ++_i) {\n          var x = offsetX + _i % dx;\n          var y = offsetY + (_i / dx | 0); // / priority > | priority\n\n          data[_i] += SimplePerlin.noise(x / quality, y / quality, z) * quality;\n        }\n\n        quality *= 4;\n      } // Tree noise\n\n\n      var noise = function noise(x, y) {\n        var s = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453123;\n        return s - Math.floor(s);\n      };\n\n      for (var _x = 0; _x < dx; ++_x) {\n        for (var _y = 0; _y < dy; ++_y) {\n          var xy = _x + _y * dx;\n          var initOff = dz / 2;\n          var surfaceLevel = initOff + (data[xy] * perlinIntensity | 0);\n          var rockLevel = Math.floor(5 * surfaceLevel / 6) - offsetZ;\n          surfaceLevel -= offsetZ;\n          var rockLevelInChunk = Math.max(0, Math.min(rockLevel, dz));\n\n          for (var zz = 0; zz < rockLevelInChunk; ++zz) {\n            var currentBlock = xy + normalSize * zz; // Rock.\n\n            blocks[currentBlock] = stone; // Ore.\n\n            var r = Math.random();\n\n            if (r > 0.98) {\n              blocks[currentBlock] = SimplePerlin.getRandomOre((r - 0.98) * 50);\n            }\n          }\n\n          var surfaceLevelInChunk = Math.max(0, Math.min(surfaceLevel, dz));\n\n          for (var _zz2 = rockLevelInChunk; _zz2 < surfaceLevelInChunk; ++_zz2) {\n            // Grass or sand.\n            var _currentBlock2 = xy + normalSize * _zz2; // if (zz === bl - 1)\n            //     blocks[currentBlock] = water;\n            // else\n\n\n            blocks[_currentBlock2] = mainBlockId;\n          }\n\n          if (hasTrees && surfaceLevelInChunk >= 16 && rockLevelInChunk > 0 && _x > 1 && _x < dx - 2 && _y > 1 && _y < dy - 2) {\n            var rand = isMainWorld ? noise(_x, _y) : noise(_y, _x);\n\n            if (rand > 0.99) {\n              SimplePerlin.addTree2D(blocks, _x, _y, surfaceLevelInChunk, dx, dz, xy, normalSize, wood, leaves);\n            }\n          }\n\n          if (offsetZ < 0 || surfaceLevel > dz) {\n            for (var _zz3 = surfaceLevelInChunk; _zz3 < dz; ++_zz3) {\n              var _currentBlock3 = xy + normalSize * _zz3;\n\n              blocks[_currentBlock3] = water;\n            }\n          }\n\n          if (surfaceLevelInChunk < 16 && surfaceLevel < 16 && offsetZ < 0 && rockLevelInChunk > 0 || offsetZ === 0) {\n            for (var _zz4 = surfaceLevelInChunk; _zz4 < 16; ++_zz4) {\n              // Grass or sand.\n              var _currentBlock4 = xy + normalSize * _zz4;\n\n              if (surfaceLevelInChunk > 0 && _zz4 === surfaceLevelInChunk) blocks[_currentBlock4] = sand;else blocks[_currentBlock4] = water;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: "simpleGeneration3D",\n    value: function simpleGeneration3D(chunk, worldId, worldInfo, perlinIntensity, shuffleChunks, blocks) {\n      var directions = [];\n      var dims = chunk.dimensions;\n      var dx = dims[0];\n      var dy = dims[1];\n      var dz = dims[2];\n      var ci = chunk.chunkI;\n      var cj = chunk.chunkJ;\n      var ck = chunk.chunkK;\n      var offsetX = dx * ci;\n      var offsetY = dy * cj;\n      var offsetZ = dz * ck;\n      var center = worldInfo.center;\n      var radius = worldInfo.radius;\n      var air = BlockType.AIR;\n      var stone = BlockType.STONE;\n      var water = BlockType.WATER;\n      var iron = BlockType.IRON;\n      var sand = BlockType.SAND;\n      var obsidian = BlockType.OBSIDIAN;\n      var abs = Math.abs;\n      var max = Math.max;\n      var deltaX = center.x - parseInt(ci, 10);\n      var adx = abs(deltaX);\n      var deltaY = center.y - parseInt(cj, 10);\n      var ady = abs(deltaY);\n      var deltaZ = center.z - parseInt(ck, 10);\n      var adz = abs(deltaZ);\n\n      if ((max(adx, max(ady, adz)) > radius || (adx === radius) + (ady === radius) + (adz === radius) < 2) && (adx > radius - 1) + (ady > radius - 1) + (adz > radius - 1) > 1) {\n        blocks.fill(air);\n        chunk.isEmpty = true;\n        return;\n      } // full stone inside the cubeworld\n\n\n      if (adx < radius && ady < radius && adz < radius) {\n        if (adx < adz && ady < adz && adz > 0) {\n          directions.push(ck > center.z ? 3 : -3);\n        } else if (adx < ady && adz < ady && ady > 0) {\n          directions.push(cj > center.y ? 2 : -2);\n        } else if (ady < adx && adz < adx && adx > 0) {\n          directions.push(ci > center.x ? 1 : -1);\n        } else {\n          blocks.fill(stone);\n          chunk.isFull = true;\n          return;\n        }\n      } // XXX [GENERATION] manage full / empty chunks\n\n\n      if (adx === radius) directions.push(ci > center.x ? 1 : -1);\n      if (ady === radius) directions.push(cj > center.y ? 2 : -2);\n      if (adz === radius) directions.push(ck > center.z ? 3 : -3); // Fill with grass on main world, sand everywhere else.\n\n      var widInt = parseInt(worldId, 10);\n      var mainBlockId = SimplePerlin.getMainBlock(widInt);\n      var ijS = dx * dy;\n      var nbDirections = directions.length;\n\n      if (nbDirections === 3) {\n        // Eighth-full generation.\n        for (var lx = dx / 2, i = directions[0] > 0 ? 0 : lx, cx = 0; cx < lx; ++cx, ++i) {\n          for (var ly = dy / 2, j = directions[1] > 0 ? 0 : ly, cy = 0; cy < ly; ++cy, ++j) {\n            for (var lz = dz / 2, k = directions[2] > 0 ? 0 : lz, cz = 0; cz < lz; ++cz, ++k) {\n              blocks[i + j * dx + k * ijS] = obsidian;\n            }\n          }\n        }\n      } else if (nbDirections === 2) {\n        // Quarter-full generation.\n        // 1 or 2, then 2 or 3!\n        for (var a1 = abs(directions[0]), l1 = a1 === 1 ? dx / 2 : dy / 2, ij = directions[0] > 0 ? 0 : l1, c1 = 0; c1 < l1; ++c1, ++ij) {\n          for (var a2 = abs(directions[1]), l2 = a2 === 2 ? dy / 2 : dz / 2, jk = directions[1] > 0 ? 0 : l2, c2 = 0; c2 < l2; ++c2, ++jk) {\n            if (a1 > 1) {\n              var ijk = ij * dx + jk * ijS;\n\n              for (var x = 0; x < dx; ++x) {\n                blocks[x + ijk] = obsidian;\n              }\n            } else if (a2 > 2) {\n              var _ijk = ij + jk * ijS;\n\n              for (var y = 0; y < dy; ++y) {\n                blocks[_ijk + y * dx] = obsidian;\n              }\n            } else {\n              var _ijk2 = ij + jk * dx;\n\n              for (var z = 0; z < dz; ++z) {\n                blocks[_ijk2 + z * ijS] = obsidian;\n              }\n            }\n          }\n        }\n      } else if (nbDirections === 1) {\n        var v1 = directions[0]; // For signum & value.\n\n        var _a = abs(v1);\n\n        var _ref = _a > 2 ? [dx, dy, dz, dx * dy, offsetX, offsetY, offsetZ, 0] : _a > 1 ? [dx, dz, dy, dx * dz, offsetX, offsetZ, offsetY, 1] : [dy, dz, dx, dy * dz, offsetY, offsetZ, offsetX, 2],\n            _ref2 = generator_simple_perlin_slicedToArray(_ref, 8),\n            d1 = _ref2[0],\n            d2 = _ref2[1],\n            d3 = _ref2[2],\n            normalSize = _ref2[3],\n            offset1 = _ref2[4],\n            offset2 = _ref2[5],\n            offset3 = _ref2[6],\n            perm = _ref2[7]; // Can factor normalSize outside.\n\n\n        var data = [];\n        var quality = 2; // const z = shuffleChunks ? Math.random() * 100 : 50;\n\n        var _z = 4 * (shuffleChunks ? Math.random() * d3 : Math.floor(d3 / 2));\n\n        for (var _i2 = 0; _i2 < normalSize; ++_i2) {\n          data[_i2] = 0;\n        }\n\n        for (var iteration = 0; iteration < 4; ++iteration) {\n          for (var _i3 = 0; _i3 < normalSize; ++_i3) {\n            var _x2 = offset1 + _i3 % d1;\n\n            var _y2 = offset2 + (_i3 / d1 | 0); // / priority > | priority\n\n\n            data[_i3] += SimplePerlin.noise(_x2 / quality, _y2 / quality, _z) * quality;\n          }\n\n          quality *= 4;\n        } // Get vertical generation direction.\n\n\n        var getStride;\n\n        if (v1 > 0) {\n          if (perm === 0) getStride = function getStride(x1, y1, z1) {\n            return z1 * dx * dy + y1 * dx + x1;\n          };else if (perm === 1) getStride = function getStride(x1, y1, z1) {\n            return y1 * dx * dy + z1 * dx + x1;\n          };else getStride = function getStride(x1, y1, z1) {\n            return y1 * dx * dy + x1 * dx + z1;\n          };\n        } else if (v1 < 0) {\n          if (perm === 0) getStride = function getStride(x1, y1, z1) {\n            return (dz - 1 - z1) * dx * dy + y1 * dx + x1;\n          };else if (perm === 1) getStride = function getStride(x1, y1, z1) {\n            return y1 * dx * dy + (dz - 1 - z1) * dx + x1;\n          };else getStride = function getStride(x1, y1, z1) {\n            return y1 * dx * dy + x1 * dx + (dz - 1 - z1);\n          };\n        }\n\n        var r = parseInt(radius, 10);\n\n        switch (v1) {\n          case 1:\n            offset3 = (-center.x - r + parseInt(ci, 10)) * d1;\n            break;\n\n          case -1:\n            offset3 = (center.x - r - parseInt(ci, 10)) * d1;\n            break;\n\n          case 2:\n            offset3 = (-center.y - r + parseInt(cj, 10)) * d2;\n            break;\n\n          case -2:\n            offset3 = (center.y - r - parseInt(cj, 10)) * d2;\n            break;\n\n          case 3:\n            offset3 = (-center.z - r + parseInt(ck, 10)) * d3;\n            break;\n\n          case -3:\n            offset3 = (center.z - r - parseInt(ck, 10)) * d3;\n            break;\n        }\n\n        for (var _x3 = 0; _x3 < d1; ++_x3) {\n          for (var _y3 = 0; _y3 < d2; ++_y3) {\n            var h = d3 / 2 + (data[_x3 + _y3 * d1] * perlinIntensity | 0) - offset3;\n            var rockLevel = Math.floor(5 * h / 6) - offset3;\n            var rl = Math.max(0, Math.min(rockLevel, d3));\n\n            for (var zz = 0; zz < rl; ++zz) {\n              var currentBlock = getStride(_x3, _y3, zz); // Rock.\n\n              blocks[currentBlock] = stone; // Iron.\n\n              if (Math.random() > 0.99) blocks[currentBlock] = iron;\n            }\n\n            var bl = Math.max(0, Math.min(h, d3));\n\n            for (var _zz5 = rl; _zz5 < bl; ++_zz5) {\n              // Grass or sand.\n              var _currentBlock5 = getStride(_x3, _y3, _zz5); // if (zz === bl - 1)\n              //     blocks[currentBlock] = water;\n              // else\n\n\n              blocks[_currentBlock5] = mainBlockId;\n            }\n\n            if (bl < 8) {\n              for (var _zz6 = bl; _zz6 < 8; ++_zz6) {\n                // Grass or sand.\n                var _currentBlock6 = getStride(_x3, _y3, _zz6);\n\n                if (_zz6 <= bl) blocks[_currentBlock6] = sand;else blocks[_currentBlock6] = water;\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: "simplePerlinGeneration",\n    value: function simplePerlinGeneration(chunk, shuffleChunks, worldId, worldInfo) {\n      var dims = chunk.dimensions;\n      var dx = dims[0];\n      var dy = dims[1];\n      var dz = dims[2]; // Create blocks.\n\n      var blocks = new Uint8Array(dx * dy * dz); // Detect intensity\n\n      var hillsType = worldInfo.hills;\n      var perlinIntensity;\n\n      switch (hillsType) {\n        case HillType.NO_HILLS:\n          perlinIntensity = 0;\n          break;\n\n        case HillType.REGULAR_HILLS:\n          perlinIntensity = 0.2;\n          break;\n\n        case HillType.GIANT_HILLS:\n          perlinIntensity = 1.0;\n          break;\n\n        default:\n          perlinIntensity = 0.1;\n          break;\n      } // Detect cube or flat world.\n\n\n      var worldType = worldInfo.type;\n\n      switch (worldType) {\n        case model_WorldType.FLAT:\n          SimplePerlin.simpleGeneration2D(chunk, worldId, worldInfo, perlinIntensity, shuffleChunks, blocks); // 1: x, 2: y, 3: z, 4: full, 5: empty\n\n          break;\n\n        case model_WorldType.CUBE:\n          SimplePerlin.simpleGeneration3D(chunk, worldId, worldInfo, perlinIntensity, shuffleChunks, blocks);\n          break;\n\n        default:\n          console.error(\'[Generator Simple Perlin] Unknown world type.\');\n      }\n\n      chunk.blocks = blocks;\n      chunk.blocksReady = true;\n    }\n  }]);\n\n  return SimplePerlin;\n}();\n\ngenerator_simple_perlin_defineProperty(generator_simple_perlin_SimplePerlin, "p", [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180, 151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]);\n\n/* harmony default export */ var generator_simple_perlin = (generator_simple_perlin_SimplePerlin);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/generator/generator_fantasy.js\n\n\nfunction generator_fantasy_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction generator_fantasy_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction generator_fantasy_createClass(Constructor, protoProps, staticProps) { if (protoProps) generator_fantasy_defineProperties(Constructor.prototype, protoProps); if (staticProps) generator_fantasy_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar generator_fantasy_FantasyGenerator = /*#__PURE__*/function () {\n  function FantasyGenerator() {\n    generator_fantasy_classCallCheck(this, FantasyGenerator);\n  }\n\n  generator_fantasy_createClass(FantasyGenerator, null, [{\n    key: "simpleFantasyGeneration",\n    value: function simpleFantasyGeneration(worldMap, chunk) {\n      var d = chunk.dimensions;\n\n      if (d[0] !== d[1] || d[1] !== d[2]) {\n        console.error(\'[FantasyGenerator] Only works on square chunks.\');\n      }\n\n      var chunkSize = d[0];\n      var tileSize = worldMap.tileDimension;\n      var tileHalfSize = tileSize / 2;\n      var chunksPerTile = tileSize / chunkSize;\n      var ci = chunk.chunkI + tileHalfSize / chunksPerTile;\n      var cj = chunk.chunkJ + tileHalfSize / chunksPerTile;\n      var ck = chunk.chunkK; // Get tile from WorldMap if ready\n      // If not, create one and command generation\n\n      var tileI = Math.floor(ci / chunksPerTile);\n      var tileJ = Math.floor(cj / chunksPerTile);\n      var t = worldMap.makeNewTileIfNeeded(tileI, tileJ);\n\n      if (t.needsGeneration) {\n        return;\n      } // console.log(worldMap);\n      // console.log(chunk);\n\n\n      var stone = BlockType.STONE;\n      var grass = BlockType.GRASS;\n      var water = BlockType.WATER;\n      var sand = BlockType.SAND;\n      var air = BlockType.AIR;\n      var wood = BlockType.WOOD;\n      var stoneb = BlockType.STONEBRICKS;\n      var leaves = BlockType.LEAVES; // Get height buffer\n      // Fill height and water\n\n      var blocks = chunk.blocks;\n      var heightBuffer = t.getRaster();\n      var offsetI = ci * chunkSize;\n      var offsetJ = cj * chunkSize;\n      var offsetK = ck * chunkSize;\n      var ijs = chunkSize * chunkSize;\n      var idStart = offsetI * tileSize + offsetJ;\n\n      for (var i = 0; i < chunkSize; ++i) {\n        var offset = idStart + i * tileSize;\n\n        for (var j = 0; j < chunkSize; ++j) {\n          var h = heightBuffer[offset + j];\n          var height = Math.floor(h / 2) + 16; // Math.floor(h < -20 ? h / 500 : h / 20) + 16;\n\n          var oij = j * chunkSize + i;\n\n          if (height > offsetK + chunkSize) {\n            for (var k = 0; k < chunkSize; ++k) {\n              var bi = ijs * k + oij;\n              blocks[bi] = stone;\n            }\n          } else if (height < offsetK) {\n            if (offsetK > 16) {\n              for (var _k = 0; _k < chunkSize; ++_k) {\n                var _bi = ijs * _k + oij;\n\n                blocks[_bi] = air;\n              }\n            } else if (offsetK + chunkSize < 16) {\n              for (var _k2 = 0; _k2 < chunkSize; ++_k2) {\n                var _bi2 = ijs * _k2 + oij;\n\n                blocks[_bi2] = water;\n              }\n            } else {\n              for (var _k3 = 0; _k3 < chunkSize; ++_k3) {\n                var _bi3 = ijs * _k3 + oij;\n\n                blocks[_bi3] = offsetK + _k3 < 16 ? water : air;\n              }\n            }\n          } else {\n            var h1 = height - offsetK - 2;\n\n            for (var _k4 = 0; _k4 < h1; ++_k4) {\n              var _bi4 = ijs * _k4 + oij;\n\n              blocks[_bi4] = stone;\n            }\n\n            var h2 = h1 + 2;\n\n            for (var _k5 = h1; _k5 < h2; ++_k5) {\n              var _bi5 = ijs * _k5 + oij;\n\n              blocks[_bi5] = height < 16 ? sand : grass;\n            }\n\n            for (var _k6 = h2; _k6 < chunkSize; ++_k6) {\n              var _bi6 = ijs * _k6 + oij;\n\n              blocks[_bi6] = offsetK + _k6 < 16 ? water : air;\n            }\n          }\n        }\n      } // Get overlay buffer\n      // Fill trees and walls\n\n\n      var surfaceBuffer = t.getSurfaceRaster();\n\n      for (var _i = 0; _i < chunkSize; ++_i) {\n        var _offset = idStart + _i * tileSize;\n\n        for (var _j = 0; _j < chunkSize; ++_j) {\n          var _h = heightBuffer[_offset + _j];\n\n          var _height = Math.floor(_h / 2) + 16; // Math.floor(h < -20 ? h / 500 : h / 20) + 16;\n\n\n          var _oij = _j * chunkSize + _i;\n\n          var s = surfaceBuffer[_offset + _j];\n\n          if (_height >= 16 && s > 0) {\n            var _h2 = _height - offsetK - 2;\n\n            var _h3 = _h2 + 2;\n\n            if (s === 2) for (var _k7 = _h3; _k7 < Math.min(_h3 + 4, chunkSize); ++_k7) {\n              var _bi7 = ijs * _k7 + _oij;\n\n              blocks[_bi7] = stoneb;\n            } else if (s === 1) generator_simple_perlin.addTree2D(blocks, _i, _j, _h3, chunkSize, chunkSize, _i + chunkSize * _j, chunkSize * chunkSize, wood, leaves);\n          }\n        }\n      } // Tell chunk has been generated\n\n\n      chunk.blocksReady = true;\n    }\n  }]);\n\n  return FantasyGenerator;\n}();\n\n/* harmony default export */ var generator_fantasy = (generator_fantasy_FantasyGenerator);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/generator/chunkgenerator.js\n/**\n *\n */\n\n\nfunction chunkgenerator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction chunkgenerator_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction chunkgenerator_createClass(Constructor, protoProps, staticProps) { if (protoProps) chunkgenerator_defineProperties(Constructor.prototype, protoProps); if (staticProps) chunkgenerator_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction chunkgenerator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n // import WorldType        from \'./../../model_world/model\';\n\n\n\n\n\nvar chunkgenerator_ChunkGenerator = /*#__PURE__*/function () {\n  function ChunkGenerator() {\n    chunkgenerator_classCallCheck(this, ChunkGenerator);\n  }\n\n  chunkgenerator_createClass(ChunkGenerator, null, [{\n    key: "createRawChunk",\n\n    /**\n     * N.B. the created chunks are in memory but not ready yet.\n     * To finalize creation, add them into the manager model.\n     * Then, call Extractor.computeFaces(chunk).\n     */\n    value: function createRawChunk(x, y, z, id, world) {\n      var c = new model_world_chunk(x, y, z, id, world); // let shuffleChunks = false; // Can be set to activated to test for initial chunk.\n      // GenSimplePerlin.simplePerlinGeneration(\n      //     c, shuffleChunks, world.worldId, world.worldInfo\n      // );\n\n      world.pushChunkForGeneration(id);\n      return c;\n    }\n  }, {\n    key: "createChunk",\n    value: function createChunk(x, y, z, id, world) {\n      var c = new model_world_chunk(x, y, z, id, world); // GenSimplePerlin.simplePerlinGeneration(\n      //     c, false, world.worldId, world.worldInfo\n      // );\n\n      world.pushChunkForGeneration(id);\n      return c;\n    }\n  }, {\n    key: "generateChunkBlocks",\n    value: function generateChunkBlocks(chunk, worldMap) {\n      var worldId = chunk.world.worldId;\n      var worldInfo = chunk.world.worldInfo;\n\n      if (worldInfo.type === model_WorldType.FANTASY) {\n        generator_fantasy.simpleFantasyGeneration(worldMap, chunk);\n      } else {\n        generator_simple_perlin.simplePerlinGeneration(chunk, false, worldId, worldInfo); // Correction for 0,0\n\n        if (worldInfo.type === model_WorldType.FLAT && chunk.chunkI === 0 && chunk.chunkJ === 0 && chunk.chunkK === 0 && chunk.dimensions[0] === 32 && chunk.dimensions[1] === 32) {\n          var b = chunk.blocks;\n          var n = chunk.dimensions[0];\n          var onm = 16 * chunk.dimensions[0] * chunk.dimensions[1];\n\n          for (var j = -2; j < 2; ++j) {\n            var o = (16 + j) * n + 16;\n\n            for (var i = -2; i < 2; ++i) {\n              b[onm + o + i] = BlockType.STONEBRICKS;\n            }\n          }\n        }\n      }\n    }\n  }]);\n\n  return ChunkGenerator;\n}();\n\nchunkgenerator_defineProperty(chunkgenerator_ChunkGenerator, "debug", false);\n\n/* harmony default export */ var chunkgenerator = (chunkgenerator_ChunkGenerator);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/builder/surface_blocks_builder.js\n/**\n *\n */\n\n\nfunction surface_blocks_builder_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction surface_blocks_builder_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction surface_blocks_builder_createClass(Constructor, protoProps, staticProps) { if (protoProps) surface_blocks_builder_defineProperties(Constructor.prototype, protoProps); if (staticProps) surface_blocks_builder_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction surface_blocks_builder_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nvar surface_blocks_builder_CSBX = /*#__PURE__*/function () {\n  function CSBX() {\n    surface_blocks_builder_classCallCheck(this, CSBX);\n  }\n\n  surface_blocks_builder_createClass(CSBX, null, [{\n    key: "extractSurfaceBlocks",\n    value: function extractSurfaceBlocks(chunk) {\n      var neighbourChunks = [];\n      var neighbourBlocks = [];\n      var numberOfNeighbours = 6; // Get all neighbour chunks.\n\n      for (var i = 0; i < numberOfNeighbours; ++i) {\n        var neighbour = builder_chunks.getNeighboringChunk(chunk, i);\n\n        if (!neighbour.blocksReady) {\n          console.error(\'[Builder] Trying to build faces from chunk with unloaded neighbors.\');\n        }\n\n        neighbourChunks.push(neighbour);\n        neighbourBlocks.push(neighbour.blocks);\n      }\n\n      var currentSbs = chunk.surfaceBlocks;\n      var blocks = chunk.blocks;\n      var iSize = chunk.dimensions[0];\n      var ijSize = chunk.dimensions[0] * chunk.dimensions[1];\n      var capacity = blocks.length;\n      var airBlock = BlockType.AIR;\n      var waterBlock = BlockType.WATER; // Test neighbourhood.\n\n      for (var b = 0; b < capacity; ++b) {\n        var currentBlock = blocks[b]; // Air surface\n\n        if (currentBlock !== airBlock) {\n          if (CSBX.processNeighborhoodFromBlockEqual(b, iSize, ijSize, capacity, blocks, neighbourBlocks, currentSbs, airBlock)) continue; // No need to do the water check.\n        } else if (currentBlock === airBlock) {\n          // If the current block is air, test for neighbour x+/y+/z+\n          if (CSBX.processNeighborhoodFromBlockDifferent(b, iSize, ijSize, capacity, neighbourBlocks, currentSbs, airBlock)) continue; // No need to do the water check.\n        } // Water surface\n\n\n        if (currentBlock !== waterBlock) {\n          CSBX.processNeighborhoodFromBlockEqual(b, iSize, ijSize, capacity, blocks, neighbourBlocks, currentSbs, waterBlock);\n        } else if (currentBlock === waterBlock) {\n          // If the current block is water\n          CSBX.processNeighborhoodFromBlockDifferent(b, iSize, ijSize, capacity, neighbourBlocks, currentSbs, waterBlock);\n        }\n      }\n    }\n  }, {\n    key: "addSurfaceBlock",\n    value: function addSurfaceBlock(bid, sbs) {\n      sbs.push(bid); // const ijC = bid % ijSize;\n      // const z = (bid - ijC) / ijSize;\n      // if (sbs.hasOwnProperty(z)) sbs[z].push(ijC);\n      // else sbs[z] = [ijC];\n    }\n  }, {\n    key: "processNeighborhoodFromBlockDifferent",\n    value: function processNeighborhoodFromBlockDifferent(b, iSize, ijSize, capacity, neighbourBlocks, currentSbs, blockType) {\n      var iPlus = b + 1;\n\n      if (iPlus % iSize === 0) {\n        if (neighbourBlocks[0][iPlus - iSize] !== blockType) {\n          CSBX.addSurfaceBlock(b, currentSbs);\n          return true;\n        }\n      }\n\n      var jPlus = b + iSize;\n\n      if ((jPlus - b % iSize) % ijSize === 0) {\n        if (neighbourBlocks[2][jPlus - ijSize] !== blockType) {\n          CSBX.addSurfaceBlock(b, currentSbs);\n          return true;\n        }\n      }\n\n      var kPlus = b + ijSize;\n\n      if (kPlus >= capacity) {\n        if (neighbourBlocks[4][kPlus - capacity] !== blockType) {\n          CSBX.addSurfaceBlock(b, currentSbs);\n          return true;\n        }\n      }\n    }\n  }, {\n    key: "processNeighborhoodFromBlockEqual",\n    value: function processNeighborhoodFromBlockEqual(b, iSize, ijSize, capacity, blocks, neighbourBlocks, currentSbs, blockType) {\n      var iPlus = b + 1;\n\n      if (iPlus % iSize !== 0) {\n        if (blocks[iPlus] === blockType) {\n          CSBX.addSurfaceBlock(b, currentSbs);\n          return true;\n        } // Access other chunk\n\n      } else if (neighbourBlocks[0][iPlus - iSize] === blockType) {\n        CSBX.addSurfaceBlock(b, currentSbs);\n        return true;\n      }\n\n      var iMinus = b - 1;\n\n      if (iMinus % iSize !== iSize - 1) {\n        if (blocks[iMinus] === blockType) {\n          CSBX.addSurfaceBlock(b, currentSbs);\n          return true;\n        } // Access other chunk\n\n      } else if (neighbourBlocks[1][iMinus + iSize] === blockType) {\n        CSBX.addSurfaceBlock(b, currentSbs);\n        return true;\n      }\n\n      var jPlus = b + iSize;\n\n      if ((jPlus - b % iSize) % ijSize !== 0) {\n        if (blocks[jPlus] === blockType) {\n          CSBX.addSurfaceBlock(b, currentSbs);\n          return true;\n        } // Access other chunk\n\n      } else if (neighbourBlocks[2][jPlus - ijSize] === blockType) {\n        CSBX.addSurfaceBlock(b, currentSbs);\n        return true;\n      }\n\n      var jMinus = b - iSize;\n\n      if ((jMinus - b % iSize) % ijSize !== ijSize - 1) {\n        if (blocks[jMinus] === blockType) {\n          CSBX.addSurfaceBlock(b, currentSbs);\n          return true;\n        } // Access other chunk\n\n      } else if (neighbourBlocks[3][jMinus + ijSize] === blockType) {\n        CSBX.addSurfaceBlock(b, currentSbs);\n        return true;\n      }\n\n      var kPlus = b + ijSize;\n\n      if (kPlus < capacity) {\n        if (blocks[kPlus] === blockType) {\n          CSBX.addSurfaceBlock(b, currentSbs);\n          return true;\n        }\n      } else if (neighbourBlocks[4][kPlus - capacity] === blockType) {\n        CSBX.addSurfaceBlock(b, currentSbs);\n        return true;\n      }\n\n      var kMinus = b - ijSize;\n\n      if (kMinus >= 0) {\n        if (blocks[kMinus] === blockType) {\n          CSBX.addSurfaceBlock(b, currentSbs);\n          return true;\n        }\n      } else if (neighbourBlocks[5][kMinus + capacity] === blockType) {\n        CSBX.addSurfaceBlock(b, currentSbs);\n        return true;\n      }\n\n      if (CSBX.debug) console.log("".concat(b, " is not a neighbour."));\n    }\n  }]);\n\n  return CSBX;\n}();\n\nsurface_blocks_builder_defineProperty(surface_blocks_builder_CSBX, "debug", false);\n\n/* harmony default export */ var surface_blocks_builder = (surface_blocks_builder_CSBX);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/builder/surface_faces_builder.js\n/**\n *\n */\n\n\nfunction surface_faces_builder_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction surface_faces_builder_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction surface_faces_builder_createClass(Constructor, protoProps, staticProps) { if (protoProps) surface_faces_builder_defineProperties(Constructor.prototype, protoProps); if (staticProps) surface_faces_builder_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction surface_faces_builder_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nvar surface_faces_builder_CSFX = /*#__PURE__*/function () {\n  function CSFX() {\n    surface_faces_builder_classCallCheck(this, CSFX);\n  }\n\n  surface_faces_builder_createClass(CSFX, null, [{\n    key: "inbounds",\n    value: function inbounds(d, b, iS, ijS, capacity) {\n      switch (d) {\n        case 0:\n          return (b - 1) % iS === b % iS - 1;\n        // iM\n\n        case 1:\n          return (b - iS) % ijS === b % ijS - iS;\n        // jM\n\n        case 2:\n          return b - ijS >= 0;\n        // kM\n\n        case 3:\n          return (b + 1) % iS !== 0;\n        // iP\n\n        case 4:\n          return (b + iS - b % iS) % ijS !== 0;\n        // jP\n\n        case 5:\n          return b + ijS < capacity;\n        // kP\n\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: "empty",\n    value: function empty(d, b, bs, iS, ijS) {\n      switch (d) {\n        case 0:\n          return bs[b - 1] === 0;\n        // iM\n\n        case 1:\n          return bs[b - iS] === 0;\n        // jM\n\n        case 2:\n          return bs[b - ijS] === 0;\n        // kM\n\n        case 3:\n          return bs[b + 1] === 0;\n        // iP\n\n        case 4:\n          return bs[b + iS] === 0;\n        // jP\n\n        case 5:\n          return bs[b + ijS] === 0;\n        // kP\n\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: "hasNeighbourOfType",\n    value: function hasNeighbourOfType(d, b, bs, iS, ijS, blockType) {\n      switch (d) {\n        case 0:\n          return bs[b - 1] === blockType;\n        // iM\n\n        case 1:\n          return bs[b - iS] === blockType;\n        // jM\n\n        case 2:\n          return bs[b - ijS] === blockType;\n        // kM\n\n        case 3:\n          return bs[b + 1] === blockType;\n        // iP\n\n        case 4:\n          return bs[b + iS] === blockType;\n        // jP\n\n        case 5:\n          return bs[b + ijS] === blockType;\n        // kP\n\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: "setFace",\n    value: function setFace(direction, bid, blockNature, faces, surfaceFaces, encounteredFaces, connectedComponents, capacity, iS, ijS, ccid, dontTranslate) {\n      var blockId = bid;\n\n      if (!dontTranslate) {\n        // Boundary faces with reverted normals.\n        switch (direction) {\n          case 0:\n            blockId -= 1;\n            break;\n\n          case 1:\n            blockId -= iS;\n            break;\n\n          case 2:\n            blockId -= ijS;\n            break;\n\n          default:\n        }\n      } // Set surface face\n\n\n      var d = direction % 3;\n      if (d in surfaceFaces) surfaceFaces[d].push(blockId);else surfaceFaces[d] = [blockId]; // Set faces\n\n      var factor = direction < 3 ? -1 : 1; // Face normal (-1 => towards minus)\n\n      faces[d][blockId] = factor * blockNature; // Face nature\n      // Set connected component\n\n      var faceId = d * capacity + blockId;\n      encounteredFaces[faceId] = ccid;\n      connectedComponents[faceId] = ccid;\n    }\n  }, {\n    key: "extractRawFacesPerBlock",\n    value: function extractRawFacesPerBlock( // z, layer,\n    blockId, iS, jS, kS, ijS, capacity, nbX, nbY, nbZ, blocks, faces, surfaceFaces, encounteredFaces, connectedComponents) {\n      var airBlock = BlockType.AIR;\n      var waterBlock = BlockType.WATER; // !air-air => ccid = 1\n      // !water-water => ccid = 2\n\n      var block = blocks[blockId];\n\n      for (var direction = 0; direction < 6; ++direction) {\n        if (CSFX.inbounds(direction, blockId, iS, ijS, capacity)) {\n          if (block !== airBlock && CSFX.hasNeighbourOfType(direction, blockId, blocks, iS, ijS, airBlock)) {\n            CSFX.setFace(direction, blockId, block, faces, surfaceFaces, encounteredFaces, connectedComponents, capacity, iS, ijS, block !== waterBlock ? 1 : 2); // this face is rock or water surface\n          } else if (block !== airBlock && block !== waterBlock && CSFX.hasNeighbourOfType(direction, blockId, blocks, iS, ijS, waterBlock)) {\n            CSFX.setFace(direction, blockId, block, faces, surfaceFaces, encounteredFaces, connectedComponents, capacity, iS, ijS, 1); // this face is underwater\n          }\n        } // Not inbounds -> only +\n        // if (direction >= 3) { // x+, y+, z+\n        else if (direction === 3) {\n            var xblock = nbX[blockId - iS + 1];\n\n            if (block !== airBlock && xblock === airBlock) {\n              // i+\n              CSFX.setFace(3, blockId, block, faces, surfaceFaces, encounteredFaces, connectedComponents, capacity, iS, ijS, block !== waterBlock ? 1 : 2);\n            } else if (block === airBlock && xblock !== airBlock && xblock !== undefined) {\n              // i+\n              CSFX.setFace(0, blockId, xblock, faces, surfaceFaces, encounteredFaces, connectedComponents, capacity, iS, ijS, xblock !== waterBlock ? 1 : 2, true);\n            } else if (block !== airBlock && block !== waterBlock && xblock === waterBlock) {\n              CSFX.setFace(3, blockId, block, faces, surfaceFaces, encounteredFaces, connectedComponents, capacity, iS, ijS, 1);\n            } else if (block === waterBlock && xblock !== airBlock && xblock !== waterBlock && xblock !== undefined) {\n              CSFX.setFace(0, blockId, xblock, faces, surfaceFaces, encounteredFaces, connectedComponents, capacity, iS, ijS, 1, true);\n            }\n          } else if (direction === 4) {\n            // j+\n            var yblock = nbY[blockId - ijS + iS];\n\n            if (block !== airBlock && yblock === airBlock) {\n              CSFX.setFace(4, blockId, block, faces, surfaceFaces, encounteredFaces, connectedComponents, capacity, iS, ijS, block !== waterBlock ? 1 : 2);\n            } else if (block === airBlock && yblock !== airBlock && yblock !== undefined) {\n              CSFX.setFace(1, blockId, yblock, faces, surfaceFaces, encounteredFaces, connectedComponents, capacity, iS, ijS, yblock !== waterBlock ? 1 : 2, true);\n            } else if (block !== airBlock && block !== waterBlock && yblock === waterBlock) {\n              CSFX.setFace(4, blockId, block, faces, surfaceFaces, encounteredFaces, connectedComponents, capacity, iS, ijS, 1);\n            } else if (block === waterBlock && yblock !== airBlock && yblock !== waterBlock && yblock !== undefined) {\n              CSFX.setFace(1, blockId, yblock, faces, surfaceFaces, encounteredFaces, connectedComponents, capacity, iS, ijS, 1, true);\n            }\n          } else if (direction === 5) {\n            // k+\n            var zblock = nbZ[blockId - capacity + ijS];\n\n            if (block !== airBlock && zblock === airBlock) {\n              CSFX.setFace(5, blockId, block, faces, surfaceFaces, encounteredFaces, connectedComponents, capacity, iS, ijS, block !== waterBlock ? 1 : 2);\n            } else if (block === airBlock && zblock !== airBlock && zblock !== undefined) {\n              CSFX.setFace(2, blockId, zblock, faces, surfaceFaces, encounteredFaces, connectedComponents, capacity, iS, ijS, zblock !== waterBlock ? 1 : 2, true);\n            } else if (block !== airBlock && block !== waterBlock && zblock === waterBlock) {\n              CSFX.setFace(5, blockId, block, faces, surfaceFaces, encounteredFaces, connectedComponents, capacity, iS, ijS, 1);\n            } else if (block === waterBlock && zblock !== airBlock && zblock !== waterBlock && zblock !== undefined) {\n              CSFX.setFace(2, blockId, zblock, faces, surfaceFaces, encounteredFaces, connectedComponents, capacity, iS, ijS, 1, true);\n            }\n          }\n      } // }\n\n    }\n  }, {\n    key: "extractRawFaces",\n    value: function extractRawFaces(blocks, neighbourBlocks, surfaceBlocks, faces, surfaceFaces, encounteredFaces, connectedComponents, dims) {\n      var iS = dims[0];\n      var jS = dims[1];\n      var kS = dims[2];\n      var ijS = iS * jS;\n      var capacity = ijS * kS;\n      var nbX = neighbourBlocks[0]; // On x+ boundary.\n\n      var nbY = neighbourBlocks[2]; // On y+ boundary.\n\n      var nbZ = neighbourBlocks[4]; // On z+ boundary.\n      // Extract faces.\n\n      for (var i = 0; i < surfaceBlocks.length; ++i) {\n        var id = surfaceBlocks[i];\n        CSFX.extractRawFacesPerBlock(id, iS, jS, kS, ijS, capacity, nbX, nbY, nbZ, blocks, faces, surfaceFaces, encounteredFaces, connectedComponents);\n      }\n\n      if (CSFX.debug) {\n        console.log("Surface block layers ".concat(Object.keys(surfaceBlocks).length, " surface faces: (") + "".concat(surfaceFaces[0].length, ",").concat(surfaceFaces[1].length, ",").concat(surfaceFaces[2].length));\n      }\n    }\n  }, {\n    key: "computeFastConnectedComponents",\n    value: function computeFastConnectedComponents(connectedComponents, fastCC) {\n      for (var i = 0, length = connectedComponents.length; i < length; ++i) {\n        if (connectedComponents[i] === 0) continue;\n        if (!fastCC.hasOwnProperty(connectedComponents[i])) fastCC[connectedComponents[i]] = [i];else fastCC[connectedComponents[i]].push(i);\n      }\n    }\n  }, {\n    key: "computeFastConnectedComponentIds",\n    value: function computeFastConnectedComponentIds(fastCC, fastCCIds, capacity, faces) {\n      for (var cccid in fastCC) {\n        if (!fastCC.hasOwnProperty(cccid)) continue;\n        fastCCIds[cccid] = [];\n        var tcur = fastCCIds[cccid];\n        var fcc = fastCC[cccid];\n\n        for (var i in fcc) {\n          if (!fcc.hasOwnProperty(i)) continue;\n          var j = fcc[i];\n          var orientation = j < capacity ? 0 : j < 2 * capacity ? 1 : 2;\n          var realId = j % capacity;\n          tcur.push(faces[orientation][realId]);\n        }\n      }\n    }\n  }, {\n    key: "getNeighbourChunks",\n    value: function getNeighbourChunks(neighbourChunks, chunk, neighbourBlocks) {\n      for (var i = 0; i < 18; ++i) {\n        neighbourChunks.push(builder_chunks.getNeighboringChunk(chunk, i));\n        neighbourBlocks.push(neighbourChunks[i].blocks);\n      }\n    } //\n\n  }, {\n    key: "extractConnectedComponents",\n    value: function extractConnectedComponents(chunk) {\n      var neighbourChunks = [];\n      var neighbourBlocks = []; // Get all six neighbour chunks.\n\n      CSFX.getNeighbourChunks(neighbourChunks, chunk, neighbourBlocks); // Properties\n\n      var surfaceBlocks = chunk.surfaceBlocks;\n      var blocks = chunk.blocks; // Static properties\n\n      var dims = chunk.dimensions; // const iS = chunk.dimensions[0];\n      // const ijS = chunk.dimensions[0] * chunk.dimensions[1];\n\n      var capacity = blocks.length; // Temporary variables\n\n      var surfaceFaces = {\n        0: [],\n        1: [],\n        2: []\n      };\n      var faces = [new Int32Array(capacity), new Int32Array(capacity), new Int32Array(capacity)];\n      var encounteredFaces = new Uint16Array(3 * capacity); // initializes all to 0\n      // Results\n\n      var connectedComponents = new Uint16Array(3 * capacity); // ditto\n\n      var fastCC = {};\n      var fastCCIds = {}; // Compute raw faces.\n\n      CSFX.extractRawFaces(blocks, neighbourBlocks, surfaceBlocks, faces, surfaceFaces, encounteredFaces, connectedComponents, dims); // Compute fast connected components.\n\n      CSFX.computeFastConnectedComponents(connectedComponents, fastCC); // Debugging fastCC\n      // for (let i in fastCC) {\n      //     for (let faceId = 0; faceId < fastCC[i].length; ++faceId)\n      //     {\n      //         if (fastCC[i].indexOf(fastCC[i][faceId]) !== faceId)\n      //             console.log(\'Detected duplicate face.\');\n      //\n      //         let dir = fastCC[i][faceId] < capacity ? 0 : fastCC[i][faceId] < 2 * capacity ? 1 : 2;\n      //\n      //         if (CSFX.debugFastCC)\n      //             if (faces[dir][fastCC[i][faceId] % capacity] === 0)\n      //                 console.log(\n      //                     `Face ${fastCC[i][faceId]} null: ${faces[dir][fastCC[i][faceId] % capacity]}`\n      //                 );\n      //     }\n      // }\n      // Induce Ids.\n\n      CSFX.computeFastConnectedComponentIds(fastCC, fastCCIds, capacity, faces); // Assign\n\n      chunk.fastComponents = fastCC;\n      chunk.fastComponentsIds = fastCCIds;\n      chunk.connectedComponents = connectedComponents;\n\n      if (CSFX.debugFastCC) {//console.log(fastCC);\n        //console.log(fastCCIds);\n      }\n\n      if (CSFX.debug) console.log("".concat(Object.keys(fastCC).length, " connected components extracted..."));\n    }\n  }]);\n\n  return CSFX;\n}();\n\nsurface_faces_builder_defineProperty(surface_faces_builder_CSFX, "debug", false);\n\nsurface_faces_builder_defineProperty(surface_faces_builder_CSFX, "debugFastCC", false);\n\n/* harmony default export */ var surface_faces_builder = (surface_faces_builder_CSFX);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/builder/builder_chunks.js\n/**\n *\n */\n\n\nfunction builder_chunks_toConsumableArray(arr) { return builder_chunks_arrayWithoutHoles(arr) || builder_chunks_iterableToArray(arr) || builder_chunks_unsupportedIterableToArray(arr) || builder_chunks_nonIterableSpread(); }\n\nfunction builder_chunks_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction builder_chunks_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return builder_chunks_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return builder_chunks_arrayLikeToArray(o, minLen); }\n\nfunction builder_chunks_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction builder_chunks_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return builder_chunks_arrayLikeToArray(arr); }\n\nfunction builder_chunks_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction builder_chunks_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction builder_chunks_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction builder_chunks_createClass(Constructor, protoProps, staticProps) { if (protoProps) builder_chunks_defineProperties(Constructor.prototype, protoProps); if (staticProps) builder_chunks_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction builder_chunks_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nvar builder_chunks_ChunkBuilder = /*#__PURE__*/function () {\n  function ChunkBuilder() {\n    builder_chunks_classCallCheck(this, ChunkBuilder);\n  }\n\n  builder_chunks_createClass(ChunkBuilder, null, [{\n    key: "computeChunkFaces",\n    value: function computeChunkFaces(chunk) {\n      if (!chunk.blocksReady) {\n        console.warn(\'[ChunkBuilder] Blocks not ready yet.\');\n        return;\n      }\n\n      var world = chunk.world; // Preload neighbours.\n\n      if (ChunkBuilder.debug) console.log(\'\\tPreloading neighbor chunks...\');\n      var status = ChunkBuilder.preloadAllNeighbourChunks(chunk, world);\n\n      if (!status) {\n        // console.log(\'[ChunkBuilder] Neighbor chunk blocks not ready yet.\');\n        return;\n      } // Detect boundary blocks.\n\n\n      if (ChunkBuilder.debug) console.log(\'\\tExtracting surface...\');\n      surface_blocks_builder.extractSurfaceBlocks(chunk); // Detect connected boundary face components.\n\n      if (ChunkBuilder.debug) console.log(\'\\tComputing connected components...\');\n      surface_faces_builder.extractConnectedComponents(chunk); //\n\n      chunk.ready = true;\n    }\n    /** MODEL\n     0\ti+1,\tj,\t\tk\n     1\ti-1,\tj,\t\tk\n     2\ti,\t\tj+1,\tk\n     3\ti,\t\tj-1,\tk\n     4\ti,\t\tj,\t\tk+1\n     5\ti,\t\tj,\t\tk-1\n     6\ti+1,\tj+1,\tk\n     7\ti-1,\tj+1,\tk\n     8\ti+1,\tj-1,\tk\n     9\ti-1,\tj-1,\tk\n     10\ti+1,\tj,\t\tk-1\n     11\ti+1,\tj,\t\tk+1\n     12\ti-1,\tj,\t\tk-1\n     13\ti-1,\tj,\t\tk+1\n     14\ti,\t\tj+1,\tk+1\n     15\ti,\t\tj-1,\tk+1\n     16\ti,\t\tj+1,\tk-1\n     17\ti,\t\tj-1,\tk-1\n    */\n\n  }, {\n    key: "getNeighboringChunk",\n    value: function getNeighboringChunk(chunk, direction) {\n      var i = chunk.chunkI;\n      var j = chunk.chunkJ;\n      var k = chunk.chunkK;\n      var world = chunk.world;\n\n      switch (direction) {\n        case 0:\n          return world.getChunk(i + 1, j, k);\n        // x+\n\n        case 1:\n          return world.getChunk(i - 1, j, k);\n        // x-\n\n        case 2:\n          return world.getChunk(i, j + 1, k);\n        // y+\n\n        case 3:\n          return world.getChunk(i, j - 1, k);\n        // y-\n\n        case 4:\n          return world.getChunk(i, j, k + 1);\n        // z+\n\n        case 5:\n          return world.getChunk(i, j, k - 1);\n        // z- (idem)\n\n        case 6:\n          return world.getChunk(i + 1, j + 1, k);\n\n        case 7:\n          return world.getChunk(i - 1, j + 1, k);\n\n        case 8:\n          return world.getChunk(i + 1, j - 1, k);\n\n        case 9:\n          return world.getChunk(i - 1, j - 1, k);\n\n        case 10:\n          return world.getChunk(i + 1, j, k - 1);\n\n        case 11:\n          return world.getChunk(i + 1, j, k + 1);\n\n        case 12:\n          return world.getChunk(i - 1, j, k - 1);\n\n        case 13:\n          return world.getChunk(i - 1, j, k + 1);\n\n        case 14:\n          return world.getChunk(i, j + 1, k + 1);\n\n        case 15:\n          return world.getChunk(i, j - 1, k + 1);\n\n        case 16:\n          return world.getChunk(i, j + 1, k - 1);\n\n        case 17:\n          return world.getChunk(i, j - 1, k - 1);\n\n        default:\n      }\n    }\n  }, {\n    key: "isNeighboringChunkLoaded",\n    value: function isNeighboringChunkLoaded(chunk, direction) {\n      var i = chunk.chunkI;\n      var j = chunk.chunkJ;\n      var k = chunk.chunkK;\n      var world = chunk.world;\n\n      switch (direction) {\n        case 0:\n          return world.hasChunk(i + 1, j, k);\n        // x+\n\n        case 1:\n          return world.hasChunk(i - 1, j, k);\n        // x-\n\n        case 2:\n          return world.hasChunk(i, j + 1, k);\n        // y+\n\n        case 3:\n          return world.hasChunk(i, j - 1, k);\n        // y-\n\n        case 4:\n          return world.hasChunk(i, j, k + 1);\n        // z+ (non-flat models)\n\n        case 5:\n          return world.hasChunk(i, j, k - 1);\n        // z-\n\n        case 6:\n          return world.hasChunk(i + 1, j + 1, k);\n\n        case 7:\n          return world.hasChunk(i - 1, j + 1, k);\n\n        case 8:\n          return world.hasChunk(i + 1, j - 1, k);\n\n        case 9:\n          return world.hasChunk(i - 1, j - 1, k);\n\n        case 10:\n          return world.hasChunk(i + 1, j, k - 1);\n\n        case 11:\n          return world.hasChunk(i + 1, j, k + 1);\n\n        case 12:\n          return world.hasChunk(i - 1, j, k - 1);\n\n        case 13:\n          return world.hasChunk(i - 1, j, k + 1);\n\n        case 14:\n          return world.hasChunk(i, j + 1, k + 1);\n\n        case 15:\n          return world.hasChunk(i, j - 1, k + 1);\n\n        case 16:\n          return world.hasChunk(i, j + 1, k - 1);\n\n        case 17:\n          return world.hasChunk(i, j - 1, k - 1);\n\n        default:\n      }\n    }\n  }, {\n    key: "preloadAllNeighbourChunks",\n    value: function preloadAllNeighbourChunks(chunk, world) {\n      var loadedChunks = world.allChunks;\n      var c = chunk;\n      var dims = c.dimensions;\n      var ci = c.chunkI;\n      var cj = c.chunkJ;\n      var ck = c.chunkK;\n      var neighbourIds = ["".concat(ci + 1, ",").concat(cj, ",").concat(ck), //  i+1,\tj,\t\tk\n      "".concat(ci, ",").concat(cj + 1, ",").concat(ck), //  i-1,\tj,\t\tk\n      "".concat(ci, ",").concat(cj, ",").concat(ck + 1), //  i,\t\tj+1,\tk\n      "".concat(ci - 1, ",").concat(cj, ",").concat(ck), //  i,\t\tj-1,\tk\n      "".concat(ci, ",").concat(cj - 1, ",").concat(ck), //  i,\t\tj,\t\tk+1\n      "".concat(ci, ",").concat(cj, ",").concat(ck - 1), //  i,\t\tj,\t\tk-1\n      "".concat(ci + 1, ",").concat(cj + 1, ",").concat(ck), //  i+1,\tj+1,\tk\n      "".concat(ci - 1, ",").concat(cj + 1, ",").concat(ck), //  i-1,\tj+1,\tk\n      "".concat(ci + 1, ",").concat(cj - 1, ",").concat(ck), //  i+1,\tj-1,\tk\n      "".concat(ci - 1, ",").concat(cj - 1, ",").concat(ck), //  i-1,\tj-1,\tk\n      "".concat(ci + 1, ",").concat(cj, ",").concat(ck - 1), //  i+1,\tj,\t\tk-1\n      "".concat(ci + 1, ",").concat(cj, ",").concat(ck + 1), //  i+1,\tj,\t\tk+1\n      "".concat(ci - 1, ",").concat(cj, ",").concat(ck - 1), //  i-1,\tj,\t\tk-1\n      "".concat(ci - 1, ",").concat(cj, ",").concat(ck + 1), //  i-1,\tj,\t\tk+1\n      "".concat(ci, ",").concat(cj + 1, ",").concat(ck + 1), //  i,\t\tj+1,\tk+1\n      "".concat(ci, ",").concat(cj - 1, ",").concat(ck + 1), //  i,\t\tj-1,\tk+1\n      "".concat(ci, ",").concat(cj + 1, ",").concat(ck - 1), //  i,\t\tj+1,\tk-1\n      "".concat(ci, ",").concat(cj - 1, ",").concat(ck - 1) //  i,\t\tj-1,\tk-1\n      ];\n      var neighborBlocksAllReady = true;\n\n      for (var i = 0, length = neighbourIds.length; i < length; ++i) {\n        var currentId = neighbourIds[i];\n        var loadedC = loadedChunks.get(currentId);\n\n        if (loadedC) {\n          if (!loadedC.blocksReady) neighborBlocksAllReady = false;\n          continue;\n        } // Don\'t compute faces\n\n\n        var neighbour = chunkgenerator.createChunk(dims[0], dims[1], dims[2], currentId, world);\n        world.addChunk(currentId, neighbour);\n        if (!neighbour.blocksReady) neighborBlocksAllReady = false;\n      }\n\n      if (neighborBlocksAllReady) {\n        chunk.neighborBlocksReady = true;\n      }\n\n      return neighborBlocksAllReady;\n    }\n  }, {\n    key: "addChunk",\n    value: function addChunk(dimX, dimY, dimZ, chunkId, world) {\n      // Do compute faces\n      var chunk = chunkgenerator.createChunk(dimX, dimY, dimZ, chunkId, world);\n      world.addChunk(chunkId, chunk); // ChunkBuilder.computeChunkFaces(chunk);\n\n      return chunk;\n    }\n  }, {\n    key: "loadNextChunk",\n    value: function loadNextChunk(player, startWid, startCid, worldModel, xModel, consistencyModel, serverLoadingRadius, forPlayer) {\n      var avatar = player.avatar;\n      var threshold = forPlayer ? avatar.chunkRenderDistance : serverLoadingRadius;\n      threshold = Math.min(threshold, serverLoadingRadius);\n      var connectivity = xModel.getConnectivity(startWid, startCid, worldModel, threshold, true, !forPlayer);\n      if (!connectivity) return;\n      var chunks = connectivity[1]; // !! Should be sorted from the nearest to the farthest.\n\n      if (!chunks) return;\n      var aid = avatar.entityId;\n\n      for (var id = 0, l = chunks.length; id < l; ++id) {\n        var current = chunks[id];\n        var wid = current[0];\n        var currentId = current[1];\n        var hasLoadedChunk = consistencyModel.hasChunk(aid, wid, currentId);\n\n        if (!hasLoadedChunk) {\n          var currentWorld = worldModel.getWorld(wid);\n          var currentChunks = currentWorld.allChunks;\n          var currentChunk = currentChunks.get(currentId);\n          var dx = currentWorld.xSize;\n          var dy = currentWorld.ySize;\n          var dz = currentWorld.zSize;\n\n          if (!currentChunk) {\n            currentChunk = ChunkBuilder.addChunk(dx, dy, dz, currentId, currentWorld);\n            currentChunks.set(currentId, currentChunk); // ChunkBuilder.computeChunkFaces(currentChunk);\n            // return currentChunk;\n\n            return null;\n          } else if (!currentChunk.blocksReady) {\n            return null; // Awaiting generation from generation engine.\n          } else if (!currentChunk.ready) {\n            ChunkBuilder.computeChunkFaces(currentChunk); // Beware! needs to have neighbour blocks ready as well.\n\n            return currentChunk.ready ? currentChunk : null;\n          } else {\n            return currentChunk;\n          }\n        }\n      }\n    }\n  }, {\n    key: "getOOBPlayerChunks",\n    value: function getOOBPlayerChunks(player, starterChunk, worldModel, xModel, consistencyModel, thresh) {\n      var avatar = player.avatar;\n      var unloadedChunksForPlayer = {};\n      var chunksToUnload = [];\n      var aid = avatar.entityId;\n      var startWid = avatar.worldId;\n      var chunkIdsForEntity = consistencyModel.chunkIdsPerWorldForEntity(aid);\n      var w = worldModel.getWorld(startWid);\n\n      if (!w) {\n        console.log(\'Could not get starting world from avatar.\');\n        return;\n      }\n\n      var c = w.getChunkByCoordinates.apply(w, builder_chunks_toConsumableArray(avatar.position));\n\n      if (!c) {\n        console.log(\'Could not get starting chunk from avatar.\');\n        return;\n      }\n\n      var startCid = c.chunkId;\n      var connectivity = xModel.getConnectivity(startWid, startCid, worldModel, thresh, true);\n      var okChunks = connectivity[1];\n      var marks = new Map();\n      okChunks.forEach(function (okCurrent) {\n        return marks.set("".concat(okCurrent[0], ",").concat(okCurrent[1]), okCurrent[2]);\n      });\n      chunkIdsForEntity.forEach(function (chunkIds, worldId) {\n        chunkIds.forEach(function (chunkId) {\n          var distance = marks.get("".concat(worldId, ",").concat(chunkId));\n          if (distance === undefined || distance === null || distance > thresh) chunksToUnload.push([worldId, chunkId]);\n        });\n      }); // Recurse on unloaded chunk ids.\n\n      for (var i = 0, l = chunksToUnload.length; i < l; ++i) {\n        var chunkToUnload = chunksToUnload[i];\n        var currentWorld = chunkToUnload[0];\n        var currentId = chunkToUnload[1];\n        if (!unloadedChunksForPlayer.hasOwnProperty(currentWorld)) unloadedChunksForPlayer[currentWorld] = {};\n        unloadedChunksForPlayer[currentWorld][currentId] = null;\n      }\n\n      return unloadedChunksForPlayer;\n    }\n  }]);\n\n  return ChunkBuilder;\n}();\n\nbuilder_chunks_defineProperty(builder_chunks_ChunkBuilder, "debug", false);\n\n/* harmony default export */ var builder_chunks = (builder_chunks_ChunkBuilder);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_topology/updater/updater_block.js\n/**\n *\n */\n\n\nfunction updater_block_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction updater_block_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction updater_block_createClass(Constructor, protoProps, staticProps) { if (protoProps) updater_block_defineProperties(Constructor.prototype, protoProps); if (staticProps) updater_block_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar updater_block_UpdaterBlock = /*#__PURE__*/function () {\n  function UpdaterBlock() {\n    updater_block_classCallCheck(this, UpdaterBlock);\n  }\n\n  updater_block_createClass(UpdaterBlock, null, [{\n    key: "removeSurfaceBlock",\n    value: function removeSurfaceBlock(surfaceBlocks, chunk, x, y, z) {\n      surfaceBlocks.splice(surfaceBlocks.indexOf(chunk._toId(x, y, z)));\n    }\n  }, {\n    key: "addSurfaceBlock",\n    value: function addSurfaceBlock(surfaceBlocks, chunk, x, y, z) {\n      var id = chunk._toId(x, y, z);\n\n      surfaceBlocks.push(id);\n    }\n  }, {\n    key: "processNeighbourSurfaceBlockAfterAddition",\n    value: function processNeighbourSurfaceBlockAfterAddition(chunk, airBlock, waterBlock, isAddedBlockWater, xs, ys, zs) {\n      var changed = false;\n      var neighbourBlock = chunk.queryBlock(xs[0], ys[0], zs[0]);\n\n      if (neighbourBlock !== airBlock && neighbourBlock === waterBlock === isAddedBlockWater // (N.B. eval from left to right)\n      ) {\n          changed = true;\n          var a = chunk.queryBlock(xs[1], ys[1], zs[1]);\n          var b = chunk.queryBlock(xs[2], ys[2], zs[2]);\n          var c = chunk.queryBlock(xs[3], ys[3], zs[3]);\n          var d = chunk.queryBlock(xs[4], ys[4], zs[4]);\n          var e = chunk.queryBlock(xs[5], ys[5], zs[5]);\n          var notSurface;\n\n          if (neighbourBlock === waterBlock) {\n            notSurface = a !== waterBlock || b !== waterBlock || c !== waterBlock || d !== waterBlock || e !== waterBlock;\n          } else {\n            notSurface = a === waterBlock || a === airBlock || b === waterBlock || b === waterBlock || c === waterBlock || c === airBlock || d === waterBlock || d === airBlock || e === waterBlock || e === airBlock;\n          }\n\n          if (notSurface) {\n            var ch = chunk.queryChunk(xs[0], ys[0], zs[0]);\n            UpdaterBlock.removeSurfaceBlock(ch[0].surfaceBlocks, ch[0], ch[1], ch[2], ch[3]);\n          }\n        }\n\n      return changed;\n    } // The difficulty is to keep layered surfaceBlocks sorted.\n\n  }, {\n    key: "updateSurfaceBlocksAfterAddition",\n    value: function updateSurfaceBlocksAfterAddition(chunk, id, x, y, z, blockId) {\n      if (!chunk.blocksReady || !chunk.neighborBlocksReady) return false;\n      var airBlock = BlockType.AIR;\n      var waterBlock = BlockType.WATER;\n      var isAddedBlockWater = blockId === waterBlock;\n      var surfaceBlocks = chunk.surfaceBlocks;\n      var xm;\n      var ym;\n      var zm;\n      var xp;\n      var yp;\n      var zp; // x+ and x-\n\n      xm = UpdaterBlock.processNeighbourSurfaceBlockAfterAddition(chunk, airBlock, waterBlock, isAddedBlockWater, [x - 1, x - 1, x - 1, x - 1, x - 1, x - 2], [y, y - 1, y + 1, y, y, y], [z, z, z, z - 1, z + 1, z]);\n      xp = UpdaterBlock.processNeighbourSurfaceBlockAfterAddition(chunk, airBlock, waterBlock, isAddedBlockWater, [x + 1, x + 1, x + 1, x + 1, x + 1, x + 2], [y, y - 1, y + 1, y, y, y], [z, z, z, z - 1, z + 1, z]); // Update (y+1, y-1) blocks.\n\n      ym = UpdaterBlock.processNeighbourSurfaceBlockAfterAddition(chunk, airBlock, waterBlock, isAddedBlockWater, [x, x - 1, x + 1, x, x, x], [y - 1, y - 1, y - 1, y - 1, y - 1, y - 2], [z, z, z, z - 1, z + 1, z]);\n      yp = UpdaterBlock.processNeighbourSurfaceBlockAfterAddition(chunk, airBlock, waterBlock, isAddedBlockWater, [x, x - 1, x + 1, x, x, x], [y + 1, y + 1, y + 1, y + 1, y + 1, y + 2], [z, z, z, z - 1, z + 1, z]); // Update (z-1, z+1) blocks.\n\n      zm = UpdaterBlock.processNeighbourSurfaceBlockAfterAddition(chunk, airBlock, waterBlock, isAddedBlockWater, [x, x - 1, x + 1, x, x, x], [y, y, y, y - 1, y + 1, y], [z - 1, z - 1, z - 1, z - 1, z - 1, z - 2]);\n      zp = UpdaterBlock.processNeighbourSurfaceBlockAfterAddition(chunk, airBlock, waterBlock, isAddedBlockWater, [x, x - 1, x + 1, x, x, x], [y, y, y, y - 1, y + 1, y], [z + 1, z + 1, z + 1, z + 1, z + 1, z + 2]); // Update current block.\n\n      if (!(xm && ym && xp && yp && zm && zp)) {\n        UpdaterBlock.addSurfaceBlock(surfaceBlocks, chunk, x, y, z);\n      }\n\n      return true;\n    } // BLOCK DELETION\n    // Simpler! A deletion is just adding an air block,\n    // so all neighbours become surface blocks.\n\n  }, {\n    key: "updateSurfaceBlocksAfterDeletion",\n    value: function updateSurfaceBlocksAfterDeletion(chunk, id, x, y, z) {\n      if (!chunk.blocksReady || !chunk.neighborBlocksReady) return false; // Get all neighbour chunks.\n\n      var neighbourChunks = []; // let neighbourBlocks = [];\n\n      var numberOfNeighbours = 6;\n\n      for (var i = 0; i < numberOfNeighbours; ++i) {\n        var tempChunk = builder_chunks.getNeighboringChunk(chunk, i);\n\n        if (tempChunk && tempChunk.blocksReady) {\n          neighbourChunks.push(tempChunk); // neighbourBlocks.push(tempChunk.blocks);\n        } else {\n          console.log(\'Error: could not get neighboring chunk at UpdaterBlocks.\');\n          return false;\n        }\n      }\n\n      var surfaceBlocks = chunk.surfaceBlocks;\n      var dimensions = chunk.dimensions;\n      var xp = false;\n      var xm = false;\n      var yp = false;\n      var ym = false;\n      var zp = false;\n      var zm = false; // Cant add a non-surface block.\n\n      if (x + 1 === dimensions[0]) UpdaterBlock.addSurfaceBlock(neighbourChunks[0].surfaceBlocks, neighbourChunks[0], 0, y, z);\n      if (x - 1 < 0) UpdaterBlock.addSurfaceBlock(neighbourChunks[1].surfaceBlocks, neighbourChunks[1], dimensions[0] - 1, y, z);\n      if (y + 1 === dimensions[1]) UpdaterBlock.addSurfaceBlock(neighbourChunks[2].surfaceBlocks, neighbourChunks[2], x, 0, z);\n      if (y - 1 < 0) UpdaterBlock.addSurfaceBlock(neighbourChunks[3].surfaceBlocks, neighbourChunks[3], x, dimensions[1] - 1, z);\n      if (z + 1 === dimensions[2]) UpdaterBlock.addSurfaceBlock(neighbourChunks[4].surfaceBlocks, neighbourChunks[4], x, y, 0);\n      if (z - 1 < 0) UpdaterBlock.addSurfaceBlock(neighbourChunks[5].surfaceBlocks, neighbourChunks[5], x, y, dimensions[2] - 1); // Update (x+1, x-1) blocks.\n\n      if (x > 0) {\n        if (chunk.contains(x - 1, y, z)) {\n          xm = true;\n          if ((y - 1 < 0 || chunk.contains(x - 1, y - 1, z)) && (y + 1 >= dimensions[1] || chunk.contains(x - 1, y + 1, z)) && (z - 1 < 0 || chunk.contains(x - 1, y, z - 1)) && (z + 1 >= dimensions[2] || chunk.contains(x - 1, y, z + 1)) && (x - 2 < 0 || chunk.contains(x - 2, y, z))) UpdaterBlock.addSurfaceBlock(surfaceBlocks, chunk, x - 1, y, z);\n        }\n      }\n\n      if (x + 1 < dimensions[0]) {\n        if (chunk.contains(x + 1, y, z)) {\n          xp = true;\n          if ((y - 1 < 0 || chunk.contains(x + 1, y - 1, z)) && (y + 1 >= dimensions[1] || chunk.contains(x + 1, y + 1, z)) && (z - 1 < 0 || chunk.contains(x + 1, y, z - 1)) && (z + 1 >= dimensions[2] || chunk.contains(x + 1, y, z + 1)) && (x + 2 >= dimensions[0] || chunk.contains(x + 2, y, z))) UpdaterBlock.addSurfaceBlock(surfaceBlocks, chunk, x + 1, y, z);\n        }\n      } // Update (y+1, y-1) blocks.\n\n\n      if (y > 0) {\n        if (chunk.contains(x, y - 1, z)) {\n          ym = true;\n          if ((x - 1 < 0 || chunk.contains(x - 1, y - 1, z)) && (x + 1 >= dimensions[0] || chunk.contains(x + 1, y - 1, z)) && (z - 1 < 0 || chunk.contains(x, y - 1, z - 1)) && (z + 1 >= dimensions[2] || chunk.contains(x, y - 1, z + 1)) && (y - 2 < 0 || chunk.contains(x, y - 2, z))) UpdaterBlock.addSurfaceBlock(surfaceBlocks, chunk, x, y - 1, z);\n        }\n      }\n\n      if (y + 1 < dimensions[1]) {\n        if (chunk.contains(x, y + 1, z)) {\n          yp = true;\n          if ((x - 1 < 0 || chunk.contains(x - 1, y + 1, z)) && (x + 1 >= dimensions[0] || chunk.contains(x + 1, y + 1, z)) && (z - 1 < 0 || chunk.contains(x, y + 1, z - 1)) && (z + 1 >= dimensions[2] || chunk.contains(x, y + 1, z + 1)) && (y + 2 >= dimensions[1] || chunk.contains(x, y + 2, z))) UpdaterBlock.addSurfaceBlock(surfaceBlocks, chunk, x, y + 1, z);\n        }\n      } // Update (z-1, z+1) blocks.\n\n\n      if (z > 0) {\n        if (chunk.contains(x, y, z - 1)) {\n          zm = true;\n          if ((x - 1 < 0 || chunk.contains(x - 1, y, z - 1)) && (x + 1 >= dimensions[0] || chunk.contains(x + 1, y, z - 1)) && (y - 1 < 0 || chunk.contains(x, y - 1, z - 1)) && (y + 1 >= dimensions[1] || chunk.contains(x, y + 1, z - 1)) && (z - 2 < 0 || chunk.contains(x, y, z - 2))) UpdaterBlock.addSurfaceBlock(surfaceBlocks, chunk, x, y, z - 1);\n        }\n      }\n\n      if (z + 1 < dimensions[2]) {\n        if (chunk.contains(x, y, z + 1)) {\n          zp = true;\n          if ((x - 1 < 0 || chunk.contains(x - 1, y, z + 1)) && (x + 1 >= dimensions[0] || chunk.contains(x + 1, y, z + 1)) && (y - 1 < 0 || chunk.contains(x, y - 1, z + 1)) && (y + 1 >= dimensions[1] || chunk.contains(x, y + 1, z + 1)) && (z + 2 >= dimensions[2] || chunk.contains(x, y, z + 2))) UpdaterBlock.addSurfaceBlock(surfaceBlocks, chunk, x, y, z + 1);\n        }\n      } // Update current block.\n\n\n      if (!(xm && ym && xp && yp && zm && zp)) // Was the current block a surface block?\n        {\n          UpdaterBlock.removeSurfaceBlock(surfaceBlocks, chunk, x, y, z);\n        }\n\n      return true;\n    }\n  }]);\n\n  return UpdaterBlock;\n}();\n\n/* harmony default export */ var updater_block = (updater_block_UpdaterBlock);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_topology/updater/updater_face.js\n/**\n *\n */\n\n\nfunction updater_face_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction updater_face_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction updater_face_createClass(Constructor, protoProps, staticProps) { if (protoProps) updater_face_defineProperties(Constructor.prototype, protoProps); if (staticProps) updater_face_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n // Get linkage strategy.\n\nvar updater_face_UpdaterFace = /*#__PURE__*/function () {\n  function UpdaterFace() {\n    updater_face_classCallCheck(this, UpdaterFace);\n  }\n\n  updater_face_createClass(UpdaterFace, null, [{\n    key: "detectProbableTopologyChangeAfterAddition",\n\n    /**\n     * @deprecated\n     */\n    value: function detectProbableTopologyChangeAfterAddition(chunk, id, x, y, z, faces) {\n      // Criterion: at least 2 surface faces that do not link on the inserted cube.\n      // i.e. if blocking edges form a cycle.\n      // Detects POTENTIAL local topology changes.\n      // Compute blocking edges.\n      var blockingEdges = []; // x-\n\n      if (faces[0] && faces[2] && chunk.contains(x - 1, y - 1, z)) blockingEdges.push([0, 4]);\n      if (faces[0] && faces[3] && chunk.contains(x - 1, y + 1, z)) blockingEdges.push([3, 7]);\n      if (faces[0] && faces[4] && chunk.contains(x - 1, y, z - 1)) blockingEdges.push([4, 7]);\n      if (faces[0] && faces[5] && chunk.contains(x - 1, y, z + 1)) blockingEdges.push([0, 3]); // x+\n\n      if (faces[1] && faces[2] && chunk.contains(x + 1, y - 1, z)) blockingEdges.push([1, 5]);\n      if (faces[1] && faces[3] && chunk.contains(x + 1, y + 1, z)) blockingEdges.push([2, 6]);\n      if (faces[1] && faces[4] && chunk.contains(x + 1, y, z - 1)) blockingEdges.push([5, 6]);\n      if (faces[1] && faces[5] && chunk.contains(x + 1, y, z + 1)) blockingEdges.push([1, 2]); // y+-z\n\n      if (faces[2] && faces[4] && chunk.contains(x, y - 1, z - 1)) blockingEdges.push([4, 5]);\n      if (faces[2] && faces[5] && chunk.contains(x, y - 1, z + 1)) blockingEdges.push([0, 1]);\n      if (faces[3] && faces[4] && chunk.contains(x, y + 1, z - 1)) blockingEdges.push([6, 7]);\n      if (faces[3] && faces[5] && chunk.contains(x, y + 1, z + 1)) blockingEdges.push([2, 3]); // Detect loop.\n\n      var ls = [];\n\n      for (var i = 0; i < blockingEdges.length; ++i) {\n        var bi = blockingEdges[i];\n        var found = false;\n\n        for (var j = 0; j < ls.length; ++j) {\n          var last = ls[j].length - 1;\n\n          if (ls[j][last] === bi[0]) {\n            ls[j].push(bi[1]);\n            found = true;\n          }\n\n          if (ls[j][last] === bi[1]) {\n            ls[j].push(bi[0]);\n            found = true;\n          }\n\n          if (ls[j][0] === ls[j][last + 1]) {\n            // Loop detected.\n            if (ls[j].length < 4) console.log(\'invalid detectProbableTopologyChangeAfterAddition algorithm\');\n            return true;\n          }\n        }\n\n        if (!found) {\n          ls.push([bi[0], bi[1]]);\n        }\n      } // No topology change by default.\n\n\n      return false;\n    }\n  }, {\n    key: "addFaceToChunk",\n    value: function addFaceToChunk(chunk, x, y, z, direction, faceNature, fromAddition) {\n      if (faceNature === BlockType.AIR) {\n        console.error(\'[UpdaterFace] Cant add air face.\');\n      }\n\n      var blockStride = chunk._toIdUnsafe(x, y, z);\n\n      var dimensions = chunk.dimensions;\n      var faceId = UpdaterFace.getFaceIdFromCoordinatesAndNormal(blockStride, direction, dimensions);\n      var connectedComponents = chunk.connectedComponents;\n      var fastComponents = chunk.fastComponents;\n      var fastComponentsIds = chunk.fastComponentsIds;\n      var componentId = faceNature === BlockType.WATER ? 2 : 1; // water\n\n      if (fromAddition) {\n        if (direction % 2 === 0) faceNature *= -1;\n      } else if (!fromAddition) {\n        if (direction % 2 !== 0) faceNature *= -1;\n      }\n\n      connectedComponents[faceId] = componentId;\n\n      if (!fastComponents[componentId]) {\n        // console.error(`BLD: invalid component id: ${componentId} for insertion.`);\n        // console.log(fastComponents);\n        // console.log(fastComponentsIds);\n        // console.log(connectedComponents);\n        // Create new components.\n        fastComponents[componentId] = [faceId];\n        fastComponentsIds[componentId] = [faceNature];\n      } else {\n        var location = collections.insert(faceId, fastComponents[componentId]);\n        var fastIds = fastComponentsIds[componentId];\n        fastIds.splice(location, 0, faceNature);\n      } // Apply update.\n\n\n      var updates = chunk.updates;\n      var removedUpdt = updates[0];\n      var addedUpdt = updates[1];\n      var changedUpdt = updates[2];\n      var nbp = collections.numberOfProperties;\n      var updatesEmpty = nbp(removedUpdt) === 0 && nbp(addedUpdt) === 0 && nbp(changedUpdt) === 0;\n\n      if (!updatesEmpty && removedUpdt.hasOwnProperty(faceId)) {\n        delete removedUpdt[faceId]; // if it is marked as \'removed\', then it exists in the original array\n\n        changedUpdt[faceId] = faceNature; //connectedComponents[fid];\n      } else {\n        addedUpdt[faceId] = faceNature; // connectedComponents[fid];\n      }\n    }\n  }, {\n    key: "removeFaceFromChunk",\n    value: function removeFaceFromChunk(chunk, x, y, z, direction) {\n      var blockStride = chunk._toIdUnsafe(x, y, z);\n\n      var dimensions = chunk.dimensions;\n      var faceId = UpdaterFace.getFaceIdFromCoordinatesAndNormal(blockStride, direction, dimensions);\n      var connectedComponents = chunk.connectedComponents;\n      var fastComponents = chunk.fastComponents;\n      var fastComponentsIds = chunk.fastComponentsIds;\n      var componentId = connectedComponents[faceId];\n\n      if (!componentId) {\n        console.error("[UpdaterFace] Face id ".concat(faceId, " not in connected components."));\n        console.log(componentId);\n      }\n\n      if (componentId < 1) {\n        console.warn("WARN: trying to remove a face that is not\\n                    registered as boundary: component id = ".concat(faceId, ".\\n                "));\n        return;\n      }\n\n      var currentComponent = fastComponents[componentId];\n\n      if (!currentComponent) {\n        var e = new Error("BLD: skipping removal on component ".concat(componentId));\n        console.error("BLD: skipping removal on component ".concat(componentId));\n        console.log(e.stack);\n        return;\n      }\n\n      var index = collections.removeFromArray(currentComponent, faceId);\n      if (currentComponent.length === 0) delete fastComponents[componentId];\n      var currentComponentsIds = fastComponentsIds[componentId];\n      collections.removeFromArrayWithId(currentComponentsIds, index);\n      if (currentComponentsIds.length === 0) delete fastComponentsIds[componentId];\n      connectedComponents[faceId] = 0; // Push update.\n\n      var updates = chunk.updates;\n      var removedUpdt = updates[0];\n      var addedUpdt = updates[1];\n      var changedUpdt = updates[2];\n      var nbp = collections.numberOfProperties;\n      var updatesEmpty = nbp(removedUpdt) === 0 && nbp(addedUpdt) === 0 && nbp(changedUpdt) === 0;\n\n      if (!updatesEmpty && addedUpdt.hasOwnProperty(faceId)) {\n        delete addedUpdt[faceId]; // if it is marked as \'added\', then it does not exist in the original array\n      } else {\n        removedUpdt[faceId] = null;\n      }\n    }\n  }, {\n    key: "updateOneFaceFromAddition",\n    value: function updateOneFaceFromAddition(chunk, otherUpdatedChunks, airBlock, waterBlock, isAddedBlockWater, blockId, otherBlockId, x, y, z, xTest, yTest, zTest, condition, direction) {\n      var current;\n\n      if (condition) {\n        current = chunk.queryChunk(xTest, yTest, zTest);\n        if (x !== xTest) current[1] += 1;\n        if (y !== yTest) current[2] += 1;\n        if (z !== zTest) current[3] += 1;\n        otherUpdatedChunks.push(current[0]);\n      } else {\n        current = [chunk, x, y, z];\n      }\n\n      if (otherBlockId === airBlock) {\n        // add face to this.\n        UpdaterFace.addFaceToChunk(current[0], current[1], current[2], current[3], direction, blockId, true);\n      } else if (otherBlockId === waterBlock && !isAddedBlockWater) {\n        // delete other block face and add face to this.\n        UpdaterFace.removeFaceFromChunk(current[0], current[1], current[2], current[3], direction);\n        UpdaterFace.addFaceToChunk(current[0], current[1], current[2], current[3], direction, blockId, true);\n      } else if (otherBlockId === waterBlock && isAddedBlockWater || otherBlockId !== airBlock && otherBlockId !== waterBlock && !isAddedBlockWater) {\n        // delete other block face.\n        UpdaterFace.removeFaceFromChunk(current[0], current[1], current[2], current[3], direction);\n      }\n    }\n  }, {\n    key: "updateSurfaceFacesAfterAddition2",\n    value: function updateSurfaceFacesAfterAddition2(chunk, id, x, y, z, blockId) {\n      if (!chunk.ready) {\n        console.warn(\'[UpdaterFaces] Addition: chunk faces not ready.\');\n        return false;\n      }\n\n      var otherUpdatedChunks = [];\n      var airBlock = BlockType.AIR;\n      var waterBlock = BlockType.WATER;\n      var isAddedBlockWater = blockId === waterBlock;\n      var a = chunk.queryBlock(x - 1, y, z);\n\n      if (a < 0) {\n        console.warn(\'[UpdaterFaces] Addition: neighbor chunk faces not ready.\');\n        return false;\n      }\n\n      var b = chunk.queryBlock(x + 1, y, z);\n\n      if (b < 0) {\n        console.warn(\'[UpdaterFaces] Addition: neighbor chunk faces not ready.\');\n        return false;\n      }\n\n      var c = chunk.queryBlock(x, y - 1, z);\n\n      if (c < 0) {\n        console.warn(\'[UpdaterFaces] Addition: neighbor chunk faces not ready.\');\n        return false;\n      }\n\n      var d = chunk.queryBlock(x, y + 1, z);\n\n      if (d < 0) {\n        console.warn(\'[UpdaterFaces] Addition: neighbor chunk faces not ready.\');\n        return false;\n      }\n\n      var e = chunk.queryBlock(x, y, z - 1);\n\n      if (e < 0) {\n        console.warn(\'[UpdaterFaces] Addition: neighbor chunk faces not ready.\');\n        return false;\n      }\n\n      var f = chunk.queryBlock(x, y, z + 1);\n\n      if (f < 0) {\n        console.warn(\'[UpdaterFaces] Addition: neighbor chunk faces not ready.\');\n        return false;\n      }\n\n      UpdaterFace.updateOneFaceFromAddition(chunk, otherUpdatedChunks, airBlock, waterBlock, isAddedBlockWater, blockId, a, x, y, z, x - 1, y, z, x === 0, 0);\n      UpdaterFace.updateOneFaceFromAddition(chunk, otherUpdatedChunks, airBlock, waterBlock, isAddedBlockWater, blockId, b, x, y, z, x + 1, y, z, false, 1);\n      UpdaterFace.updateOneFaceFromAddition(chunk, otherUpdatedChunks, airBlock, waterBlock, isAddedBlockWater, blockId, c, x, y, z, x, y - 1, z, y === 0, 2);\n      UpdaterFace.updateOneFaceFromAddition(chunk, otherUpdatedChunks, airBlock, waterBlock, isAddedBlockWater, blockId, d, x, y, z, x, y + 1, z, false, 3);\n      UpdaterFace.updateOneFaceFromAddition(chunk, otherUpdatedChunks, airBlock, waterBlock, isAddedBlockWater, blockId, e, x, y, z, x, y, z - 1, z === 0, 4);\n      UpdaterFace.updateOneFaceFromAddition(chunk, otherUpdatedChunks, airBlock, waterBlock, isAddedBlockWater, blockId, f, x, y, z, x, y, z + 1, false, 5);\n      return otherUpdatedChunks;\n    }\n  }, {\n    key: "updateOneFaceFromDeletion",\n    value: function updateOneFaceFromDeletion(chunk, otherUpdatedChunks, airBlock, waterBlock, isRemovedBlockWater, otherBlockId, x, y, z, xTest, yTest, zTest, condition, direction) {\n      // Removed\n      var current;\n\n      if (condition) {\n        current = chunk.queryChunk(xTest, yTest, zTest);\n        if (x !== xTest) current[1] += 1;\n        if (y !== yTest) current[2] += 1;\n        if (z !== zTest) current[3] += 1;\n        otherUpdatedChunks.push(current[0]);\n      } else {\n        current = [chunk, x, y, z];\n      }\n\n      if (otherBlockId === airBlock) {\n        // delete this face.\n        UpdaterFace.removeFaceFromChunk(current[0], current[1], current[2], current[3], direction);\n      } else if (otherBlockId === waterBlock && !isRemovedBlockWater) {\n        // delete this face and add other block face water.\n        UpdaterFace.removeFaceFromChunk(current[0], current[1], current[2], current[3], direction);\n        UpdaterFace.addFaceToChunk(current[0], current[1], current[2], current[3], direction, otherBlockId, false);\n      } else if (otherBlockId === waterBlock && isRemovedBlockWater || otherBlockId !== airBlock && otherBlockId !== waterBlock && !isRemovedBlockWater) {\n        // add other block face.\n        UpdaterFace.addFaceToChunk(current[0], current[1], current[2], current[3], direction, otherBlockId, false);\n      }\n    }\n  }, {\n    key: "updateSurfaceFacesAfterDeletion2",\n    value: function updateSurfaceFacesAfterDeletion2(chunk, id, x, y, z, blockId) {\n      if (!chunk.ready) {\n        console.warn(\'[UpdaterFaces] Deletion: chunk faces not ready.\');\n        return false;\n      }\n\n      var otherUpdatedChunks = [];\n      var airBlock = BlockType.AIR;\n      var waterBlock = BlockType.WATER; // let blockId = chunk.queryBlock(x, y, z);\n\n      var isRemovedBlockWater = blockId === waterBlock;\n      var a = chunk.queryBlock(x - 1, y, z);\n\n      if (a < 0) {\n        console.warn(\'[UpdaterFaces] Deletion: neighbor faces not ready.\');\n        return false;\n      }\n\n      var b = chunk.queryBlock(x + 1, y, z);\n\n      if (b < 0) {\n        console.warn(\'[UpdaterFaces] Deletion: neighbor faces not ready.\');\n        return false;\n      }\n\n      var c = chunk.queryBlock(x, y - 1, z);\n\n      if (c < 0) {\n        console.warn(\'[UpdaterFaces] Deletion: neighbor faces not ready.\');\n        return false;\n      }\n\n      var d = chunk.queryBlock(x, y + 1, z);\n\n      if (d < 0) {\n        console.warn(\'[UpdaterFaces] Deletion: neighbor faces not ready.\');\n        return false;\n      }\n\n      var e = chunk.queryBlock(x, y, z - 1);\n\n      if (e < 0) {\n        console.warn(\'[UpdaterFaces] Deletion: neighbor faces not ready.\');\n        return false;\n      }\n\n      var f = chunk.queryBlock(x, y, z + 1);\n\n      if (f < 0) {\n        console.warn(\'[UpdaterFaces] Deletion: neighbor faces not ready.\');\n        return false;\n      }\n\n      UpdaterFace.updateOneFaceFromDeletion(chunk, otherUpdatedChunks, airBlock, waterBlock, isRemovedBlockWater, a, x, y, z, x - 1, y, z, x === 0, 0);\n      UpdaterFace.updateOneFaceFromDeletion(chunk, otherUpdatedChunks, airBlock, waterBlock, isRemovedBlockWater, b, x, y, z, x + 1, y, z, false, 1);\n      UpdaterFace.updateOneFaceFromDeletion(chunk, otherUpdatedChunks, airBlock, waterBlock, isRemovedBlockWater, c, x, y, z, x, y - 1, z, y === 0, 2);\n      UpdaterFace.updateOneFaceFromDeletion(chunk, otherUpdatedChunks, airBlock, waterBlock, isRemovedBlockWater, d, x, y, z, x, y + 1, z, false, 3);\n      UpdaterFace.updateOneFaceFromDeletion(chunk, otherUpdatedChunks, airBlock, waterBlock, isRemovedBlockWater, e, x, y, z, x, y, z - 1, z === 0, 4);\n      UpdaterFace.updateOneFaceFromDeletion(chunk, otherUpdatedChunks, airBlock, waterBlock, isRemovedBlockWater, f, x, y, z, x, y, z + 1, false, 5);\n      return otherUpdatedChunks;\n    }\n    /**\n     * Gets the id of a face taken from a block.\n     * @param id block id\n     * @param normal which of the 6 faces (+/- x/y/z)\n     * 0 -> x-, 1 -> x+, 2 -> y-, 3 -> y+, 4 -> z-, 5 -> z+.\n     * @param dimensions chunk size\n     */\n\n  }, {\n    key: "getFaceIdFromCoordinatesAndNormal",\n    value: function getFaceIdFromCoordinatesAndNormal(id, normal, dimensions) {\n      var ddd = dimensions[0] * dimensions[1] * dimensions[2];\n\n      switch (normal) {\n        case 0:\n          // x-\n          return id - 1;\n\n        case 2:\n          // y-\n          return ddd + id - dimensions[0];\n\n        case 4:\n          // z-\n          return 2 * ddd + id - dimensions[0] * dimensions[1];\n\n        case 1:\n          // x+\n          return id;\n\n        case 3:\n          // y+\n          return ddd + id;\n\n        case 5:\n          // z+\n          return 2 * ddd + id;\n\n        default:\n      }\n    }\n  }, {\n    key: "addFaceToModel",\n    value: function addFaceToModel(chunk, faceId, kind) {\n      var connectedComponents = chunk.connectedComponents;\n      var fastComponents = chunk.fastComponents;\n      var fastComponentsIds = chunk.fastComponentsIds;\n      var cc = 1; // not topology-aware\n\n      connectedComponents[faceId] = cc;\n\n      if (fastComponents.hasOwnProperty(cc)) {\n        fastComponents[cc].push(faceId);\n        fastComponentsIds[cc].push(kind);\n      } else {\n        console.log("ERROR @addFaceToModel: fastComponents doesnt have a ".concat(cc, " component. ") + "face id: ".concat(faceId, " kind: ").concat(kind));\n        fastComponents[cc] = [faceId];\n        fastComponentsIds[cc] = [kind];\n      }\n    }\n  }, {\n    key: "removeFaceFromModel",\n    value: function removeFaceFromModel(chunk, faceId) {\n      var connectedComponents = chunk.connectedComponents;\n      var fastComponents = chunk.fastComponents;\n      var fastComponentsIds = chunk.fastComponentsIds;\n      var cc = connectedComponents[faceId];\n      var id = collections.removeFromArray(fastComponents[cc], faceId);\n      collections.removeFromArrayWithId(fastComponentsIds[cc], id);\n      connectedComponents[faceId] = 0;\n    }\n  }]);\n\n  return UpdaterFace;\n}();\n\n/* harmony default export */ var updater_face = (updater_face_UpdaterFace);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_topology/updater/updater.js\n/**\n * Transform and operate chunks.\n */\n\n\nfunction updater_slicedToArray(arr, i) { return updater_arrayWithHoles(arr) || updater_iterableToArrayLimit(arr, i) || updater_unsupportedIterableToArray(arr, i) || updater_nonIterableRest(); }\n\nfunction updater_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction updater_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return updater_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return updater_arrayLikeToArray(o, minLen); }\n\nfunction updater_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction updater_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction updater_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction updater_updater_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction updater_updater_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction updater_updater_createClass(Constructor, protoProps, staticProps) { if (protoProps) updater_updater_defineProperties(Constructor.prototype, protoProps); if (staticProps) updater_updater_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar updater_updater_Updater = /*#__PURE__*/function () {\n  function Updater(topologyEngine) {\n    updater_updater_classCallCheck(this, Updater);\n\n    // Models.\n    this._worldModel = topologyEngine.worldModel;\n    this._entityModel = topologyEngine.entityModel;\n    this._outputBuffer = topologyEngine.outputBuffer;\n  }\n\n  updater_updater_createClass(Updater, [{\n    key: "update",\n    value: function update(inputBuffer) {\n      var _this = this;\n\n      inputBuffer.forEach(function (input) {\n        var data = input[0];\n        var avatar = input[1];\n        var worldId = avatar.worldId;\n        if (!worldId) return; // Avatar was disconnected between input & update.\n\n        var meta = data.meta;\n        var action = meta[0]; // Manage block addition.\n\n        if (action === \'add\') {\n          var blockId = meta[4];\n\n          if (_this.isValidBlock(blockId)) {\n            var x = parseInt(meta[1], 10);\n            var y = parseInt(meta[2], 10);\n            var z = parseInt(meta[3], 10);\n            var bid = parseInt(blockId, 10);\n\n            _this.addBlock(avatar, x, y, z, bid);\n          }\n        } else if (action === \'del\') {\n          var _x = parseInt(meta[1], 10);\n\n          var _y = parseInt(meta[2], 10);\n\n          var _z = parseInt(meta[3], 10);\n\n          _this.delBlock(avatar, _x, _y, _z);\n        }\n      });\n    }\n  }, {\n    key: "isValidBlock",\n    value: function isValidBlock(blockId) {\n      var isBlock = typeof blockId === \'number\' && BlockTypes.isBlock(blockId);\n\n      if (!isBlock) {\n        console.warn(\'[TopoEngine/Updater] Block not managed. \' + \'See BlockTypes and ItemType.\');\n      }\n\n      return isBlock;\n    }\n  }, {\n    key: "addBlock",\n    value: function addBlock(avatar, x, y, z, blockId) {\n      var worldId = avatar.worldId;\n\n      var world = this._worldModel.getWorld(worldId);\n\n      var o = this._outputBuffer;\n      var em = this._entityModel;\n      var a = updater_access.requestAddBlock(avatar, x, y, z, world, em);\n      if (!a) return;\n      var $chunk;\n      var $x;\n      var $y;\n      var $z;\n\n      var _a = updater_slicedToArray(a, 4);\n\n      $chunk = _a[0];\n      $x = _a[1];\n      $y = _a[2];\n      $z = _a[3];\n      var $id = $chunk.add($x, $y, $z, blockId);\n      var status = updater_block.updateSurfaceBlocksAfterAddition($chunk, $id, $x, $y, $z, blockId);\n\n      if (!status) {\n        console.warn(\'[Updater] Addition: blocks not ready.\');\n        return;\n      }\n\n      var updatedChunks = updater_face.updateSurfaceFacesAfterAddition2($chunk, $id, $x, $y, $z, blockId);\n\n      if (!updatedChunks) {\n        return;\n      } // Push updates.\n\n\n      updatedChunks.forEach(function (c) {\n        return o.chunkUpdated(worldId, c.chunkId);\n      });\n      o.chunkUpdated(worldId, $chunk.chunkId);\n    }\n  }, {\n    key: "delBlock",\n    value: function delBlock(avatar, x, y, z) {\n      var worldId = avatar.worldId;\n\n      var world = this._worldModel.getWorld(worldId);\n\n      var o = this._outputBuffer;\n      var em = this._entityModel;\n      var a = updater_access.requestDelBlock(avatar, x, y, z, world, em);\n      if (!a) return;\n      var $chunk;\n      var $x;\n      var $y;\n      var $z;\n\n      var _a2 = updater_slicedToArray(a, 4);\n\n      $chunk = _a2[0];\n      $x = _a2[1];\n      $y = _a2[2];\n      $z = _a2[3];\n      var oldBlock = $chunk.what($x, $y, $z);\n      var $id = $chunk.del($x, $y, $z);\n      var status = updater_block.updateSurfaceBlocksAfterDeletion($chunk, $id, $x, $y, $z);\n\n      if (!status) {\n        console.warn(\'[Updater] Deletion: blocks not ready.\');\n        return;\n      }\n\n      var updatedChunks = updater_face.updateSurfaceFacesAfterDeletion2($chunk, $id, $x, $y, $z, oldBlock);\n\n      if (!updatedChunks) {\n        return;\n      } // Push updates.\n\n\n      updatedChunks.forEach(function (c) {\n        return o.chunkUpdated(worldId, c.chunkId);\n      });\n      o.chunkUpdated(worldId, $chunk.chunkId);\n    }\n  }]);\n\n  return Updater;\n}();\n\n/* harmony default export */ var updater_updater = (updater_updater_Updater);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_topology/topology.js\n/**\n *\n */\n\n\nfunction topology_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction topology_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction topology_createClass(Constructor, protoProps, staticProps) { if (protoProps) topology_defineProperties(Constructor.prototype, protoProps); if (staticProps) topology_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar topology_TopologyEngine = /*#__PURE__*/function () {\n  function TopologyEngine(game) {\n    topology_classCallCheck(this, TopologyEngine);\n\n    // Models.\n    this._entityModel = game.entityModel;\n    this._worldModel = game.worldModel;\n    this._xModel = game.xModel;\n    this._consistencyModel = game.consistencyModel; // Buffers.\n\n    this._inputBuffer = new engine_topology_input_buffer();\n    this._outputBuffer = new engine_topology_output_buffer(); // Engine.\n\n    this._selector = new selector(this); // Extracts subsets for players.\n\n    this._updater = new updater_updater(this); // Updates model. Needs Accessor.\n  }\n\n  topology_createClass(TopologyEngine, [{\n    key: "addInput",\n    value: function addInput(meta, avatar) {\n      // Security: copy avatar state before physics engine updates positions and world translations.\n      var pos = avatar.position;\n      var secureAvatar = {\n        position: [pos[0], pos[1], pos[2]],\n        worldId: avatar.worldId\n      };\n\n      this._inputBuffer.addInput(meta, secureAvatar);\n    }\n  }, {\n    key: "update",\n    value: function update() {\n      this._updater.update(this._inputBuffer.getInput());\n\n      this._inputBuffer.flush();\n    } // Get (chunk id, blocks) map for updated chunks.\n\n  }, {\n    key: "getOutput",\n    value: function getOutput() {\n      return this._outputBuffer.getOutput();\n    } // Get (chunk id, updates) object for updated chunks concerning specific player.\n\n  }, {\n    key: "getOutputForPlayer",\n    value: function getOutputForPlayer(p, updatedChunks, newChunks) {\n      var worldModel = this._worldModel;\n      var consistencyModel = this._consistencyModel;\n      return this._selector.selectUpdatedChunksForPlayer(p, worldModel, consistencyModel, updatedChunks, newChunks);\n    }\n  }, {\n    key: "flushOutput",\n    value: function flushOutput() {\n      this._outputBuffer.flushOutput(this._worldModel);\n    }\n  }, {\n    key: "entityModel",\n    get: function get() {\n      return this._entityModel;\n    }\n  }, {\n    key: "worldModel",\n    get: function get() {\n      return this._worldModel;\n    }\n  }, {\n    key: "outputBuffer",\n    get: function get() {\n      return this._outputBuffer;\n    }\n  }]);\n\n  return TopologyEngine;\n}();\n\n/* harmony default export */ var topology = (topology_TopologyEngine);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/buffer_chunk.js\n/**\n *\n */\n\n\nfunction buffer_chunk_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction buffer_chunk_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction buffer_chunk_createClass(Constructor, protoProps, staticProps) { if (protoProps) buffer_chunk_defineProperties(Constructor.prototype, protoProps); if (staticProps) buffer_chunk_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar ChunkBuffer = /*#__PURE__*/function () {\n  function ChunkBuffer() {\n    buffer_chunk_classCallCheck(this, ChunkBuffer);\n\n    this._outputBuffer = new Map();\n  } // addedChunks:     world id => chunk id => [fast components, fast component ids]\n  //     on the first: world metadata (type, radius, center.xyz)\n  // removedChunks:   world id => chunk id => null\n  // updatedChunks:   (topologyEngine)\n\n\n  buffer_chunk_createClass(ChunkBuffer, [{\n    key: "updateChunksForPlayer",\n    value: function updateChunksForPlayer(playerId, addedChunks, removedChunks, addedWorlds, addedWorldsMeta) {\n      // Check.\n      if (!(addedChunks && Object.keys(addedChunks).length > 0) && !(removedChunks && Object.keys(removedChunks).length > 0)) return; // Aggregate.\n\n      if (addedChunks && Object.keys(addedChunks).length > 0 && removedChunks && Object.keys(removedChunks).length > 0) {\n        for (var propA in addedChunks) {\n          if (propA in removedChunks) {\n            Object.assign(addedChunks[propA], removedChunks[propA]); // Not the same cid to add & delete.\n\n            delete removedChunks[propA];\n          }\n        } // After deleting everything in common with removedChunks, can safely assign the remainder.\n\n\n        Object.assign(addedChunks, removedChunks);\n      } else if (removedChunks && Object.keys(removedChunks).length > 0) addedChunks = removedChunks;\n\n      if (addedWorlds) addedChunks.worlds = addedWorlds;\n      if (addedWorldsMeta) addedChunks.worldsMeta = addedWorldsMeta; // Output.\n\n      this._outputBuffer.set(playerId, addedChunks);\n    } // Shallow.\n\n  }, {\n    key: "getOutput",\n    value: function getOutput() {\n      // XXX [PERF] remove copy\n      return new Map(this._outputBuffer);\n    }\n  }, {\n    key: "flush",\n    value: function flush() {\n      this._outputBuffer = new Map();\n    }\n  }]);\n\n  return ChunkBuffer;\n}();\n\n/* harmony default export */ var buffer_chunk = (ChunkBuffer);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/buffer_entity.js\n/**\n *\n */\n\n\nfunction buffer_entity_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction buffer_entity_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction buffer_entity_createClass(Constructor, protoProps, staticProps) { if (protoProps) buffer_entity_defineProperties(Constructor.prototype, protoProps); if (staticProps) buffer_entity_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar EntityBuffer = /*#__PURE__*/function () {\n  function EntityBuffer() {\n    buffer_entity_classCallCheck(this, EntityBuffer);\n\n    this._addedPlayers = new Set();\n    this._removedPlayers = new Set();\n    this._outputBuffer = new Map();\n  }\n\n  buffer_entity_createClass(EntityBuffer, [{\n    key: "spawnEntity",\n    value: function spawnEntity(entity) {\n      var removedPlayers = this._removedPlayers;\n      var id = entity.entityId;\n      if (removedPlayers.has(id)) removedPlayers["delete"](id);else this._addedPlayers.add(id);\n    }\n  }, {\n    key: "removeEntity",\n    value: function removeEntity(entityId) {\n      var addedPlayers = this._addedPlayers;\n      if (addedPlayers.has(entityId)) addedPlayers["delete"](entityId);else this._removedPlayers.add(entityId);\n    }\n  }, {\n    key: "spawnPlayer",\n    value: function spawnPlayer(player) {\n      var removedPlayers = this._removedPlayers;\n      var id = player.avatar.entityId;\n      if (removedPlayers.has(id)) removedPlayers["delete"](id);else this._addedPlayers.add(id);\n    }\n  }, {\n    key: "removePlayer",\n    value: function removePlayer(playerId) {\n      var addedPlayers = this._addedPlayers;\n      if (addedPlayers.has(playerId)) addedPlayers["delete"](playerId);else this._removedPlayers.add(playerId);\n    } // addedEntities:   entity id => {p:e.position, r:e.rotation, k:e.kind}\n    // removedEntities: entity id => null\n\n  }, {\n    key: "updateEntitiesForPlayer",\n    value: function updateEntitiesForPlayer(playerId, addedEntities, removedEntities) {\n      // Check.\n      if (!(addedEntities && Object.keys(addedEntities).length > 0) && !(removedEntities && Object.keys(removedEntities).length > 0)) return;\n      if (addedEntities && Object.keys(addedEntities).length > 0 && removedEntities && Object.keys(removedEntities).length > 0) Object.assign(addedEntities, removedEntities); // Aggregate.\n      else if (removedEntities && Object.keys(removedEntities).length > 0) addedEntities = removedEntities; // Output.\n\n      var o = this._outputBuffer.get(playerId);\n\n      if (!o) this._outputBuffer.set(playerId, addedEntities);else {\n        // Bundle updates\n        for (var e in addedEntities) {\n          if (!addedEntities.hasOwnProperty(e)) continue;\n          o[e] = addedEntities[e];\n        }\n      }\n    } // Shallow.\n\n  }, {\n    key: "getOutput",\n    value: function getOutput() {\n      return new Map(this._outputBuffer);\n    }\n  }, {\n    key: "flush",\n    value: function flush() {\n      this._addedPlayers = new Set();\n      this._removedPlayers = new Set();\n      this._outputBuffer = new Map();\n    }\n  }, {\n    key: "addedPlayers",\n    get: function get() {\n      return this._addedPlayers;\n    }\n  }, {\n    key: "removedPlayers",\n    get: function get() {\n      return this._removedPlayers;\n    }\n  }]);\n\n  return EntityBuffer;\n}();\n\n/* harmony default export */ var buffer_entity = (EntityBuffer);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/loader/loader_chunk.js\n/**\n * Extract chunk surfaces and build hierarchy.\n */\n\n\nfunction loader_chunk_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction loader_chunk_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction loader_chunk_createClass(Constructor, protoProps, staticProps) { if (protoProps) loader_chunk_defineProperties(Constructor.prototype, protoProps); if (staticProps) loader_chunk_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction loader_chunk_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n // import TimeUtils            from \'../../../math/time\';\n\nvar loader_chunk_ChunkLoader = /*#__PURE__*/function () {\n  function ChunkLoader(consistencyEngine) {\n    loader_chunk_classCallCheck(this, ChunkLoader);\n\n    // Models.\n    this._worldModel = consistencyEngine.worldModel;\n    this._consistencyModel = consistencyEngine.consistencyModel;\n    this._xModel = consistencyEngine.xModel;\n  } // THOUGHT [OPTIM] n nearest, 1 chunk per X.\n  // no more than X chunk per player per iteration?\n\n\n  loader_chunk_createClass(ChunkLoader, [{\n    key: "computeNewChunksInRange",\n    value: function computeNewChunksInRange(player) {\n      if (!ChunkLoader.load) return;\n      var avatar = player.avatar;\n      var worldId = avatar.worldId;\n\n      var world = this._worldModel.getWorld(worldId);\n\n      var consistencyModel = this._consistencyModel;\n      var pos = avatar.position; // Has nearest chunk changed?\n\n      var coords = world.getChunkCoordinates(pos[0], pos[1], pos[2]);\n      var nearestChunkId = "".concat(coords[0], ",").concat(coords[1], ",").concat(coords[2]); // let formerNearestChunkId = avatar.nearestChunkId;\n      // Get current chunk.\n\n      var starterChunk = world.getChunkById(nearestChunkId);\n\n      if (!starterChunk) {\n        console.log(\'[WARN] Could not load chunk on which current entity is.\');\n        starterChunk = builder_chunks.addChunk(world.xSize, world.ySize, world.zSize, nearestChunkId, world); // return;\n      } // Return variables.\n\n\n      var newChunksForPlayer = {};\n      var unloadedChunksForPlayer = {}; // Case 1: need to load chunks up to R_i (inner circle)\n      // and to unload from R_o (outer circle).\n\n      if (!consistencyModel.doneChunkLoadingPhase(player, starterChunk)) {\n        newChunksForPlayer = this.loadInnerSphere(player, starterChunk); // For (i,j,k) s.t. D = d({i,j,k}, P) < P.thresh, ordered by increasing D\n        //     if !P.has(i,j,k)\n        //         Load (i,j,k) and break\n        // unloadedChunksForPlayer = this.unloadInnerToOuterSphere(player, starterChunk);\n\n        unloadedChunksForPlayer = this.unloadOuterSphere(player, starterChunk); // For (i,j,k) s.t. P.has(i,j,k)\n        //     if d({i,j,k}, P) > P.thresh\n        //         Unload (i,j,k)\n\n        avatar.nearestChunkId = nearestChunkId;\n      } // THOUGHT [OPTIM] don\'t test when doneChunkLoadingPhase has been reached once, until (nearest !== formerNearest)\n      // Case 2: if chunks were loaded up to R_i, but player walked\n      // into another chunk. Need to ensure all chunks are loaded up to R_i\n      // and every loaded chunk that happens to be outside R_o is unloaded.\n\n      /*\n      else if (nearestChunkId !== formerNearestChunkId) {\n           // For (i,j,k) s.t. d({i,j,k}, P) < P.thresh\n              // if !P.has(i,j,k)\n                  // Load (i,j,k) and break\n          newChunksForPlayer = this.loadInnerSphere(player, starterChunk);\n           // For (i,j,k) s.t. P.has(i,j,k)\n              // if d({i,j,k}, P) > P.outerThresh\n                  // Unload (i,j,k)\n          unloadedChunksForPlayer = this.unloadOuterSphere(player, starterChunk);\n          avatar.nearestChunkId = nearestChunkId;\n      }\n      */\n      // No avatar position change, nothing to update.\n      else {\n          unloadedChunksForPlayer = this.unloadOuterSphere(player, starterChunk);\n          return;\n        } // Nothing to update.\n\n\n      if (Object.keys(newChunksForPlayer).length < 1 && Object.keys(unloadedChunksForPlayer).length < 1) return;\n      return [newChunksForPlayer, unloadedChunksForPlayer];\n    } // Consistency loading (building chunks once blocks have been generated).\n\n  }, {\n    key: "loadInnerSphere",\n    value: function loadInnerSphere(player, starterChunk) {\n      // let worldId = player.avatar.worldId;\n      var worldModel = this._worldModel;\n      var xModel = this._xModel;\n      var consistencyModel = this._consistencyModel; // let world = worldModel.getWorld(worldId);\n\n      var sRadius = model_WorldModel.serverLoadingRadius;\n      var newChunksForPlayer = {}; // Loading circle for server (a bit farther)\n      // let t = TimeUtils.getTimeSecNano();\n\n      var wid = starterChunk.world.worldId;\n      var cid = starterChunk.chunkId;\n      builder_chunks.loadNextChunk(player, wid, cid, worldModel, xModel, consistencyModel, sRadius, false); // let dt1 = TimeUtils.getTimeSecNano(t)[1] / 1000;\n      // if (ChunkLoader.bench && dt1 > 1000) console.log(`\\t\\t${dt1} preLoad ForServer.`);\n      // Loading circle for client (nearer)\n      // Only load one at a time!\n      // t = TimeUtils.getTimeSecNano();\n\n      var newChunk = builder_chunks.loadNextChunk(player, wid, cid, worldModel, xModel, consistencyModel, sRadius, true); // dt1 = TimeUtils.getTimeSecNano(t)[1] / 1000;\n      // if (ChunkLoader.bench && dt1 > 1000) console.log(`\\t\\t${dt1} preLoad ForPlayer.`);\n\n      if (newChunk) {\n        if (ChunkLoader.debug) console.log("New chunk : ".concat(newChunk.chunkId)); // [OPT] multiple chunks at a time\n\n        newChunksForPlayer[newChunk.world.worldId] = loader_chunk_defineProperty({}, newChunk.chunkId, [newChunk.fastComponents, newChunk.fastComponentsIds]);\n      }\n\n      return newChunksForPlayer;\n    } // unloadInnerToOuterSphere(player, starterChunk)\n    // {\n    //     let consistencyModel = this._consistencyModel;\n    //     let worldModel = this._worldModel;\n    //     let xModel = this._xModel;\n    //\n    //     let minThreshold = player.avatar.chunkRenderDistance;\n    //     let maxThreshold = WorldModel.serverLoadingRadius;\n    //     minThreshold = Math.min(minThreshold, maxThreshold);\n    //\n    //     return ChunkBuilder.getOOBPlayerChunks(player, starterChunk,\n    //         worldModel, xModel, consistencyModel, minThreshold\n    //     );\n    // }\n\n  }, {\n    key: "unloadOuterSphere",\n    value: function unloadOuterSphere(player, starterChunk) {\n      var consistencyModel = this._consistencyModel;\n      var worldModel = this._worldModel;\n      var xModel = this._xModel;\n      var maxThreshold = player.avatar.chunkUnloadDistance;\n      return builder_chunks.getOOBPlayerChunks(player, starterChunk, worldModel, xModel, consistencyModel, maxThreshold);\n    }\n  }]);\n\n  return ChunkLoader;\n}();\n\nloader_chunk_defineProperty(loader_chunk_ChunkLoader, "debug", false);\n\nloader_chunk_defineProperty(loader_chunk_ChunkLoader, "load", true);\n\nloader_chunk_defineProperty(loader_chunk_ChunkLoader, "bench", false);\n\n/* harmony default export */ var loader_chunk = (loader_chunk_ChunkLoader);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/loader/loader_entity.js\n/**\n * Load and prepare chunks for players.\n */\n\n\nfunction loader_entity_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction loader_entity_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction loader_entity_createClass(Constructor, protoProps, staticProps) { if (protoProps) loader_entity_defineProperties(Constructor.prototype, protoProps); if (staticProps) loader_entity_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar loader_entity_EntityLoader = /*#__PURE__*/function () {\n  function EntityLoader(consistencyEngine) {\n    loader_entity_classCallCheck(this, EntityLoader);\n\n    this._entityModel = consistencyEngine.entityModel;\n    this._consistencyModel = consistencyEngine.consistencyModel;\n  } // XXX [PERF]: Use searcher O(n) -> O(n), or link entities to chunks.\n  // (only quadratic as fn of players, not entities!)\n\n\n  loader_entity_createClass(EntityLoader, [{\n    key: "computeNewEntitiesInRange",\n    value: function computeNewEntitiesInRange(player, updatedEntities, addedPlayers, removedPlayers) {\n      var entityModel = this._entityModel;\n      var consistencyModel = this._consistencyModel;\n      var avatar = player.avatar;\n      var thresh = avatar.entityRenderDistance;\n      thresh *= thresh; // Squared distance.\n      // XXX [IO] also compute entities on loaded chunks.\n\n      var distance = math_geometry.entitySquaredTransEuclideanDistance; // XXX [PERF] [IO] use array\n\n      var addedEntities = {};\n      var removedEntities = {};\n      var aid = avatar.entityId; // For all different entities.\n\n      entityModel.forEach(function (e) {\n        if (!e) return;\n        var eid = e.entityId;\n\n        if (eid !== aid) {\n          // Compute distance & find in OLD consistency model.\n          var isInRange = distance(e, avatar) < thresh;\n          var isPresent = consistencyModel.hasEntity(aid, eid);\n\n          if (isInRange && !isPresent) {\n            var d = [!!e.hit + 0, !!e._isHitting + 0, !!e._loadingRanged + 0, !!e._isParrying + 0];\n            addedEntities[eid] = {\n              p: e.position,\n              r: e.rotation,\n              k: e.kind,\n              w: e.worldId,\n              a: e.captain === avatar,\n              // is an ally\n              d: d // what it does\n\n            };\n          } else if (!isInRange && isPresent) removedEntities[eid] = null;else if (isInRange && (updatedEntities.has(eid) || updatedEntities.has(aid))) {\n            var _d = [!!e.hit + 0, !!e._isHitting + 0, !!e._loadingRanged + 0, !!e._isParrying + 0];\n            addedEntities[eid] = {\n              p: e.position,\n              r: e.rotation,\n              k: e.kind,\n              w: e.worldId,\n              a: e.captain === avatar,\n              // is an ally\n              d: _d\n            };\n          }\n        }\n      });\n      removedPlayers.forEach(function (eid) {\n        if (consistencyModel.hasEntity(aid, eid)) removedEntities[eid] = null;\n      });\n      return [addedEntities, removedEntities];\n    }\n  }]);\n\n  return EntityLoader;\n}();\n\n/* harmony default export */ var loader_entity = (loader_entity_EntityLoader);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/generator/worldgenerator.js\n/**\n *\n */\n\n\nfunction worldgenerator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction worldgenerator_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction worldgenerator_createClass(Constructor, protoProps, staticProps) { if (protoProps) worldgenerator_defineProperties(Constructor.prototype, protoProps); if (staticProps) worldgenerator_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar worldgenerator_WorldGenerator = /*#__PURE__*/function () {\n  function WorldGenerator() {\n    worldgenerator_classCallCheck(this, WorldGenerator);\n  }\n\n  worldgenerator_createClass(WorldGenerator, null, [{\n    key: "generateInitialWorld",\n    value: function generateInitialWorld(chunkSizeX, chunkSizeY, chunkSizeZ, world) {\n      var worldMap = new Map();\n      worldMap.set(\'0,0,0\', WorldGenerator.generateInitialChunk(chunkSizeX, chunkSizeY, chunkSizeZ, 0, 0, 0, world));\n      return worldMap;\n    }\n  }, {\n    key: "generateInitialChunk",\n    value: function generateInitialChunk(x, y, z, i, j, k, world) {\n      var id = "".concat(i, ",").concat(j, ",").concat(k);\n      return chunkgenerator.createRawChunk(x, y, z, id, world);\n    }\n  }, {\n    key: "generatePerlinWorld",\n    value: function generatePerlinWorld() {\n      return new Map();\n    }\n  }]);\n\n  return WorldGenerator;\n}();\n\n/* harmony default export */ var worldgenerator = (worldgenerator_WorldGenerator);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/generator/generator.js\n/**\n * Create and fill chunks.\n */\n\n\nfunction generator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction generator_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction generator_createClass(Constructor, protoProps, staticProps) { if (protoProps) generator_defineProperties(Constructor.prototype, protoProps); if (staticProps) generator_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar generator_Generator = /*#__PURE__*/function () {\n  function Generator(consistencyEngine) {\n    generator_classCallCheck(this, Generator);\n\n    this._worldModel = consistencyEngine.worldModel;\n  }\n\n  generator_createClass(Generator, [{\n    key: "generateWorld",\n    value: function generateWorld() {\n      var world = this._worldModel.getWorld(-1);\n\n      return new Promise(function (resolve) {\n        // Generate blocks.\n        var x = world.xSize;\n        var y = world.ySize;\n        var z = world.zSize;\n        var chunkMap = worldgenerator.generateInitialWorld(x, y, z, world); // Affect chunks.\n\n        world.allChunks = chunkMap; // Finalize chunks (extract surface faces).\n        // let chunks = new Map(chunkMap);\n        // Adds chunks in worldModel, so mutable chunkMapCollection does not fit.\n        // chunks.forEach(chunk/*, id)*/ => ChunkBuilder.computeChunkFaces(chunk));\n        // Notify\n\n        resolve();\n      });\n    }\n  }]);\n\n  return Generator;\n}();\n\n/* harmony default export */ var generator = (generator_Generator);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/updater/updater_x.js\n/**\n *\n */\n\n\nfunction updater_x_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction updater_x_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction updater_x_createClass(Constructor, protoProps, staticProps) { if (protoProps) updater_x_defineProperties(Constructor.prototype, protoProps); if (staticProps) updater_x_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar updater_x_XUpdater = /*#__PURE__*/function () {\n  function XUpdater(consistencyEngine) {\n    updater_x_classCallCheck(this, XUpdater);\n\n    this._worldModel = consistencyEngine.worldModel;\n    this._xModel = consistencyEngine.xModel;\n    this._consistencyModel = consistencyEngine.consistencyModel;\n    this._entityModel = consistencyEngine.entityModel;\n  }\n\n  updater_x_createClass(XUpdater, [{\n    key: "update",\n    value: function update(avatar, data) {\n      // let worldModel = this._worldModel;\n      var xModel = this._xModel; // let consistencyModel = this._consistencyModel;\n      // let action = data.action; // \'gate\'\n\n      var meta = data.meta;\n      var originWorld = parseInt(avatar.worldId, 10);\n      var x1 = parseInt(meta[1], 10);\n      var y1 = parseInt(meta[2], 10);\n      var z1 = parseInt(meta[3], 10);\n\n      var world = this._worldModel.getWorld(avatar.worldId);\n\n      var em = this._entityModel;\n      var a = updater_access.requestAddBlock(avatar, x1, y1, z1, world, em);\n      if (!a) return;\n\n      if (meta[0] === \'add\') {\n        var x2 = parseInt(meta[4], 10);\n        var y2 = parseInt(meta[5], 10);\n        var z2 = parseInt(meta[6], 10);\n        a = updater_access.requestAddBlock(avatar, x2, y2, z2, world, em);\n        if (!a) return;\n        var offset = parseFloat(meta[7]);\n        var o = parseFloat(meta[8]);\n        var orientation = typeof o === \'number\' ? o : 0;\n        var isOrangeOrBlue = meta[9];\n        var portalToLink = null;\n\n        if (!isOrangeOrBlue) // portal to another world\n          {\n            xModel.addPortal(originWorld, x1, y1, z1, x2, y2, z2, offset, orientation, portalToLink, true);\n          } else // portal linked to other players portal\n          {\n            var isBlue = meta[10];\n            var isOrange = !isBlue;\n\n            if (!isBlue && !isOrange) {\n              console.warn(\'[Updater/X] Specified portal is neither blue nor orange.\');\n              return;\n            }\n\n            var blue = avatar.bluePortal;\n            var orange = avatar.orangePortal;\n            var hasBlue = blue !== null;\n            var hasOrange = orange !== null;\n\n            if (isBlue && hasBlue || isOrange && hasOrange) {\n              console.log(\'[Updater/X] TODO: manage portal edition / deletion.\'); // return;\n            } else if (isBlue && hasOrange || isOrange && hasBlue) {\n              portalToLink = isBlue ? orange.portalId : blue.portalId;\n              var newPortal = xModel.addPortal(originWorld, x1, y1, z1, x2, y2, z2, offset, orientation, portalToLink, false);\n\n              if (!newPortal) {\n                console.error(\'[Updater/X] Failed to link to a new portal.\');\n                return;\n              }\n\n              if (isBlue) avatar.bluePortal = newPortal;else if (isOrange) avatar.orangePortal = newPortal;\n            } else {\n              var _newPortal = xModel.addPortal(originWorld, x1, y1, z1, x2, y2, z2, offset, orientation, null, false);\n\n              if (!_newPortal) {\n                console.error(\'[Updater/X] Failed to create a new portal.\');\n                return;\n              }\n\n              if (isBlue) avatar.bluePortal = _newPortal;else if (isOrange) avatar.orangePortal = _newPortal;\n            }\n          }\n      } else if (meta[0] === \'del\') {\n        xModel.removePortalFromPosition(originWorld, x1, y1, z1);\n      }\n    }\n  }]);\n\n  return XUpdater;\n}();\n\n/* harmony default export */ var updater_x = (updater_x_XUpdater);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/loader/loader_x.js\n/**\n *\n */\n\n\nfunction loader_x_toConsumableArray(arr) { return loader_x_arrayWithoutHoles(arr) || loader_x_iterableToArray(arr) || loader_x_unsupportedIterableToArray(arr) || loader_x_nonIterableSpread(); }\n\nfunction loader_x_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction loader_x_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return loader_x_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return loader_x_arrayLikeToArray(o, minLen); }\n\nfunction loader_x_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction loader_x_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return loader_x_arrayLikeToArray(arr); }\n\nfunction loader_x_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction loader_x_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction loader_x_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction loader_x_createClass(Constructor, protoProps, staticProps) { if (protoProps) loader_x_defineProperties(Constructor.prototype, protoProps); if (staticProps) loader_x_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar XLoader = /*#__PURE__*/function () {\n  function XLoader(consistencyEngine) {\n    loader_x_classCallCheck(this, XLoader);\n\n    this._xModel = consistencyEngine.xModel;\n    this._worldModel = consistencyEngine.worldModel;\n    this._consistencyModel = consistencyEngine.consistencyModel;\n  }\n\n  loader_x_createClass(XLoader, [{\n    key: "computeNewXInRange",\n    value: function computeNewXInRange(player) {\n      var _wm$getWorld;\n\n      var a = player.avatar;\n      var avatarId = a.entityId;\n      var pos = a.position;\n      var worldId = a.worldId;\n      var portalLoadingRadius = a.portalRenderDistance;\n      var wm = this._worldModel;\n      var xm = this._xModel;\n      var cm = this._consistencyModel;\n\n      var chunk = (_wm$getWorld = wm.getWorld(worldId)).getChunkByCoordinates.apply(_wm$getWorld, loader_x_toConsumableArray(pos));\n\n      if (!chunk) {\n        console.log("[LoaderX] Undefined chunk for pos ".concat(pos, " in wid ").concat(worldId, "."));\n        return null;\n      } // Format:\n      // Map (portal id -> [other portal id, other portal world])\n      // Compute new portals in range.\n\n\n      var connectivity = xm.getConnectivity(worldId, chunk.chunkId, wm, portalLoadingRadius);\n      if (!connectivity) return;\n      var addedPortals = {};\n      var portals = connectivity[0];\n      if (portals) portals.forEach(function (array, portalId) {\n        var partial = cm.isPartialX();\n        if (cm.hasX(avatarId, portalId) && !partial) return; // Manage other end as a whole.\n\n        if (partial) {\n          if (array) {\n            addedPortals[portalId] = loader_x_toConsumableArray(array); // API: Other end id, chunk id, world id, xyzp, orientation, world id,\n            // x1,y1,z1, x2,y2,z2, partial position, orientation\n\n            cm.unsetPartialX(avatarId, portalId);\n          } // Else, nothing to do still.\n\n        } else if (!partial) {\n          if (array) {\n            addedPortals[portalId] = loader_x_toConsumableArray(array);\n          } else {\n            // If those other ids have length 0, client will consider the portal blank.\n            addedPortals[portalId] = [0]; // Then they are flagged as \'partial\' in consistency model.\n\n            cm.setPartialX(avatarId, portalId);\n          }\n        }\n      }); // Update out of range portals.\n      // XXX [PERF] when getConnectivity is performed,\n      //  just remember which levels correspond to which portals\n\n      var playerXs = cm.getXIdsForEntity(avatarId);\n      var removedPortals = {};\n      var chunks = connectivity[1];\n\n      if (chunks) {\n        var marks = new Map();\n        chunks.forEach(function (c) {\n          return marks.set("".concat(c[0], ",").concat(c[1]), "".concat(c[2]));\n        });\n        playerXs.forEach(function (portalId) {\n          var p = xm.getPortal(portalId);\n          var i = "".concat(p.worldId, ",").concat(p.chunkId);\n          var d = marks.get(i);\n          if (d === undefined || d === null || d > portalLoadingRadius) removedPortals[portalId] = null;\n        });\n      }\n\n      return [addedPortals, removedPortals];\n    }\n  }]);\n\n  return XLoader;\n}();\n\n/* harmony default export */ var loader_x = (XLoader);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/buffer_x.js\n/**\n *\n */\n\n\nfunction buffer_x_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction buffer_x_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction buffer_x_createClass(Constructor, protoProps, staticProps) { if (protoProps) buffer_x_defineProperties(Constructor.prototype, protoProps); if (staticProps) buffer_x_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar XBuffer = /*#__PURE__*/function () {\n  function XBuffer() {\n    buffer_x_classCallCheck(this, XBuffer);\n\n    // Don\'t implement add/removeX\n    // For they\'ll be updated next frame.\n    // Should do same with players :/\n    this._outputBuffer = new Map();\n  }\n\n  buffer_x_createClass(XBuffer, [{\n    key: "updateXForPlayer",\n    value: function updateXForPlayer(playerId, addedX, removedX) {\n      if (!(addedX && Object.keys(addedX).length > 0) && !(removedX && Object.keys(removedX).length > 0)) return;\n      if (addedX && Object.keys(addedX).length > 0 && removedX && Object.keys(removedX).length > 0) Object.assign(addedX, removedX);else if (removedX && Object.keys(removedX).length > 0) addedX = removedX;\n\n      this._outputBuffer.set(playerId, addedX);\n    }\n  }, {\n    key: "getOutput",\n    value: function getOutput() {\n      return new Map(this._outputBuffer);\n    }\n  }, {\n    key: "flush",\n    value: function flush() {\n      this._outputBuffer = new Map();\n    }\n  }]);\n\n  return XBuffer;\n}();\n\n/* harmony default export */ var buffer_x = (XBuffer);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/updater/updater.js\n/**\n *\n */\n\n\nfunction updater_updater_slicedToArray(arr, i) { return updater_updater_arrayWithHoles(arr) || updater_updater_iterableToArrayLimit(arr, i) || updater_updater_unsupportedIterableToArray(arr, i) || updater_updater_nonIterableRest(); }\n\nfunction updater_updater_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction updater_updater_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return updater_updater_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return updater_updater_arrayLikeToArray(o, minLen); }\n\nfunction updater_updater_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction updater_updater_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction updater_updater_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction engine_consistency_updater_updater_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction engine_consistency_updater_updater_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction engine_consistency_updater_updater_createClass(Constructor, protoProps, staticProps) { if (protoProps) engine_consistency_updater_updater_defineProperties(Constructor.prototype, protoProps); if (staticProps) engine_consistency_updater_updater_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction updater_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nvar engine_consistency_updater_updater_Updater = /*#__PURE__*/function () {\n  function Updater(consistencyEngine) {\n    engine_consistency_updater_updater_classCallCheck(this, Updater);\n\n    // Model.\n    this._game = consistencyEngine.game;\n    this._worldModel = consistencyEngine.worldModel;\n    this._consistencyModel = consistencyEngine.consistencyModel; // Engine.\n\n    this._physicsEngine = consistencyEngine.physicsEngine;\n    this._chunkBuffer = consistencyEngine.chunkBuffer;\n    this._entityBuffer = consistencyEngine.entityBuffer;\n    this._chunkLoader = consistencyEngine.chunkLoader;\n    this._entityLoader = consistencyEngine.entityLoader; // xEngine.\n\n    this._xUpdater = new updater_x(consistencyEngine);\n    this._xLoader = new loader_x(consistencyEngine);\n    this._xBuffer = new buffer_x(); // X creation/deletion buffer.\n\n    this._inputBuffer = [];\n  }\n\n  engine_consistency_updater_updater_createClass(Updater, [{\n    key: "addInput",\n    value: function addInput(meta, avatar) {\n      this._inputBuffer.push([avatar, meta]);\n    }\n  }, {\n    key: "update",\n    value: function update(updateEntities) {\n      // User-send updates (mainly x).\n      this.processBuffer(); // Compute aggregates to send.\n\n      this.updateConsistency(updateEntities);\n    }\n  }, {\n    key: "processBuffer",\n    value: function processBuffer() {\n      var buffer = this._inputBuffer;\n      var xUpdater = this._xUpdater;\n      buffer.forEach(function (x) {\n        // console.log(x[0]); // Avatar\n        // console.log(x[1]); // { action: \'gate\', meta: [ \'add\', -2, 6, -16, portalToLinkId ] }\n        xUpdater.update(x[0], x[1]);\n      }); // Flush X INPUT (BEFORE SEND UPDATE).\n\n      this._inputBuffer = [];\n    } // Get X output\n\n  }, {\n    key: "getOutput",\n    value: function getOutput() {\n      return this._xBuffer.getOutput();\n    } // Flush X OUTPUT (AFTER SEND UPDATER).\n\n  }, {\n    key: "flushBuffers",\n    value: function flushBuffers() {\n      this._xBuffer.flush();\n    } // This only takes care of LOADING things with respect to players.\n    // (entities, chunks)\n    // The Output class directly manages CHANGING things.\n    // (it gets outputs from TopologyEngine and PhysicsEngine, then transmits them to players)\n    // Loading and unloading objects is done exclusively here.\n    // Single criterion for maintaining loaded objects consistent: distance.\n    // (objects are initialized with STATES so they don\'t need updates)\n\n  }, {\n    key: "updateConsistency",\n    value: function updateConsistency(updateEntities) {\n      var players = this._game.players; // Get buffers.\n\n      var cbuf = this._chunkBuffer;\n      var ebuf = this._entityBuffer;\n      var xbuf = this._xBuffer; // Model and engines.\n\n      var worldModel = this._worldModel;\n      var consistencyModel = this._consistencyModel;\n\n      var updatedEntities = this._physicsEngine.getOutput();\n\n      var addedPlayers = this._entityBuffer.addedPlayers;\n      var removedPlayers = this._entityBuffer.removedPlayers; // Loaders\n\n      var eLoader = this._entityLoader;\n      var cLoader = this._chunkLoader;\n      var xLoader = this._xLoader; // Object iterator.\n\n      var forEach = function forEach(object, callback) {\n        for (var id in object) {\n          callback(id);\n        }\n      }; // For each player...\n      // let t = TimeUtils.getTimeSecNano();\n      // let dt1;\n      // let debugThresh = 1000;\n      // XXX [PERF] [IO] use more arrays instead of objects and for-ins\n\n\n      players.forEach(function (p) {\n        if (p.avatar) {\n          var pid = p.avatar.entityId; // Compute change for entities in range.\n\n          var addedEntities;\n          var removedEntities;\n          var u = updateEntities ? eLoader.computeNewEntitiesInRange(p, updatedEntities, addedPlayers, removedPlayers) : null;\n\n          if (u) {\n            var _u = updater_updater_slicedToArray(u, 2);\n\n            addedEntities = _u[0];\n            removedEntities = _u[1];\n          } // XXX [PERF] filter: updated entities and entities that enter in range.\n          // dt1 = TimeUtils.getTimeSecNano(t)[1] / 1000;\n          // if (Updater.bench && dt1 > debugThresh) console.log(`\\t${dt1} computeNew Entities.`);\n          // t = TimeUtils.getTimeSecNano();\n          // Compute change for chunks in range.\n\n\n          var addedChunks;\n          var removedChunks;\n          var v = cLoader.computeNewChunksInRange(p);\n\n          if (v) {\n            var _v = updater_updater_slicedToArray(v, 2);\n\n            addedChunks = _v[0];\n            removedChunks = _v[1];\n          } // dt1 = TimeUtils.getTimeSecNano(t)[1] / 1000;\n          // if (Updater.bench && dt1 > debugThresh) console.log(`\\t${dt1} computeNew Chunks.`);\n          // t = TimeUtils.getTimeSecNano();\n\n\n          var addedX;\n          var removedX;\n          var addedW;\n          var addedWMeta;\n          var x = xLoader.computeNewXInRange(p);\n\n          if (x) {\n            var _x = updater_updater_slicedToArray(x, 2);\n\n            addedX = _x[0];\n            removedX = _x[1];\n          } // Update consistency model.\n          // WARN: updates will only be transmitted during next output pass.\n          // BE CAREFUL HERE\n\n\n          if (addedEntities && Object.keys(addedEntities).length > 0) forEach(addedEntities, function (e) {\n            return consistencyModel.setEntityLoaded(pid, parseInt(e, 10));\n          });\n          if (removedEntities && Object.keys(removedEntities).length > 0) forEach(removedEntities, function (e) {\n            return consistencyModel.setEntityOutOfRange(pid, parseInt(e, 10));\n          });\n          if (addedX && Object.keys(addedX).length > 0) forEach(addedX, function (ax) {\n            return consistencyModel.setXLoaded(pid, parseInt(ax, 10));\n          });\n          if (removedX && Object.keys(removedX).length > 0) forEach(removedX, function (ax) {\n            return consistencyModel.setXOutOfRange(pid, parseInt(ax, 10));\n          });\n\n          if (addedChunks) {\n            addedW = {};\n            addedWMeta = {};\n            forEach(addedChunks, function (wid) {\n              if (!(wid in addedW)) {\n                var w = worldModel.getWorld(parseInt(wid, 10));\n                addedW[wid] = [w.xSize, w.ySize, w.zSize];\n\n                if (!consistencyModel.hasWorld(wid)) {\n                  addedWMeta[wid] = [w.worldInfo.type, w.worldInfo.radius, w.worldInfo.center.x, w.worldInfo.center.y, w.worldInfo.center.z];\n                }\n              }\n\n              forEach(addedChunks[wid], function (c) {\n                consistencyModel.setChunkLoaded(pid, parseInt(wid, 10), c);\n              });\n            });\n          }\n\n          if (removedChunks) forEach(removedChunks, function (wid) {\n            forEach(removedChunks[wid], function (c) {\n              return consistencyModel.setChunkOutOfRange(pid, parseInt(wid, 10), c);\n            });\n          }); // XXX [PERF] pack everything in just one send\n          // Update output buffers.\n\n          if (addedChunks && Object.keys(addedChunks).length > 0 || removedChunks && Object.keys(removedChunks).length > 0) cbuf.updateChunksForPlayer(pid, addedChunks, removedChunks, addedW, addedWMeta);\n          if (addedEntities && Object.keys(addedEntities).length > 0 || removedEntities && Object.keys(removedEntities).length > 0) ebuf.updateEntitiesForPlayer(pid, addedEntities, removedEntities);\n          if (addedX && Object.keys(addedX).length > 0 || removedX && Object.keys(removedX).length > 0) xbuf.updateXForPlayer(pid, addedX, removedX);\n        }\n      });\n    }\n  }]);\n\n  return Updater;\n}();\n\nupdater_defineProperty(engine_consistency_updater_updater_Updater, "bench", false);\n\n/* harmony default export */ var engine_consistency_updater_updater = (engine_consistency_updater_updater_Updater);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_consistency/consistency.js\n/**\n *\n */\n\n\nfunction consistency_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction consistency_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction consistency_createClass(Constructor, protoProps, staticProps) { if (protoProps) consistency_defineProperties(Constructor.prototype, protoProps); if (staticProps) consistency_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\n\nvar consistency_ConsistencyEngine = /*#__PURE__*/function () {\n  function ConsistencyEngine(game) {\n    consistency_classCallCheck(this, ConsistencyEngine);\n\n    this._game = game; // Models.\n\n    this._entityModel = game.entityModel;\n    this._worldModel = game.worldModel;\n    this._xModel = game.xModel;\n    this._consistencyModel = game.consistencyModel; // Buffers.\n\n    this._chunkBuffer = new buffer_chunk();\n    this._entityBuffer = new buffer_entity(); // Other engines.\n\n    this._physicsEngine = game.physicsEngine;\n    this._topologyEngine = game.topologyEngine; // Internal engine.\n\n    this._generator = new generator(this);\n    this._chunkLoader = new loader_chunk(this);\n    this._entityLoader = new loader_entity(this);\n    this._updater = new engine_consistency_updater_updater(this); // Spawn input\n\n    this._awaitingSpawn = [];\n  }\n\n  consistency_createClass(ConsistencyEngine, [{\n    key: "spawnPlayer",\n    // On connection / disconnection.\n    value: function spawnPlayer(player) {\n      this._awaitingSpawn.push(player);\n    }\n  }, {\n    key: "updateSpawns",\n    value: function updateSpawns() {\n      var awaiting = this._awaitingSpawn;\n      var l = awaiting.length;\n      if (l < 1) return;\n      var status = this.trySpawningPlayer(awaiting[l - 1]);\n\n      if (status) // Managed spawning a player!\n        {\n          awaiting.pop();\n        }\n    }\n  }, {\n    key: "trySpawningPlayer",\n    value: function trySpawningPlayer(player) {\n      var world = this._worldModel.getFreeWorld();\n\n      var freePosition = world.getFreePosition();\n\n      if (!freePosition) {\n        // console.log(\'Failed to spawn player.\');\n        return false;\n      } // Insert player into \'all entities\' array\n\n\n      this._entityModel.spawnPlayer(player, world, freePosition); // Init entity and chunk visibility for player\n\n\n      this._consistencyModel.spawnPlayer(player); // Push new player into next updates\n\n\n      this._entityBuffer.spawnPlayer(player); // Insert player into optimized physics structures\n\n\n      this._physicsEngine.spawnPlayer(player); // Listen to player inputs\n\n\n      this._game._externalInput.listenPlayer(player);\n\n      return true;\n    }\n  }, {\n    key: "despawnPlayer",\n    value: function despawnPlayer(playerId) {\n      this._entityBuffer.removePlayer(playerId);\n\n      this._consistencyModel.removePlayer(playerId);\n\n      this._physicsEngine.removePlayer(playerId);\n\n      this._entityModel.removePlayer(playerId);\n    }\n  }, {\n    key: "spawnEntity",\n    value: function spawnEntity(kind, world, position) {\n      var entity = this._entityModel.spawnEntity(kind, world, position);\n\n      this._entityBuffer.spawnEntity(entity);\n\n      this._physicsEngine.spawnEntity(entity);\n\n      return entity;\n    }\n  }, {\n    key: "despawnEntity",\n    value: function despawnEntity(entityId) {\n      if (!this._entityModel || !this._entityModel._entities) return;\n      var e = this._entityModel._entities[entityId];\n      if (!e) return;\n\n      this._entityBuffer.removeEntity(entityId);\n\n      this._physicsEngine.removeEntity(entityId);\n\n      this._entityModel.removeEntity(entityId);\n    }\n  }, {\n    key: "addInput",\n    value: function addInput(meta, avatar) {\n      this._updater.addInput(meta, avatar);\n    }\n  }, {\n    key: "update",\n    value: function update(updateEntities) {\n      this.updateSpawns();\n\n      this._updater.update(updateEntities);\n    }\n  }, {\n    key: "getChunkOutput",\n    value: function getChunkOutput() {\n      return this._chunkBuffer.getOutput();\n    }\n  }, {\n    key: "getEntityOutput",\n    value: function getEntityOutput() {\n      return this._entityBuffer.getOutput();\n    }\n  }, {\n    key: "getPlayerOutput",\n    value: function getPlayerOutput() {\n      return this._entityBuffer.addedPlayers;\n    }\n  }, {\n    key: "getXOutput",\n    value: function getXOutput() {\n      return this._updater.getOutput();\n    }\n  }, {\n    key: "flushBuffers",\n    value: function flushBuffers(updateEntities) {\n      this._chunkBuffer.flush();\n\n      if (updateEntities) this._entityBuffer.flush();\n\n      this._updater.flushBuffers();\n    }\n  }, {\n    key: "generateWorld",\n    value: function generateWorld() {\n      return this._generator.generateWorld();\n    }\n  }, {\n    key: "game",\n    get: function get() {\n      return this._game;\n    }\n  }, {\n    key: "worldModel",\n    get: function get() {\n      return this._worldModel;\n    }\n  }, {\n    key: "entityModel",\n    get: function get() {\n      return this._entityModel;\n    }\n  }, {\n    key: "xModel",\n    get: function get() {\n      return this._xModel;\n    }\n  }, {\n    key: "consistencyModel",\n    get: function get() {\n      return this._consistencyModel;\n    }\n  }, {\n    key: "physicsEngine",\n    get: function get() {\n      return this._physicsEngine;\n    }\n  }, {\n    key: "chunkBuffer",\n    get: function get() {\n      return this._chunkBuffer;\n    }\n  }, {\n    key: "entityBuffer",\n    get: function get() {\n      return this._entityBuffer;\n    }\n  }, {\n    key: "chunkLoader",\n    get: function get() {\n      return this._chunkLoader;\n    }\n  }, {\n    key: "entityLoader",\n    get: function get() {\n      return this._entityLoader;\n    }\n  }]);\n\n  return ConsistencyEngine;\n}();\n\n/* harmony default export */ var consistency = (consistency_ConsistencyEngine);\n// CONCATENATED MODULE: ./server/app/engine/game3d/model_entity/avatar.js\n/**\n * Player entry point.\n */\n\n\nfunction avatar_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { avatar_typeof = function _typeof(obj) { return typeof obj; }; } else { avatar_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return avatar_typeof(obj); }\n\nfunction avatar_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction avatar_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction avatar_createClass(Constructor, protoProps, staticProps) { if (protoProps) avatar_defineProperties(Constructor.prototype, protoProps); if (staticProps) avatar_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (avatar_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\nvar Avatar = /*#__PURE__*/function (_Entity) {\n  _inherits(Avatar, _Entity);\n\n  var _super = _createSuper(Avatar);\n\n  function Avatar(id) {\n    var _this;\n\n    avatar_classCallCheck(this, Avatar);\n\n    _this = _super.call(this, id);\n    _this._kind = \'player\'; // Counted as a number of chunks.\n\n    _this._chunkRenderDistance = 5; // If you increase this, also increase model_x/model.push(chksZ, currentDepth + 2);\n    // For flat worlds\n\n    _this._chunkUnloadDistance = 7; // Might be a good idea to keep the unload distance as big as possible client-wise\n    // When games dont contain many players.\n\n    _this._portalRenderDistance = 4;\n    _this._portalBlue = null;\n    _this._portalOrange = null; // Counted as a number of blocks.\n\n    _this._entityRenderDistance = 3 * 32; // XXX [PERF] Should be a number of closest entities instead\n    // For op / admin accesses\n\n    _this._role = 0;\n    _this._nearestChunkId = null;\n    _this._pAction = [0, 0, 0]; // where action is triggered from\n\n    _this._fAction = [0, 0, 0]; // where action is looking to\n\n    _this._isParrying = false;\n    _this._loadingRanged = false;\n    _this._hasJustFired = false;\n    _this._hasJustMeleed = false;\n    _this._isHitting = false;\n    _this._hasJustJumped = false;\n    _this._isAvatar = true;\n    _this._timeSpentLoading = 0;\n    return _this;\n  } // Returns -1: admin, 0: OP, 1: registered, 2: guest.\n\n\n  avatar_createClass(Avatar, [{\n    key: "getForwardActionVector",\n    value: function getForwardActionVector() {\n      return this._fAction;\n    }\n  }, {\n    key: "unParry",\n    value: function unParry() {\n      this._isParrying = false;\n    }\n  }, {\n    key: "loadRanged",\n    value: function loadRanged() {\n      this._loadingRanged = true;\n      this._timeSpentLoading = 0;\n    }\n  }, {\n    key: "unLoadRanged",\n    value: function unLoadRanged() {\n      var power = this._timeSpentLoading;\n      this._loadingRanged = false;\n      this._timeSpentLoading = 0;\n      return power;\n    }\n  }, {\n    key: "parry",\n    value: function parry(px, py, pz, fx, fy, fz) {\n      this.setPF(px, py, pz, fx, fy, fz);\n      this._isParrying = true;\n    }\n  }, {\n    key: "melee",\n    value: function melee(px, py, pz, fx, fy, fz) {\n      this.setPF(px, py, pz, fx, fy, fz);\n      this._hasJustMeleed = true;\n    }\n  }, {\n    key: "countSinceLoadStart",\n    value: function countSinceLoadStart() {\n      if (this._loadingRanged) {\n        ++this._timeSpentLoading;\n      } else {\n        this._timeSpentLoading = 0;\n      }\n    }\n  }, {\n    key: "fire",\n    value: function fire(px, py, pz, fx, fy, fz) {\n      this.setPF(px, py, pz, fx, fy, fz);\n      this._hasJustFired = true;\n    }\n  }, {\n    key: "setPF",\n    value: function setPF(px, py, pz, fx, fy, fz) {\n      var p = this._pAction;\n      p[0] = px;\n      p[1] = py;\n      p[2] = pz;\n      var f = this._fAction;\n      var norm = fx * fx + fy * fy + fz * fz;\n      var x = fx / norm;\n      x = Math.min(Math.max(-1, x), 1);\n      var y = fy / norm;\n      y = Math.min(Math.max(-1, y), 1);\n      var z = fz / norm;\n      z = Math.min(Math.max(-1, z), 1);\n      if (x * x + y * y + z * z > 1.001) return;\n      f[0] = x;\n      f[1] = y;\n      f[2] = z;\n    }\n  }, {\n    key: "role",\n    get: function get() {\n      return this._role;\n    },\n    set: function set(role) {\n      this._role = role;\n    }\n  }, {\n    key: "chunkRenderDistance",\n    get: function get() {\n      return this._chunkRenderDistance;\n    },\n    set: function set(renderDistance) {\n      this._chunkRenderDistance = renderDistance;\n    }\n  }, {\n    key: "chunkUnloadDistance",\n    get: function get() {\n      return this._chunkUnloadDistance;\n    },\n    set: function set(unloadDistance) {\n      this._chunkUnloadDistance = unloadDistance;\n    }\n  }, {\n    key: "entityRenderDistance",\n    get: function get() {\n      return this._entityRenderDistance;\n    },\n    set: function set(renderDistance) {\n      this._entityRenderDistance = renderDistance;\n    }\n  }, {\n    key: "portalRenderDistance",\n    get: function get() {\n      return this._portalRenderDistance;\n    },\n    set: function set(renderDistance) {\n      this._portalRenderDistance = renderDistance;\n    }\n  }, {\n    key: "nearestChunkId",\n    get: function get() {\n      return this._nearestChunkId;\n    },\n    set: function set(chunkId) {\n      this._nearestChunkId = chunkId;\n    }\n  }, {\n    key: "bluePortal",\n    get: function get() {\n      return this._portalBlue;\n    },\n    set: function set(p) {\n      this._portalBlue = p;\n    }\n  }, {\n    key: "orangePortal",\n    get: function get() {\n      return this._portalOrange;\n    },\n    set: function set(p) {\n      this._portalOrange = p;\n    }\n  }, {\n    key: "hasJustMeleed",\n    get: function get() {\n      return this._hasJustMeleed;\n    },\n    set: function set(n) {\n      this._hasJustMeleed = n;\n    }\n  }, {\n    key: "loadingRanged",\n    get: function get() {\n      return this._loadingRanged;\n    },\n    set: function set(n) {\n      this._loadingRanged = n;\n    }\n  }, {\n    key: "hasJustFired",\n    get: function get() {\n      return this._hasJustFired;\n    },\n    set: function set(n) {\n      this._hasJustFired = n;\n    }\n  }, {\n    key: "isParrying",\n    get: function get() {\n      return this._isParrying;\n    }\n  }]);\n\n  return Avatar;\n}(model_entity_entity);\n\n/* harmony default export */ var model_entity_avatar = (Avatar);\n// CONCATENATED MODULE: ./server/app/engine/game3d/model_entity/cube.js\n/**\n *\n */\n\n\nfunction cube_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { cube_typeof = function _typeof(obj) { return typeof obj; }; } else { cube_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return cube_typeof(obj); }\n\nfunction cube_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction cube_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) cube_setPrototypeOf(subClass, superClass); }\n\nfunction cube_setPrototypeOf(o, p) { cube_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return cube_setPrototypeOf(o, p); }\n\nfunction cube_createSuper(Derived) { var hasNativeReflectConstruct = cube_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = cube_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = cube_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return cube_possibleConstructorReturn(this, result); }; }\n\nfunction cube_possibleConstructorReturn(self, call) { if (call && (cube_typeof(call) === "object" || typeof call === "function")) { return call; } return cube_assertThisInitialized(self); }\n\nfunction cube_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction cube_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction cube_getPrototypeOf(o) { cube_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return cube_getPrototypeOf(o); }\n\n\n\nvar Cube = /*#__PURE__*/function (_Entity) {\n  cube_inherits(Cube, _Entity);\n\n  var _super = cube_createSuper(Cube);\n\n  function Cube(id) {\n    var _this;\n\n    cube_classCallCheck(this, Cube);\n\n    _this = _super.call(this, id);\n    _this._kind = \'cube\';\n    return _this;\n  }\n\n  return Cube;\n}(model_entity_entity);\n\n/* harmony default export */ var model_entity_cube = (Cube);\n// CONCATENATED MODULE: ./server/app/engine/game3d/model_entity/walker.js\n/**\n * IA entry point.\n */\n\n\nfunction walker_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { walker_typeof = function _typeof(obj) { return typeof obj; }; } else { walker_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return walker_typeof(obj); }\n\nfunction walker_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction walker_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction walker_createClass(Constructor, protoProps, staticProps) { if (protoProps) walker_defineProperties(Constructor.prototype, protoProps); if (staticProps) walker_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction walker_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) walker_setPrototypeOf(subClass, superClass); }\n\nfunction walker_setPrototypeOf(o, p) { walker_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return walker_setPrototypeOf(o, p); }\n\nfunction walker_createSuper(Derived) { var hasNativeReflectConstruct = walker_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = walker_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = walker_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return walker_possibleConstructorReturn(this, result); }; }\n\nfunction walker_possibleConstructorReturn(self, call) { if (call && (walker_typeof(call) === "object" || typeof call === "function")) { return call; } return walker_assertThisInitialized(self); }\n\nfunction walker_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction walker_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction walker_getPrototypeOf(o) { walker_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return walker_getPrototypeOf(o); }\n\n\n\nvar Walker = /*#__PURE__*/function (_Entity) {\n  walker_inherits(Walker, _Entity);\n\n  var _super = walker_createSuper(Walker);\n\n  function Walker(id) {\n    var _this;\n\n    walker_classCallCheck(this, Walker);\n\n    _this = _super.call(this, id);\n    _this._kind = \'ia\';\n    _this._capW = .008;\n    _this._age = 0;\n    _this._lastDecision = 0;\n    _this._target = null;\n    _this._captain = null;\n    _this._aggro = null;\n    return _this;\n  }\n\n  walker_createClass(Walker, [{\n    key: "age",\n    value: function age() {\n      ++this._age;\n    }\n  }, {\n    key: "takeDecision",\n    value: function takeDecision() {\n      this._lastDecision = this._age;\n    }\n  }, {\n    key: "howLongSinceLastDecision",\n    value: function howLongSinceLastDecision() {\n      return this._lastDecision - this._age;\n    }\n  }, {\n    key: "captain",\n    get: function get() {\n      return this._captain;\n    },\n    set: function set(newCaptain) {\n      this._captain = newCaptain;\n    }\n  }, {\n    key: "aggro",\n    get: function get() {\n      return this._aggro;\n    },\n    set: function set(newAggro) {\n      this._aggro = newAggro;\n    }\n  }, {\n    key: "target",\n    get: function get() {\n      return this._target;\n    },\n    set: function set(newTarget) {\n      this._target = newTarget;\n    }\n  }]);\n\n  return Walker;\n}(model_entity_entity);\n\n/* harmony default export */ var walker = (Walker);\n// CONCATENATED MODULE: ./server/app/engine/game3d/model_entity/projectile.js\n/**\n * Magnus-friendly foe.\n */\n\n\nfunction projectile_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { projectile_typeof = function _typeof(obj) { return typeof obj; }; } else { projectile_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return projectile_typeof(obj); }\n\nfunction projectile_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction projectile_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction projectile_createClass(Constructor, protoProps, staticProps) { if (protoProps) projectile_defineProperties(Constructor.prototype, protoProps); if (staticProps) projectile_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction projectile_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) projectile_setPrototypeOf(subClass, superClass); }\n\nfunction projectile_setPrototypeOf(o, p) { projectile_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return projectile_setPrototypeOf(o, p); }\n\nfunction projectile_createSuper(Derived) { var hasNativeReflectConstruct = projectile_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = projectile_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = projectile_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return projectile_possibleConstructorReturn(this, result); }; }\n\nfunction projectile_possibleConstructorReturn(self, call) { if (call && (projectile_typeof(call) === "object" || typeof call === "function")) { return call; } return projectile_assertThisInitialized(self); }\n\nfunction projectile_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction projectile_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction projectile_getPrototypeOf(o) { projectile_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return projectile_getPrototypeOf(o); }\n\n\n\nvar Projectile = /*#__PURE__*/function (_Entity) {\n  projectile_inherits(Projectile, _Entity);\n\n  var _super = projectile_createSuper(Projectile);\n\n  function Projectile(id) {\n    var _this;\n\n    projectile_classCallCheck(this, Projectile);\n\n    _this = _super.call(this, id);\n    _this._kind = \'projectile\';\n    _this._collided = false;\n    _this._widthX = .125;\n    _this._widthY = .125;\n    _this._widthZ = .125;\n    _this._age = 0;\n    _this._lastMoved = 0;\n    _this._isProjectile = true;\n    return _this;\n  }\n\n  projectile_createClass(Projectile, [{\n    key: "ageProjectile",\n    value: function ageProjectile() {\n      ++this._age;\n    }\n  }, {\n    key: "hasMoved",\n    value: function hasMoved() {\n      this._lastMoved = this._age;\n    }\n  }, {\n    key: "howLongSinceLastMoved",\n    value: function howLongSinceLastMoved() {\n      return this._age - this._lastMoved;\n    }\n  }, {\n    key: "collided",\n    set: function set(c) {\n      this._collided = c;\n    },\n    get: function get() {\n      return this._collided;\n    }\n  }]);\n\n  return Projectile;\n}(model_entity_entity);\n\n/* harmony default export */ var projectile = (Projectile);\n// CONCATENATED MODULE: ./server/app/engine/game3d/model_entity/model.js\n/**\n *\n */\n\n\nfunction model_entity_model_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction model_entity_model_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction model_entity_model_createClass(Constructor, protoProps, staticProps) { if (protoProps) model_entity_model_defineProperties(Constructor.prototype, protoProps); if (staticProps) model_entity_model_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n // import Entity from \'./entity\';\n// import CollectionUtil from \'../../math/collections\';\n\nvar model_EntityModel = /*#__PURE__*/function () {\n  function EntityModel(game) {\n    model_entity_model_classCallCheck(this, EntityModel);\n\n    this._game = game; // Fast register for all entities.\n    // [OPT] accessor: LACKS.\n    // [OPT] use arrays\n    //this._entities = new Map();\n    // [OPT] cache optimization.\n\n    this._entities = []; // Entity id <-> position in entity array.\n    // new Array(10);\n\n    this._freedEntities = []; // Indexes of deleted entities.\n\n    this._entitiesLength = 0; // Length of entity array.\n  }\n\n  model_entity_model_createClass(EntityModel, [{\n    key: "forEach",\n    value: function forEach(callback) {\n      var entities = this._entities;\n      entities.forEach(function (entity\n      /*, id)*/\n      ) {\n        callback(entity);\n      });\n    }\n  }, {\n    key: "spawnPlayer",\n    value: function spawnPlayer(p, world, freePosition) {\n      var avatar = this.createEntity(\'avatar\');\n      p.avatar = avatar;\n      var worldId = world.worldId;\n      avatar.spawn(freePosition, worldId);\n    }\n  }, {\n    key: "spawnEntity",\n    value: function spawnEntity(kind, world, position) {\n      var entity = this.createEntity(kind);\n      var worldId = world.worldId;\n      entity.spawn(position, worldId);\n      return entity;\n    } // World to be set at spawn time.\n\n  }, {\n    key: "createEntity",\n    value: function createEntity(kind) {\n      var entities = this._entities; //let entitiesLength = this._entitiesLength;\n\n      var freedEntities = this._freedEntities;\n      var entityId;\n\n      if (freedEntities.length > 0) {\n        entityId = freedEntities[0]; // ^ XXX [ENTITIES] impact consistency model\n\n        freedEntities.shift();\n      } else {\n        entityId = entities.length; //if (entityId >= entitiesLength) resizeAugment();\n        //++entitiesLength;\n      } // console.log(\'Entity shall have id \' + entityId);\n\n\n      var e;\n\n      switch (kind) {\n        case \'avatar\':\n          e = new model_entity_avatar(entityId);\n          break;\n\n        case \'cube\':\n          e = new model_entity_cube(entityId);\n          break;\n\n        case \'walker\':\n          e = new walker(entityId);\n          break;\n\n        case \'projectile\':\n          e = new projectile(entityId);\n          break;\n\n        default:\n          throw Error(\'Invalid entity type.\');\n      }\n\n      entities[entityId] = e;\n      return e;\n    }\n  }, {\n    key: "removePlayer",\n    value: function removePlayer(playerId) {\n      this.removeEntity(playerId);\n    }\n  }, {\n    key: "removeEntity",\n    value: function removeEntity(entityId) {\n      this._entities[entityId] = undefined;\n\n      this._freedEntities.push(entityId);\n    } // [OPT] Can be optimized\n\n  }, {\n    key: "anEntityIsPresentOn",\n    value: function anEntityIsPresentOn(worldId, x, y, z) {\n      var entities = this._entities;\n      if (!entities) return false; // O(n) -> not good\n\n      for (var e = 0, l = entities.length; e < l; ++e) {\n        var entity = entities[e];\n        if (!entity || entity.worldId !== worldId) continue;\n        var p = entity.position;\n        var px = p[0];\n        var wx = entity.widthX;\n        var py = p[1];\n        var wy = entity.widthY;\n        var pz = p[2];\n        var wz = entity.widthZ;\n        if (x + 1 >= px - wx && x <= px + wx && y + 1 >= py - wy && y <= py + wy && z + 1 >= pz - wz && z <= pz + wz) return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: "entities",\n    get: function get() {\n      return this._entities;\n    }\n  }]);\n\n  return EntityModel;\n}();\n\n/* harmony default export */ var model_entity_model = (model_EntityModel);\n// CONCATENATED MODULE: ./server/app/engine/game3d/model_x/knot.js\n/**\n *\n */\n\n\nfunction knot_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction knot_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction knot_createClass(Constructor, protoProps, staticProps) { if (protoProps) knot_defineProperties(Constructor.prototype, protoProps); if (staticProps) knot_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar knot_Knot = /*#__PURE__*/function () {\n  /**\n   * @param id knot id in XModel\n   * @param portal1 first portal\n   * @param portal2 second (if not, generated) portal\n   */\n  function Knot(id, portal1, portal2) {\n    knot_classCallCheck(this, Knot);\n\n    this._id = id;\n    this._portal1 = portal1;\n\n    if (!portal2) {\n      // TODO [PORTAL] choose something interesting to link the portal to\n      portal2 = new model_x_portal();\n    }\n\n    this._portal2 = portal2;\n  }\n\n  knot_createClass(Knot, [{\n    key: "otherEnd",\n    value: function otherEnd(portal) {\n      if (portal === this._portal1) return this._portal2;else if (portal === this._portal2) return this._portal1;else return null;\n    } // Can a portal link to itself?\n\n  }, {\n    key: "removePortal",\n    value: function removePortal(portal) {\n      if (portal === this._portal1) this._portal1 = null;else if (portal === this._portal2) this._portal2 = null;\n    }\n  }, {\n    key: "id",\n    get: function get() {\n      return this._id;\n    }\n  }, {\n    key: "portal2",\n    get: function get() {\n      return this._portal2;\n    }\n  }, {\n    key: "portal1",\n    get: function get() {\n      return this._portal1;\n    }\n  }]);\n\n  return Knot;\n}();\n\n/* harmony default export */ var model_x_knot = (knot_Knot);\n// CONCATENATED MODULE: ./server/app/engine/game3d/model_x/model.js\n/**\n *\n */\n\n\nfunction model_toConsumableArray(arr) { return model_arrayWithoutHoles(arr) || model_iterableToArray(arr) || model_unsupportedIterableToArray(arr) || model_nonIterableSpread(); }\n\nfunction model_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction model_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return model_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return model_arrayLikeToArray(o, minLen); }\n\nfunction model_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction model_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return model_arrayLikeToArray(arr); }\n\nfunction model_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction model_x_model_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction model_x_model_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction model_x_model_createClass(Constructor, protoProps, staticProps) { if (protoProps) model_x_model_defineProperties(Constructor.prototype, protoProps); if (staticProps) model_x_model_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction model_x_model_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\nvar model_XModel = /*#__PURE__*/function () {\n  function XModel(game, worldModel) {\n    model_x_model_classCallCheck(this, XModel);\n\n    this._game = game;\n    this._worldModel = worldModel; // Database\n\n    this._knots = new Map();\n    this._portals = new Map(); // world id => [map: chunk id => set of portal ids]\n    // [OPT] optimize by sorting.\n\n    this._worldToChunksToPortals = new Map(); // Portal id => knots\n\n    this._portalsToKnots = new Map(); // Cached requests\n\n    this._cachedConnectivity = [new Map(), new Map()]; // WorldId+ChunkId -> portals ids.\n    // To update whenever avatar moves from one chunk to another.\n  }\n\n  model_x_model_createClass(XModel, [{\n    key: "addPortal",\n\n    /** Create / link **/\n    // One knows it must link parts of this knots before it opens...\n    // OtherPortalId: if null, spawns an empty portal; otherwise, links an existing portal and forge it into a knot.\n    value: function addPortal(worldId, x1, y1, z1, x2, y2, z2, offset, orientation, otherPortalId, createNewPortal) {\n      var world = this._worldModel.getWorld(worldId);\n\n      var portals = this._portals;\n      var worldToChunksToPortals = this._worldToChunksToPortals; // TODO [PORTAL] determine a free position\n      //while ((!world.isFree([x1, y1, z1]) || !world.isFree([x2, y2, z2])) && z2 < world.zSize) {\n      //    z1++; z2++;\n      //}\n      //if (z2 >= world.zSize) return;\n      // Check parameters.\n      // Orientation should be correct.\n      // if (orientation !== \'first\' && orientation !== \'next\') return;\n      // Portal must be orthogonal an axis: exactly one block coordinate in common.\n\n      var bx = x1 === x2;\n      var by = y1 === y2;\n      var bz = z1 === z2;\n      var sum = bx + by + bz;\n\n      if (sum !== 1 && sum !== 2) {\n        console.log("Portal not axis-aligned: ".concat(sum, "."));\n        return;\n      } // Portal minimal size.\n      // Check chunks.\n\n\n      var coords1 = world.getChunkCoordinates(x1, y1, z1);\n      var coords2 = world.getChunkCoordinates(x2, y2, z2); // Must be on one same chunk.\n      // XXX [PORTAL] manage portals sitting across chunks.\n\n      var chunk1 = world.getChunk.apply(world, model_toConsumableArray(coords1));\n      var chunk2 = world.getChunk.apply(world, model_toConsumableArray(coords2));\n      if (chunk1 && chunk1 !== chunk2) return;\n      var portalId = collections.generateId(portals);\n      var portal = new model_x_portal(worldId, portalId, [x1, y1, z1], [x2, y2, z2], offset, orientation, chunk1);\n      var chunkId = chunk1.chunkId;\n      portals.set(portalId, portal);\n      var wtpc = worldToChunksToPortals.get(worldId);\n      var ctpc;\n\n      if (wtpc) {\n        ctpc = wtpc.get(chunkId);\n\n        if (ctpc) {\n          ctpc.add(portalId);\n        } else {\n          ctpc = new Set();\n          ctpc.add(portalId);\n          wtpc.set(chunkId, ctpc);\n        }\n      } else {\n        wtpc = new Map();\n        ctpc = new Set();\n        ctpc.add(portalId);\n        wtpc.set(chunkId, ctpc);\n        worldToChunksToPortals.set(worldId, wtpc);\n      }\n\n      if (otherPortalId) {\n        this.addKnot(portalId, otherPortalId); // console.log(`world present ${otherPortalId}`);\n      } else if (createNewPortal) {\n        var newWorld = this._worldModel.addWorld();\n\n        if (!newWorld) {\n          console.log(\'Failed to create a new world.\');\n          return;\n        } // Force generation (1 chunk) and add portal.\n\n\n        var xS = newWorld.xSize;\n        var yS = newWorld.ySize;\n        var zS = newWorld.zSize;\n        var ijk = chunkId.split(\',\');\n        var newChunk = worldgenerator.generateInitialChunk.apply(worldgenerator, [xS, yS, zS].concat(model_toConsumableArray(ijk), [newWorld]));\n        newWorld.addChunk(newChunk.chunkId, newChunk);\n        this.addPortal(newWorld.worldId, x1, y1, z1, x2, y2, z2, offset, orientation, portalId);\n      }\n\n      this._cachedConnectivity = [new Map(), new Map()];\n      return portal;\n    } // (x1, y1, z1): first block\n    // (x2, y2, z2): second block\n    // position: percentage of block towards +\n    // orientation: \'+\', \'-\' or both.\n    // One does not know where this one will lead.\n\n  }, {\n    key: "addKnot",\n    value: function addKnot(portalId1, portalId2) {\n      var knots = this._knots;\n      var portals = this._portals;\n      var portalsToKnots = this._portalsToKnots; // Check portals.\n\n      var portal1 = portals.get(portalId1);\n      var portal2 = portals.get(portalId2);\n      if (!portal1) return; // Check already linked.\n\n      if (portalsToKnots.has(portalId1)) return;\n      if (portal2 && portalsToKnots.has(portalId2)) return; // Create knot & link portals.\n\n      var id = collections.generateId(knots);\n      var knot = new model_x_knot(id, portal1, portal2); // Create in model.\n\n      knots.set(id, knot);\n      portalsToKnots.set(knot.portal1.portalId, knot);\n      portalsToKnots.set(knot.portal2.portalId, knot);\n      return knot;\n    }\n    /** Remove **/\n\n  }, {\n    key: "removePortalFromPosition",\n    value: function removePortalFromPosition(worldId, x, y, z) {\n      // TODO [PORTAL] implement portal removal\n      console.log("Removing ".concat(x, ",").concat(y, ",").concat(z, " portal from ").concat(worldId, "."));\n    }\n  }, {\n    key: "removePortal",\n    value: function removePortal(portalId) {\n      // Unlink and remove portal.\n      var portalToKnots = this._portalsToKnots;\n      var portals = this._portals;\n      var portal = portals.get(portalId);\n      if (!portal) return;\n      var knot = portalToKnots.get(portalId);\n\n      if (knot) {\n        var otherEnd = knot.otherEnd(portal);\n        if (otherEnd) knot.removePortal(portal);else this._knots["delete"](otherEnd.portalId);\n        portalToKnots["delete"](portalId);\n      }\n\n      portals["delete"](portalId);\n      this._cachedConnectivity = [new Map(), new Map()];\n    }\n  }, {\n    key: "removeKnot",\n    value: function removeKnot(knotId) {\n      // Unlink portals.\n      var knots = this._knots;\n      var portalToKnots = this._portalsToKnots;\n      var knot = knots.get(knotId);\n\n      if (knot) {\n        var end1 = knot.portal1;\n        var end2 = knot.portal2;\n\n        if (end1) {\n          portalToKnots.remove(end1.portalId);\n        }\n\n        if (end2) {\n          portalToKnots.remove(end2.portalId);\n        }\n\n        knots.remove(knotId);\n      } // Invalidate cache.\n      // THOUGHT [OPTIM] think of a wiser invalidation method.\n\n\n      this._cachedConnectivity = [new Map(), new Map()];\n    }\n    /** Get **/\n\n  }, {\n    key: "getPortal",\n    value: function getPortal(portalId) {\n      portalId = parseInt(portalId, 10);\n      return this._portals.get(portalId);\n    }\n  }, {\n    key: "chunkContainsPortal",\n    value: function chunkContainsPortal(worldId, chunkId, portalId) {\n      worldId = parseInt(worldId, 10);\n\n      var ctp = this._worldToChunksToPortals.get(worldId);\n\n      if (!ctp) return false;\n      var p = ctp.get(chunkId);\n      if (!p) return false;\n      return p.has(portalId);\n    }\n  }, {\n    key: "getPortalsFromChunk",\n    value: function getPortalsFromChunk(worldId, chunkId) {\n      worldId = parseInt(worldId, 10);\n\n      var ctp = this._worldToChunksToPortals.get(worldId);\n\n      if (!ctp) return null;\n      return ctp.get(chunkId);\n    }\n  }, {\n    key: "getOtherSide",\n    value: function getOtherSide(portalId) {\n      portalId = parseInt(portalId, 10);\n\n      var p = this._portals.get(portalId);\n\n      if (!p) return;\n\n      var k = this._portalsToKnots.get(portalId);\n\n      if (!k) return;\n      return k.otherEnd(p);\n    } // Returns a Map portalId -> [otherEndId, otherWorldId]\n    // THOUGHT 1 [OPTIM] cache deepest request, then filter cached requests from then on\n    // THOUGHT 2 [OPTIM] optimize time with memory.\n    // Every time a portal is created, you add in an associative map\n    // coordinates of both linked chunks (order is important).\n    // Then you can compute offsets for two chunks in different worlds (just take\n    // min distance by considering all possible combinations of ways going through superposed chunks).\n    // A way to do it efficiently is to keep a Voronoi-like structure that emulate a geographical sorting of gates,\n    // along with a sorted list of distance further between any pair of 4D subworlds.\n    // Affectation can be solved by Munkres\' algorithm.\n\n  }, {\n    key: "getConnectivity",\n    value: function getConnectivity(startWid, startCid, wModel, thresh, force) {\n      var _this = this;\n\n      if (!force && this._portals.size < 1) return; // Quite often.\n      // Request cache.\n\n      var aggregate = "".concat(startWid, ";").concat(startCid, ";").concat(thresh);\n\n      var cached1 = this._cachedConnectivity[0].get(aggregate);\n\n      var cached2 = this._cachedConnectivity[1].get(aggregate);\n\n      if (cached1 && cached2) return [cached1, cached2];\n      var recursedPortals = new Map();\n      var recursedChunks = []; // BFS.\n\n      var marks = new Set();\n      var depth = 0;\n      var count = 0;\n      var stack = [[startWid, startCid, depth]];\n\n      var _loop = function _loop() {\n        var element = stack.shift();\n        var currentWorld = element[0];\n        var currentChunk = element[1];\n        var currentDepth = element[2];\n        var marksId = "".concat(currentWorld, ",").concat(currentChunk);\n        if (marks.has(marksId)) return "continue";\n        marks.add(marksId);\n        recursedChunks.push([currentWorld, currentChunk, currentDepth]);\n        count++;\n        depth = currentDepth; // let world = wModel.getWorld(currentWorld);\n\n        var ijk = currentChunk.split(\',\');\n        var i = parseInt(ijk[0], 10);\n        var j = parseInt(ijk[1], 10);\n        var k = parseInt(ijk[2], 10); // Manhattan loading.\n\n        var chksXY = ["".concat(i + 1, ",").concat(j, ",").concat(k), "".concat(i - 1, ",").concat(j, ",").concat(k), "".concat(i, ",").concat(j + 1, ",").concat(k), "".concat(i, ",").concat(j - 1, ",").concat(k)];\n        var chksZ = ["".concat(i, ",").concat(j, ",").concat(k + 1), "".concat(i, ",").concat(j, ",").concat(k - 1)]; // let chks = [\n        //     `${i + 1},${j},${k}`,  `${i - 1},${j},${k}`,\n        //     `${i},${j + 1},${k}`,  `${i},${j - 1},${k}`,\n        //     `${i},${j},${k + 1}`,  `${i},${j},${k - 1}`\n        //    // ((i+1)+\',\'+j+\',\'+k),  ((i-1)+\',\'+j+\',\'+k),\n        //    // (i+\',\'+(j+1)+\',\'+k),  (i+\',\'+(j-1)+\',\'+k),\n        //    // (i+\',\'+j+\',\'+(k+1)),  (i+\',\'+j+\',\'+(k-1))\n        // ];\n\n        var push = function push(chks, newDepth) {\n          return chks.forEach(function (c) {\n            if (!marks.has("".concat(currentWorld, ",").concat(c))) stack.push([currentWorld, c, newDepth]);\n          });\n        };\n\n        if (startWid !== currentWorld) {\n          push(chksXY, currentDepth + 2);\n          push(chksZ, currentDepth + 2);\n        } else // if (startWid === currentWorld)\n          {\n            var world = wModel.getWorld(currentWorld);\n\n            if (world && world.isFlat()) {\n              push(chksXY, currentDepth + 1);\n              push(chksZ, currentDepth + 2);\n            } else {\n              push(chksXY, currentDepth + 1);\n              push(chksZ, currentDepth + 1);\n            }\n          }\n\n        var gates = _this.getPortalsFromChunk(currentWorld, currentChunk);\n\n        if (gates) {\n          gates.forEach(function (g) {\n            var currentPortal = _this.getPortal(g);\n\n            var otherSide = _this.getOtherSide(g);\n\n            if (!otherSide) {\n              recursedPortals.set(g, [null, currentPortal.chunkId, currentPortal.worldId].concat(model_toConsumableArray(currentPortal.state)));\n            } else {\n              var otherChunk = otherSide.chunk;\n              if (XModel.debug) console.log("origin: world ".concat(currentPortal.worldId, ", portal ").concat(currentPortal.portalId));\n              if (XModel.debug) console.log("destin: world ".concat(otherSide.worldId, ", portal ").concat(otherSide.portalId));\n              recursedPortals.set(g, [otherSide.portalId, currentPortal.chunkId, currentPortal.worldId].concat(model_toConsumableArray(currentPortal.state)));\n\n              if (otherChunk) {\n                var otherWorld = otherChunk.world.worldId;\n                var otherChunkId = otherChunk.chunkId;\n                if (!marks.has("".concat(otherWorld, ",").concat(otherChunkId))) stack.push([otherWorld, otherChunkId, currentDepth + 1]);\n              }\n            }\n          });\n        } // Usually (always, I think) already sorted.\n        // But it\'s important to keep it sorted. Make sure.\n\n\n        stack.sort(function (a, b) {\n          return a[2] - b[2];\n        });\n      };\n\n      while (stack.length > 0 && depth < thresh) {\n        var _ret = _loop();\n\n        if (_ret === "continue") continue;\n      }\n\n      if (XModel.debug) console.log("".concat(count, " iterations on ").concat(startWid, "/").concat(startCid, "/").concat(thresh));\n\n      this._cachedConnectivity[0].set(aggregate, recursedPortals);\n\n      this._cachedConnectivity[1].set(aggregate, recursedChunks);\n\n      return [recursedPortals, recursedChunks];\n    }\n  }, {\n    key: "portals",\n    get: function get() {\n      return this._portals;\n    }\n  }, {\n    key: "worldToChunksToPortals",\n    get: function get() {\n      return this._worldToChunksToPortals;\n    }\n  }]);\n\n  return XModel;\n}();\n\nmodel_x_model_defineProperty(model_XModel, "debug", false);\n\n/* harmony default export */ var model_x_model = (model_XModel);\n// CONCATENATED MODULE: ./server/app/engine/game3d/model_consistency/model.js\n/**\n *\n */\n\n\nfunction model_consistency_model_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction model_consistency_model_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction model_consistency_model_createClass(Constructor, protoProps, staticProps) { if (protoProps) model_consistency_model_defineProperties(Constructor.prototype, protoProps); if (staticProps) model_consistency_model_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar model_ConsistencyModel = /*#__PURE__*/function () {\n  function ConsistencyModel(game) {\n    model_consistency_model_classCallCheck(this, ConsistencyModel);\n\n    // Model.\n    this._worldModel = game.worldModel;\n    this._entityModel = game.entityModel;\n    this._xModel = game.xModel; // Internals.\n\n    this._entityIdsForEntity = new Map();\n    this._chunkIdsForEntity = new Map();\n    this._chunkIdAndPartsForEntity = new Map();\n    this._xIdsForEntity = new Map();\n    this._partialXs = new Map();\n  }\n\n  model_consistency_model_createClass(ConsistencyModel, [{\n    key: "spawnPlayer",\n    value: function spawnPlayer(player) {\n      var playerId = parseInt(player.avatar.entityId, 10);\n      var chunksMap = new Map();\n      chunksMap.set(player.avatar.worldId, new Set());\n\n      this._entityIdsForEntity.set(playerId, new Set());\n\n      this._chunkIdsForEntity.set(playerId, chunksMap);\n\n      this._chunkIdAndPartsForEntity.set(playerId, new Map());\n\n      this._xIdsForEntity.set(playerId, new Set());\n\n      this._partialXs.set(playerId, new Set());\n    }\n  }, {\n    key: "removePlayer",\n    value: function removePlayer(playerId) {\n      playerId = parseInt(playerId, 10);\n\n      this._entityIdsForEntity["delete"](playerId);\n\n      this._chunkIdsForEntity["delete"](playerId);\n\n      this._chunkIdAndPartsForEntity["delete"](playerId);\n\n      this._xIdsForEntity["delete"](playerId);\n\n      this._partialXs["delete"](playerId);\n    }\n    /** Entity to chunks **/\n\n  }, {\n    key: "chunkIdsPerWorldForEntity",\n    value: function chunkIdsPerWorldForEntity(playerId) {\n      playerId = parseInt(playerId, 10);\n      return this._chunkIdsForEntity.get(playerId);\n    }\n  }, {\n    key: "hasWorld",\n    value: function hasWorld(playerId, worldId) {\n      playerId = parseInt(playerId, 10);\n      worldId = parseInt(worldId, 10);\n\n      var chunkIdsForEntity = this._chunkIdsForEntity.get(playerId);\n\n      return chunkIdsForEntity && chunkIdsForEntity.has(worldId);\n    }\n  }, {\n    key: "hasChunk",\n    value: function hasChunk(playerId, worldId, chunkId) {\n      playerId = parseInt(playerId, 10);\n      worldId = parseInt(worldId, 10);\n\n      var chunkIdsForEntityInWorld = this._chunkIdsForEntity.get(playerId).get(worldId);\n\n      return chunkIdsForEntityInWorld && chunkIdsForEntityInWorld.has(chunkId);\n    }\n  }, {\n    key: "setChunkLoaded",\n    value: function setChunkLoaded(playerId, worldId, chunkId) {\n      // Just in case.\n      playerId = parseInt(playerId, 10);\n      worldId = parseInt(worldId, 10);\n\n      var chunksForPlayer = this._chunkIdsForEntity.get(playerId);\n\n      if (chunksForPlayer.has(worldId)) {\n        chunksForPlayer.get(worldId).add(chunkId);\n      } else {\n        var s = new Set();\n        s.add(chunkId);\n        chunksForPlayer.set(worldId, s);\n      }\n    }\n  }, {\n    key: "setChunkOutOfRange",\n    value: function setChunkOutOfRange(playerId, worldId, chunkId) {\n      playerId = parseInt(playerId, 10);\n      worldId = parseInt(worldId, 10);\n\n      var chunksForPlayerInWorld = this._chunkIdsForEntity.get(playerId).get(worldId);\n\n      chunksForPlayerInWorld["delete"](chunkId);\n\n      if (chunksForPlayerInWorld.size < 1) {\n        this._chunkIdsForEntity.get(playerId)["delete"](worldId);\n      }\n    }\n  }, {\n    key: "doneChunkLoadingPhase",\n    value: function doneChunkLoadingPhase(player, starterChunk) {\n      var avatar = player.avatar;\n      var renderDistance = avatar.chunkRenderDistance;\n      var worldId = avatar.worldId;\n      var side = renderDistance * 2 + 1; // This only counts loaded chunks in the current world\n      // which is fine so far.\n\n      var aid = avatar.entityId;\n\n      var worlds = this._chunkIdsForEntity.get(aid);\n\n      var chunks = worlds.get(worldId);\n      if (!chunks) return false;\n      var actualInnerSize = 0;\n      var distance = math_geometry.infiniteNormDistance;\n      var sijk = starterChunk.chunkId.split(\',\');\n      chunks.forEach(function (chunkId) {\n        var ijk = chunkId.split(\',\');\n\n        if (distance(sijk, ijk) <= renderDistance) {\n          actualInnerSize++;\n        }\n      }); // This is not correct strictly speaking\n      // (a "side"-radius sphere in the 1-norm\n      // is not a "side"-sized square), but so far it does the job.\n\n      var expectedSize = side * side * side;\n      return expectedSize <= actualInnerSize;\n    }\n    /** Entity to entities **/\n\n  }, {\n    key: "hasEntity",\n    value: function hasEntity(playerId, entityId) {\n      return this._entityIdsForEntity.get(playerId).has(entityId);\n    }\n  }, {\n    key: "setEntityLoaded",\n    value: function setEntityLoaded(playerId, entityId) {\n      this._entityIdsForEntity.get(playerId).add(entityId);\n    }\n  }, {\n    key: "setEntityOutOfRange",\n    value: function setEntityOutOfRange(playerId, entityId) {\n      this._entityIdsForEntity.get(playerId)["delete"](entityId);\n    }\n    /** Entity to xs **/\n\n  }, {\n    key: "getXIdsForEntity",\n    value: function getXIdsForEntity(entityId) {\n      return this._xIdsForEntity.get(entityId);\n    } // Note: it would not have been wise to consider an x as an \'entity\'.\n    // ENHANCEMENT [LONG-TERM]: can an x move over time?\n\n  }, {\n    key: "hasX",\n    value: function hasX(playerId, xId) {\n      xId = parseInt(xId, 10);\n      return this._xIdsForEntity.get(playerId).has(xId);\n    }\n  }, {\n    key: "setXLoaded",\n    value: function setXLoaded(playerId, xId) {\n      xId = parseInt(xId, 10);\n\n      this._xIdsForEntity.get(playerId).add(xId);\n    }\n  }, {\n    key: "setXOutOfRange",\n    value: function setXOutOfRange(playerId, xId) {\n      xId = parseInt(xId, 10);\n\n      this._xIdsForEntity.get(playerId)["delete"](xId);\n    }\n  }, {\n    key: "setPartialX",\n    value: function setPartialX(playerId, xId) {\n      xId = parseInt(xId, 10);\n\n      this._partialXs.get(playerId).add(xId);\n    }\n  }, {\n    key: "unsetPartialX",\n    value: function unsetPartialX(playerId, xId) {\n      xId = parseInt(xId, 10);\n\n      this._partialXs.get(playerId)["delete"](xId);\n    }\n  }, {\n    key: "isPartialX",\n    value: function isPartialX(playerId, xId) {\n      xId = parseInt(xId, 10);\n\n      var p = this._partialXs.get(playerId);\n\n      if (!p) return false;\n      return p.has(xId);\n    }\n  }]);\n\n  return ConsistencyModel;\n}();\n\n/* harmony default export */ var model_consistency_model = (model_ConsistencyModel);\n// CONCATENATED MODULE: ./server/app/model/connection/chat.js\n/**\n *\n */\n\n\nfunction chat_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction chat_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction chat_createClass(Constructor, protoProps, staticProps) { if (protoProps) chat_defineProperties(Constructor.prototype, protoProps); if (staticProps) chat_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Chat = /*#__PURE__*/function () {\n  function Chat(game) {\n    chat_classCallCheck(this, Chat);\n\n    this._game = game;\n    this._temporaryMessages = [];\n  }\n\n  chat_createClass(Chat, [{\n    key: "log",\n    value: function log(message) {\n      console.log("On ".concat(this._game.gameId, ": ").concat(message));\n    }\n  }, {\n    key: "hasMessages",\n    value: function hasMessages() {\n      return this._temporaryMessages.length > 0;\n    }\n  }, {\n    key: "updateOutput",\n    value: function updateOutput() {\n      // XXX [CHAT] transmit updates to clients.\n      if (this.hasMessages()) {// broadcast(\'chat\', ...)\n      }\n    }\n    /**\n     * @param player\n     * A player knows its user (player.user)\n     * A user has an id (user.id)\n     * @returns {Function}\n     */\n\n  }, {\n    key: "playerInput",\n    value: function playerInput(player) {\n      var _this = this;\n\n      // XXX [CHAT] log input into temporaryMessages.\n      return function (data) {\n        // Important: don\'t send responses immediately on input.\n        // Store history of received messages in a temporary variable,\n        // then wait for server to call \'updateOutput\' method after it\n        // has finished rendering current game state.\n        _this.log("received message ".concat(data, " from ").concat(player.user.id));\n      };\n    }\n  }, {\n    key: "broadcast",\n    value: function broadcast(kind, data) {\n      var game = this._game;\n      game.connection.io.to(game.gameId).emit(kind, data);\n    }\n  }]);\n\n  return Chat;\n}();\n\n/* harmony default export */ var chat = (Chat);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/tile/random.js\n\n\nvar Random = function Random(textSeed) {\n  function xmur3(str) {\n    for (var i = 0, h = 1779033703 ^ str.length; i < str.length; i++) {\n      h = Math.imul(h ^ str.charCodeAt(i), 3432918353);\n      h = h << 13 | h >>> 19;\n    }\n\n    return function () {\n      h = Math.imul(h ^ h >>> 16, 2246822507);\n      h = Math.imul(h ^ h >>> 13, 3266489909);\n      return (h ^= h >>> 16) >>> 0;\n    };\n  }\n\n  function sfc32(a, b, c, d) {\n    return function () {\n      a >>>= 0;\n      b >>>= 0;\n      c >>>= 0;\n      d >>>= 0;\n      var t = a + b | 0;\n      a = b ^ b >>> 9;\n      b = c + (c << 3) | 0;\n      c = c << 21 | c >>> 11;\n      d = d + 1 | 0;\n      t = t + d | 0;\n      c = c + t | 0;\n      return (t >>> 0) / 4294967296;\n    };\n  }\n\n  var seed1 = xmur3("".concat(textSeed, "h2g2"));\n  var seed2 = xmur3("".concat(textSeed, "DouglasAdams"));\n  var seed3 = xmur3("".concat(textSeed, "42"));\n  var rand1 = sfc32(seed1(), seed1(), seed1(), seed1());\n  var rand2 = sfc32(seed2(), seed2(), seed2(), seed2());\n  var rand3 = sfc32(seed3(), seed3(), seed3(), seed3());\n  /**\n   * Uniform distribution generator.\n   * @returns uniform number in [0, 1]\n   */\n\n  this.uniform = function () {\n    return rand1();\n  };\n\n  this.random = this.uniform; // alias for simplex generator\n\n  /**\n   * Normal distribution generator.\n   * @returns number number in [-1, 1] (mean 0)\n   */\n\n  this.normal = function () {\n    var u = 0;\n    var v = 0;\n\n    while (u === 0) {\n      u = rand2();\n    }\n\n    while (v === 0) {\n      v = rand3();\n    }\n\n    var n = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);\n    n = n / 10.0 + 0.5;\n    if (n > 1 || n < 0) return this.normal();\n    return n * 2 - 1;\n  }; // this.rnorm = this.normal;\n\n\n  this.z2 = null;\n\n  this.rnorm = function () {\n    if (this.z2 !== null) {\n      var tmp = this.z2;\n      this.z2 = null;\n      return tmp;\n    }\n\n    var x1 = 0;\n    var x2 = 0;\n    var w = 2.0;\n\n    while (w >= 1) {\n      x1 = this.uniform() * 2 - 1; // runif(-1, 1);\n\n      x2 = this.uniform() * 2 - 1; // runif(-1, 1);\n\n      w = x1 * x1 + x2 * x2;\n    }\n\n    w = Math.sqrt(-2 * Math.log(w) / w);\n    this.z2 = x2 * w;\n    return x1 * w;\n  };\n\n  this.clamp = function (n, min, max) {\n    return Math.min(Math.max(n, min), max);\n  };\n};\n\nvar Sobol = function Sobol(dimension) {\n  var BITS = 52;\n  var SCALE = 1048576; // 2 << 51;\n\n  var COEFFICIENTS = [\'d       s       a       m_i\', \'2       1       0       1\', \'3       2       1       1 3\', \'4       3       1       1 3 1\', \'5       3       2       1 1 1\', \'6       4       1       1 1 3 3\', \'7       4       4       1 3 5 13\', \'8       5       2       1 1 5 5 17\', \'9       5       4       1 1 5 5 5\', \'10      5       7       1 1 7 11 1\'];\n  if (dimension < 1 || dimension > COEFFICIENTS.length) throw new Error(\'OOB\');\n  var tmp = [];\n  var direction = [];\n  var zee = [];\n  var x = [];\n  var lines = COEFFICIENTS;\n  var count = 0;\n  var i;\n  this.dimension = dimension;\n  this.count = count;\n\n  this.next = function () {\n    if (count === 0) {\n      count++;\n      return zee.slice();\n    }\n\n    var v = [];\n    var c = 1;\n    var value = count - 1;\n\n    while ((value & 1) === 1) {\n      value >>= 1;\n      c++;\n    }\n\n    for (i = 0; i < dimension; i++) {\n      x[i] ^= direction[i][c];\n      v[i] = x[i] / SCALE;\n    }\n\n    count++;\n    return v;\n  };\n\n  for (i = 0; i <= BITS; i++) {\n    tmp.push(0);\n  }\n\n  for (i = 0; i < dimension; i++) {\n    direction[i] = tmp.slice();\n    x[i] = 0;\n    zee[i] = 0;\n  }\n\n  for (i = 1; i <= BITS; i++) {\n    direction[0][i] = 1 << BITS - i;\n  }\n\n  for (var d = 1; d < dimension; d++) {\n    var cells = lines[d].split(/\\s+/);\n    var s = +cells[1];\n    var a = +cells[2];\n    var m = [0];\n\n    for (i = 0; i < s; i++) {\n      m.push(+cells[3 + i]);\n    }\n\n    for (i = 1; i <= s; i++) {\n      direction[d][i] = m[i] << BITS - i;\n    }\n\n    for (i = s + 1; i <= BITS; i++) {\n      direction[d][i] = direction[d][i - s] ^ direction[d][i - s] >> s;\n\n      for (var k = 1; k <= s - 1; k++) {\n        direction[d][i] ^= (a >> s - 1 - k & 1) * direction[d][i - k];\n      }\n    }\n  } // Skip first trivial sieving\n\n\n  this.rng = new Random(\'Sobol\');\n  var nbToSkip = Math.floor(10 + dimension * 10 * this.rng.uniform());\n\n  for (var j = 0; j < nbToSkip; ++j) {\n    this.next();\n  }\n\n  this.generate = function (num) {\n    var draws = [];\n\n    for (var _j = 0; _j < num; ++_j) {\n      draws.push(this.next());\n    }\n\n    return draws;\n  };\n};\n\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/tile/noise.js\n // THREEJS implementation,\n// Ported from Stefan Gustavson\'s java implementation\n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n// Read Stefan\'s excellent paper for details on how this code works.\n//\n// Sean McCullough banksean@gmail.com\n\nvar SimplexNoise = function SimplexNoise(r) {\n  if (r === undefined) r = Math;\n  this.grad3 = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]];\n  this.grad4 = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]];\n  this.p = [];\n\n  for (var i = 0; i < 256; i++) {\n    this.p[i] = Math.floor(r.random() * 256);\n  } // To remove the need for index wrapping, double the permutation table length\n\n\n  this.perm = [];\n\n  for (var _i = 0; _i < 512; _i++) {\n    this.perm[_i] = this.p[_i & 255];\n  } // A lookup table to traverse the simplex around a given point in 4D.\n  // Details can be found where this table is used, in the 4D noise method.\n\n\n  this.simplex = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]];\n  this.F2 = 0.5 * (Math.sqrt(3.0) - 1.0);\n  this.G2 = (3.0 - Math.sqrt(3.0)) / 6.0;\n};\n\nSimplexNoise.prototype.dot = function (g, x, y) {\n  return g[0] * x + g[1] * y;\n};\n\nSimplexNoise.prototype.dot3 = function (g, x, y, z) {\n  return g[0] * x + g[1] * y + g[2] * z;\n};\n\nSimplexNoise.prototype.dot4 = function (g, x, y, z, w) {\n  return g[0] * x + g[1] * y + g[2] * z + g[3] * w;\n};\n\nSimplexNoise.prototype.noise = function (xin, yin) {\n  var n0;\n  var n1;\n  var n2; // Noise contributions from the three corners\n  // Skew the input space to determine which simplex cell we\'re in\n\n  var F2 = this.F2;\n  var s = (xin + yin) * F2; // Hairy factor for 2D\n\n  var i = Math.floor(xin + s);\n  var j = Math.floor(yin + s);\n  var G2 = this.G2;\n  var t = (i + j) * G2;\n  var X0 = i - t; // Unskew the cell origin back to (x,y) space\n\n  var Y0 = j - t;\n  var x0 = xin - X0; // The x,y distances from the cell origin\n\n  var y0 = yin - Y0; // For the 2D case, the simplex shape is an equilateral triangle.\n  // Determine which simplex we are in.\n\n  var i1;\n  var j1; // Offsets for second (middle) corner of simplex in (i,j) coords\n\n  if (x0 > y0) {\n    // lower triangle, XY order: (0,0)->(1,0)->(1,1)\n    i1 = 1;\n    j1 = 0;\n  } else {\n    // upper triangle, YX order: (0,0)->(0,1)->(1,1)\n    i1 = 0;\n    j1 = 1;\n  } // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\n  // c = (3 - sqrt(3)) / 6\n\n\n  var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\n\n  var y1 = y0 - j1 + G2;\n  var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\n\n  var y2 = y0 - 1.0 + 2.0 * G2; // Work out the hashed gradient indices of the three simplex corners\n\n  var ii = i & 255;\n  var jj = j & 255;\n  var p = this.perm;\n  var g3 = this.grad3; // let gi0 = p[ii + p[jj]] % 12;\n  // let gi1 = p[ii + i1 + p[jj + j1]] % 12;\n  // let gi2 = p[ii + 1 + p[jj + 1]] % 12;\n  // Calculate the contribution from the three corners\n\n  var t0 = 0.5 - x0 * x0 - y0 * y0;\n  if (t0 < 0) n0 = 0.0;else {\n    t0 *= t0;\n    n0 = t0 * t0 * this.dot(g3[p[ii + p[jj]] % 12], x0, y0); // (x,y) of grad3 used for 2D gradient\n  }\n  var t1 = 0.5 - x1 * x1 - y1 * y1;\n  if (t1 < 0) n1 = 0.0;else {\n    t1 *= t1;\n    n1 = t1 * t1 * this.dot(g3[p[ii + i1 + p[jj + j1]] % 12], x1, y1);\n  }\n  var t2 = 0.5 - x2 * x2 - y2 * y2;\n  if (t2 < 0) n2 = 0.0;else {\n    t2 *= t2;\n    n2 = t2 * t2 * this.dot(g3[p[ii + 1 + p[jj + 1]] % 12], x2, y2);\n  } // Add contributions from each corner to get the final noise value.\n  // The result is scaled to return values in the interval [-1,1].\n\n  return 70.0 * (n0 + n1 + n2);\n};\n\nSimplexNoise.prototype.noise3d = function (xin, yin, zin) {\n  var n0;\n  var n1;\n  var n2;\n  var n3; // Noise contributions from the four corners\n  // Skew the input space to determine which simplex cell we\'re in\n\n  var F3 = 1.0 / 3.0;\n  var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D\n\n  var i = Math.floor(xin + s);\n  var j = Math.floor(yin + s);\n  var k = Math.floor(zin + s);\n  var G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too\n\n  var t = (i + j + k) * G3;\n  var X0 = i - t; // Unskew the cell origin back to (x,y,z) space\n\n  var Y0 = j - t;\n  var Z0 = k - t;\n  var x0 = xin - X0; // The x,y,z distances from the cell origin\n\n  var y0 = yin - Y0;\n  var z0 = zin - Z0; // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n  // Determine which simplex we are in.\n\n  var i1;\n  var j1;\n  var k1; // Offsets for second corner of simplex in (i,j,k) coords\n\n  var i2;\n  var j2;\n  var k2; // Offsets for third corner of simplex in (i,j,k) coords\n\n  if (x0 >= y0) {\n    if (y0 >= z0) {\n      // X Y Z order\n      i1 = 1;\n      j1 = 0;\n      k1 = 0;\n      i2 = 1;\n      j2 = 1;\n      k2 = 0;\n    } else if (x0 >= z0) {\n      // X Z Y order\n      i1 = 1;\n      j1 = 0;\n      k1 = 0;\n      i2 = 1;\n      j2 = 0;\n      k2 = 1;\n    } else {\n      // Z X Y order\n      i1 = 0;\n      j1 = 0;\n      k1 = 1;\n      i2 = 1;\n      j2 = 0;\n      k2 = 1;\n    }\n  } else // x0<y0\n    if (y0 < z0) {\n      // Z Y X order\n      i1 = 0;\n      j1 = 0;\n      k1 = 1;\n      i2 = 0;\n      j2 = 1;\n      k2 = 1;\n    } else if (x0 < z0) {\n      // Y Z X order\n      i1 = 0;\n      j1 = 1;\n      k1 = 0;\n      i2 = 0;\n      j2 = 1;\n      k2 = 1;\n    } else {\n      // Y X Z order\n      i1 = 0;\n      j1 = 1;\n      k1 = 0;\n      i2 = 1;\n      j2 = 1;\n      k2 = 0;\n    } // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\n  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\n  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\n  // c = 1/6.\n\n\n  var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\n\n  var y1 = y0 - j1 + G3;\n  var z1 = z0 - k1 + G3;\n  var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords\n\n  var y2 = y0 - j2 + 2.0 * G3;\n  var z2 = z0 - k2 + 2.0 * G3;\n  var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords\n\n  var y3 = y0 - 1.0 + 3.0 * G3;\n  var z3 = z0 - 1.0 + 3.0 * G3; // Work out the hashed gradient indices of the four simplex corners\n\n  var ii = i & 255;\n  var jj = j & 255;\n  var kk = k & 255;\n  var gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;\n  var gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;\n  var gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;\n  var gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12; // Calculate the contribution from the four corners\n\n  var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\n  if (t0 < 0) n0 = 0.0;else {\n    t0 *= t0;\n    n0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0);\n  }\n  var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\n  if (t1 < 0) n1 = 0.0;else {\n    t1 *= t1;\n    n1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1);\n  }\n  var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\n  if (t2 < 0) n2 = 0.0;else {\n    t2 *= t2;\n    n2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2);\n  }\n  var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\n  if (t3 < 0) n3 = 0.0;else {\n    t3 *= t3;\n    n3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3);\n  } // Add contributions from each corner to get the final noise value.\n  // The result is scaled to stay just inside [-1,1]\n\n  return 32.0 * (n0 + n1 + n2 + n3);\n};\n\nvar TileablePerlinNoise = function TileablePerlinNoise(r) {\n  this.r = r;\n  if (!this.r) this.r = Math;\n  this.p = [];\n\n  for (var i = 0; i < 256; i++) {\n    this.p[i] = Math.floor(this.r.random() * 256);\n  }\n\n  this.perm = [];\n\n  for (var _i2 = 0; _i2 < 512; _i2++) {\n    this.perm[_i2] = this.p[_i2 & 255];\n  }\n\n  this.dirs = [];\n  var pi2256 = 2.0 * Math.PI / 256;\n\n  for (var _i3 = 0; _i3 < 256; _i3++) {\n    this.dirs[_i3] = [Math.cos(_i3 * pi2256), Math.sin(_i3 * pi2256)];\n  }\n};\n\nTileablePerlinNoise.prototype.surflet = function (x, y, gridX, gridY, per) {\n  var distX = Math.abs(x - gridX);\n  var distY = Math.abs(y - gridY);\n  var polyX = 1 - distX * distX * distX * (distX * (distX * 6 - 15) + 10);\n  var polyY = 1 - distY * distY * distY * (distY * (distY * 6 - 15) + 10);\n  var p = this.perm;\n  var d = this.dirs;\n  var hashed = p[(p[gridX % per] + gridY) % per]; // if (!d[hashed]) debugger;\n\n  var grad = (x - gridX) * d[hashed][0] + (y - gridY) * d[hashed][1];\n  return polyX * polyY * grad;\n};\n\nTileablePerlinNoise.prototype.noise = function (x, y, per) {\n  var intX = x >> 0;\n  var intY = y >> 0;\n  var v = 0;\n  v += this.surflet(x, y, intX, intY, per);\n  v += this.surflet(x, y, intX + 1, intY, per);\n  v += this.surflet(x, y, intX, intY + 1, per);\n  v += this.surflet(x, y, intX + 1, intY + 1, per);\n  return v;\n};\n\nTileablePerlinNoise.prototype.sumOctaves = function (x, y, nbOctaves, per) {\n  var v = 0;\n  var q = 32;\n\n  for (var i = 0; i < nbOctaves; ++i) {\n    v += 1 / q * this.noise(x * q, y * q, per * q);\n    q *= 2;\n  }\n\n  return v;\n};\n\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/tile/pixel.js\n\n\n\n\n\nvar CHUNK_TREES = Object.freeze({\n  NO_TREES: 0,\n  LIGHT: 1,\n  DENSE: 2,\n  FULL: 3\n});\n\nvar pixel_Rasterizer = function Rasterizer(dimension) {\n  this.dimension = dimension || 512;\n  this.chunkHeight = 16;\n  this.chunkWidth = 16;\n  this.heightBuffer = [];\n  this.surfaceBuffer = [];\n  this.treeDensities = []; // this.chunkBiomes = [];\n\n  this.rng2 = null;\n  this.noiseTile = [];\n  this.noiseTileDimension = 256;\n  this.noiseTileReady = false;\n  this.rng = new Random(\'simplex\');\n  this.tpng = new TileablePerlinNoise(this.rng);\n  this.zBuffer = [];\n  this.zPassBuffer = []; // Progressive\n\n  this.step = -1;\n  this.currentTriangle = 0; // current rasterized triangle\n\n  this.heightPassDone = false;\n};\n\npixel_Rasterizer.prototype.setNoiseTile = function (noiseTile) {\n  var td = this.noiseTileDimension;\n\n  if (noiseTile.length !== td * td) {\n    throw Error(\'[Rasterizer] Noise tile dimension mismatch.\');\n  }\n\n  if (!(noiseTile instanceof Float32Array)) {\n    throw Error(\'[Rasterizer] Noise tile type mismatch.\');\n  }\n\n  this.noiseTile = noiseTile;\n  this.noiseTileReady = true;\n};\n\npixel_Rasterizer.prototype.resetBuffers = function (size) {\n  if (this.zBuffer.length !== size) this.zBuffer = new Float64Array(size);else this.zBuffer.fill(0);\n  if (this.zPassBuffer.length !== size) this.zPassBuffer = new Uint8Array(size);else this.zPassBuffer.fill(0);\n};\n\npixel_Rasterizer.prototype.computeTriMesh = function (mesh, tile) {\n  // let pts = mesh.pts;\n  var tris = mesh.tris;\n  var tidx = mesh.triPointIndexes;\n  var values = tile.buffer;\n  var nbInteriorTris = mesh.nbInteriorTris;\n  var triMesh = [];\n  this.resetBuffers(mesh.nbTriPointIndexes); // Prevent GC\n\n  var z = this.zBuffer; // new Float64Array(mesh.nbTriPointIndexes);\n\n  var zPass = this.zPassBuffer; // new Uint8Array(mesh.nbTriPointIndexes);\n  // Compute point heights\n\n  for (var i = 0; i < tris.length; ++i) {\n    var t = tris[i]; // let v = i >= nbInteriorTris ? -0.01 : values[i];\n\n    var v = values[i];\n\n    if (i >= nbInteriorTris) {// console.log(values[i]);\n    }\n\n    if (t.length !== 3) continue;\n    var ti = tidx[i];\n\n    for (var j = 0; j < 3; ++j) {\n      var index = ti[j]; // let p = t[j];\n\n      if (!z[index]) {\n        z[index] = v;\n        zPass[index] = 1;\n      } else {\n        var ov = z[index];\n\n        if (Math.sign(v) !== Math.sign(ov)) {\n          z[index] = Math.min(ov, v);\n          zPass[index] = 1;\n        } else {\n          z[index] = ov + v;\n          zPass[index] += 1;\n        }\n      }\n\n      z[index] += v;\n      zPass[index]++;\n    }\n  } // for (let i = 0; i < z.length; ++i)\n  // {\n  //     let count = zPass[i];\n  //     if (count < 1) continue;\n  //     z[i] /= count;\n  // }\n  // Compute 3D tris\n\n\n  for (var _i = 0; _i < tris.length; ++_i) {\n    var _t = tris[_i];\n    if (_t.length !== 3) continue;\n    var _ti = tidx[_i];\n    var newTri = []; // let v = values[i];\n\n    for (var _j = 0; _j < 3; ++_j) {\n      var p = _t[_j];\n      var x = p[0];\n      var y = p[1]; // let index = `${x.toFixed(5)},${y.toFixed(5)}`;\n\n      var _index = _ti[_j];\n      var height = z[_index] / zPass[_index];\n      newTri.push([x, y, height]);\n    }\n\n    triMesh.push(newTri);\n  }\n\n  return triMesh;\n};\n\npixel_Rasterizer.prototype.putPixel = function (x, y, v) {\n  var buffer = this.surfaceBuffer;\n  var w = this.dimension;\n  buffer[y * w + x] = v;\n}; // https://en.wikipedia.org/wiki/Midpoint_circle_algorithm\n// Algorithm from Eric Andres, Discrete circles, rings and spheres\n\n\npixel_Rasterizer.prototype.drawCircle = function (centerX, centerY, radius) {\n  var x;\n  var y;\n  var d;\n  x = 0;\n  y = radius;\n  d = radius - 1;\n  var v = 2;\n\n  while (y >= x) {\n    this.putPixel(centerX + x, centerY + y, v);\n    this.putPixel(centerX + y, centerY + x, v);\n    this.putPixel(centerX - x, centerY + y, v);\n    this.putPixel(centerX - y, centerY + x, v);\n    this.putPixel(centerX + x, centerY - y, v);\n    this.putPixel(centerX + y, centerY - x, v);\n    this.putPixel(centerX - x, centerY - y, v);\n    this.putPixel(centerX - y, centerY - x, v);\n\n    if (d >= 2 * x) {\n      d -= 2 * x + 1;\n      ++x;\n    } else if (d < 2 * (radius - y)) {\n      d += 2 * y - 1;\n      --y;\n    } else {\n      d += 2 * (y - x - 1);\n      --y;\n      ++x;\n    }\n  }\n}; // from https://github.com/delphifirst/js-rasterizer\n// 2016 Yang Cao\n\n\npixel_Rasterizer.prototype.drawTriangle = function (v1h0, v1h1, v1h2, v2h0, v2h1, v2h2, v3h0, v3h1, v3h2) {\n  var minX = Math.min(v1h0, v2h0, v3h0);\n  var maxX = Math.max(v1h0, v2h0, v3h0);\n  var minY = Math.min(v1h1, v2h1, v3h1);\n  var maxY = Math.max(v1h1, v2h1, v3h1);\n  var dx12 = v1h1 - v2h1;\n  var dy12 = v2h0 - v1h0;\n  var dz12 = v1h0 * v2h1 - v2h0 * v1h1;\n  var dx23 = v2h1 - v3h1;\n  var dy23 = v3h0 - v2h0;\n  var dz23 = v2h0 * v3h1 - v3h0 * v2h1;\n  var dx31 = v3h1 - v1h1;\n  var dy31 = v1h0 - v3h0;\n  var dz31 = v3h0 * v1h1 - v1h0 * v3h1;\n  var startY = Math.floor(minY);\n  var startX = Math.floor(minX);\n  var endY = Math.ceil(maxY);\n  var endX = Math.ceil(maxX);\n  var alphaDen = dx23 * v1h0 + dy23 * v1h1 + dz23;\n  var betaDen = dx31 * v2h0 + dy31 * v2h1 + dz31;\n  var gammaDen = dx12 * v3h0 + dy12 * v3h1 + dz12;\n  var width = this.dimension;\n  var hb = this.heightBuffer;\n\n  for (var y = startY; y <= endY; ++y) {\n    var offset = width * y;\n\n    for (var x = startX; x <= endX; ++x) {\n      var alpha = (dx23 * x + dy23 * y + dz23) / alphaDen;\n      var beta = (dx31 * x + dy31 * y + dz31) / betaDen;\n      var gamma = (dx12 * x + dy12 * y + dz12) / gammaDen;\n\n      if (alpha > 0 && beta > 0 && gamma > 0) {\n        // const h = 255 * (alpha * v1h2 + beta * v2h2 + gamma * v3h2);\n        // if (h < 0) h = 255;\n        // hb[offset + x] = h;\n        hb[offset + x] = 255 * (alpha * v1h2 + beta * v2h2 + gamma * v3h2);\n      }\n    }\n  }\n};\n\npixel_Rasterizer.prototype.initBuffers = function () {\n  var width = this.dimension;\n  var height = this.dimension;\n  this.heightBuffer = new Int32Array(width * height);\n  this.surfaceBuffer = new Uint8Array(width * height);\n};\n\npixel_Rasterizer.prototype.heightPass = function (triMesh) {\n  var width = this.dimension;\n  var height = this.dimension;\n  var start = math_time["a" /* default */].getTimeSecMillis();\n  var nbTris = triMesh.length;\n  var startTri = this.currentTriangle;\n\n  for (var i = startTri; i < nbTris; ++i) {\n    var t = triMesh[i];\n    if (t.length !== 3) continue;\n    this.drawTriangle((0.5 + t[0][0]) * width - 0.5, (0.5 + t[0][1]) * height - 0.5, t[0][2], (0.5 + t[1][0]) * width - 0.5, (0.5 + t[1][1]) * height - 0.5, t[1][2], (0.5 + t[2][0]) * width - 0.5, (0.5 + t[2][1]) * height - 0.5, t[2][2]);\n\n    if (i === nbTris - 1) {\n      this.heightPassDone = true;\n      this.currentTriangle = 0; // console.log(this.heightBuffer);\n\n      return;\n    } else {\n      var current = math_time["a" /* default */].getTimeSecMillis();\n      var delta = current - start;\n\n      if (i - startTri > 1000 && delta > 8) {\n        this.currentTriangle = i + 1;\n        return;\n      }\n    }\n  }\n}; // XXX [GENERATION] lower this noise frequency\n\n\npixel_Rasterizer.prototype.precomputeNoiseTile = function (nbOctaves) {\n  // Noise tile = 256\n  var height = this.noiseTileDimension;\n  var width = this.noiseTileDimension;\n  var tpng = this.tpng;\n  this.noiseTile = new Float32Array(width * height);\n  var buffer = this.noiseTile;\n  var freq = 1 / 256;\n  var wf = width * freq >> 0;\n\n  for (var y = 0; y < height; ++y) {\n    var offset = width * y;\n\n    for (var x = 0; x < width; ++x) {\n      buffer[offset + x] = tpng.sumOctaves(x * freq, y * freq, nbOctaves, wf);\n    }\n  } // Normalize\n\n\n  var min = Infinity;\n  var max = -Infinity;\n\n  for (var i = 0; i < buffer.length; ++i) {\n    var bi = buffer[i];\n    if (bi > max) max = bi;\n    if (bi < min) min = bi;\n  }\n\n  var range = max - min;\n\n  for (var _i2 = 0; _i2 < buffer.length; ++_i2) {\n    buffer[_i2] = (buffer[_i2] - min) / range;\n  }\n\n  this.noiseTileReady = true;\n};\n\npixel_Rasterizer.prototype.noisePass = function (factor) {\n  if (!this.noiseTileReady) {\n    this.precomputeNoiseTile(5);\n  }\n\n  if (this.dimension % this.noiseTileDimension !== 0) {\n    throw Error(\'Map dimension must be a multiple of the noise kernel dimension.\');\n  }\n\n  var buffer = this.heightBuffer;\n  var pattern = this.noiseTile;\n  var height = this.dimension;\n  var heightN = this.noiseTileDimension;\n  var width = this.dimension;\n  var widthN = this.noiseTileDimension;\n\n  for (var y = 0; y < height; ++y) {\n    var offset = width * y;\n    var offsetNoise = widthN * (y % heightN);\n\n    for (var x = 0; x < width; ++x) {\n      var b = buffer[offset + x];\n      if (b < 0) continue;\n      buffer[offset + x] = b - factor * pattern[offsetNoise + x % widthN];\n    }\n  }\n}; // Should be on the overlay and decrease water height.\n\n\npixel_Rasterizer.prototype.riverPass = function (rivers) {\n  var width = this.dimension;\n  var height = this.dimension;\n  var nbRivers = rivers.length;\n  var riverHalfWidth = 8;\n  var riverDepth = -10 / 256; // let hb = this.heightBuffer;\n\n  for (var i = 0; i < nbRivers; ++i) {\n    var r = rivers[i];\n    var nbSegments = r.length - 1;\n\n    for (var j = 0; j < nbSegments; ++j) {\n      var p1 = r[j];\n      var p2 = r[j + 1];\n      var x1 = (0.5 + p1[0]) * width;\n      var y1 = (0.5 + p1[1]) * height;\n      var x2 = (0.5 + p2[0]) * width;\n      var y2 = (0.5 + p2[1]) * height;\n      var x = x2 - x1;\n      var y = y2 - y1;\n      var norm = Math.sqrt(x * x + y * y);\n      var nvx = riverHalfWidth * x / norm;\n      var nvy = riverHalfWidth * y / norm;\n      x1 -= 0.1 * norm * x;\n      x2 += 0.1 * norm * x;\n      y1 -= 0.1 * norm * y;\n      y2 += 0.1 * norm * y;\n      var clockwiseX = nvy;\n      var clockwiseY = -nvx;\n      var counterClockwiseX = -nvy;\n      var counterClockwiseY = nvx; // Rectangle 1 (clockwise)\n\n      var upx1 = clockwiseX + x1;\n      var upy1 = clockwiseY + y1;\n      var upx2 = clockwiseX + x2;\n      var upy2 = clockwiseY + y2;\n      var h1 = 1 / 255; // hb[width * Math.floor(upy1) + Math.floor(upx1)] / 255;\n\n      this.drawTriangle(x1, y1, riverDepth, x2, y2, riverDepth, upx1, upy1, h1);\n      this.drawTriangle(x2, y2, riverDepth, upx1, upy1, h1, upx2, upy2, 1 / 255 // hb[width * Math.floor(upy2) + Math.floor(upx2)] / 255,\n      ); // Rectangle 2 (counterclockwise)\n\n      var dnx1 = counterClockwiseX + x1;\n      var dny1 = counterClockwiseY + y1;\n      var dnx2 = counterClockwiseX + x2;\n      var dny2 = counterClockwiseY + y2;\n      var h2 = 1 / 255; // hb[width * Math.floor(dny1) + Math.floor(dnx1)] / 255;\n\n      this.drawTriangle(x1, y1, riverDepth, x2, y2, riverDepth, dnx1, dny1, h2);\n      this.drawTriangle(x2, y2, riverDepth, dnx1, dny1, h2, dnx2, dny2, 1 / 255 // hb[width * Math.floor(dny2) + Math.floor(dnx2)] / 255,\n      );\n    }\n  }\n};\n\npixel_Rasterizer.prototype.drawCity = function (cityX, cityY, cityRadius) {\n  this.drawCircle(cityX, cityY, cityRadius);\n  this.drawCircle(cityX, cityY, cityRadius - 1);\n  this.drawCircle(cityX, cityY, cityRadius - 2); // XXX [GENERATION] voronoi (inner walls); inside of cities with buildings\n};\n\npixel_Rasterizer.prototype.cityPass = function (mesh, cities) {\n  var nbCities = cities.length;\n  var width = this.dimension;\n  var height = this.dimension;\n  var tris = mesh.tris;\n\n  for (var i = 0; i < nbCities; ++i) {\n    var c = cities[i]; // City center\n\n    var t = tris[c];\n    var cX = 0;\n    var cY = 0;\n    var l = t.length;\n    if (l !== 2 && l !== 3) console.warn("Uncommon tri length: ".concat(l, "."));\n\n    for (var j = 0; j < l; ++j) {\n      cX += t[j][0];\n      cY += t[j][1];\n    }\n\n    cX /= l;\n    cY /= l; // City draw\n\n    var cityRadius = i < 5 ? 30 : 15; // nb blocks\n\n    var centerX = (0.5 + cX) * width - 0.5 >> 0;\n    var centerY = (0.5 + cY) * height - 0.5 >> 0;\n    this.drawCity(centerX, centerY, cityRadius);\n  }\n};\n\npixel_Rasterizer.prototype.seedChunkRandom = function (seed) {\n  this.rng2 = new Random(seed);\n};\n\npixel_Rasterizer.prototype.computeChunkTreeDensity = function () {\n  var nbChunksX = this.dimension / this.chunkHeight;\n  var nbChunksY = this.dimension / this.chunkWidth;\n  var densityLength = nbChunksX * nbChunksY;\n  this.treeDensities = new Uint8Array(densityLength);\n  var td = this.treeDensities;\n  var rng2 = this.rng2;\n\n  for (var i = 0; i < densityLength; ++i) {\n    var r = rng2.uniform();\n\n    if (r > 0.99) {\n      td[i] = CHUNK_TREES.FULL;\n    } else if (r > 0.9) {\n      td[i] = CHUNK_TREES.DENSE;\n    } else if (r > 0.5) {\n      td[i] = CHUNK_TREES.LIGHT;\n    } else {\n      td[i] = CHUNK_TREES.NONE;\n    }\n  }\n};\n\npixel_Rasterizer.prototype.fillTrees = function (chunkI, chunkJ, nbTrees) {\n  var chunkHeight = this.chunkHeight;\n  var chunkWidth = this.chunkWidth;\n  var xStart = chunkI * chunkHeight; // const xEnd = xStart + 16;\n\n  var yStart = chunkJ * chunkWidth; // const yEnd = yStart + 16;\n\n  var w = this.dimension;\n  var rng = this.rng2;\n  var sb = this.surfaceBuffer; // XXX [GENERATION] jitter sampling\n\n  for (var i = 0; i < nbTrees; ++i) {\n    // never on a chunk border.\n    var x = xStart + Math.floor(1 + rng.uniform() * (chunkWidth - 1));\n    var y = yStart + Math.floor(1 + rng.uniform() * (chunkHeight - 1));\n    sb[x * w + y] = 1; // only plant stump\n  }\n}; // XXX [GENERATION] combine with height and voronoi\n\n\npixel_Rasterizer.prototype.treePass = function () {\n  var nbChunksX = this.dimension / 16;\n  var nbChunksY = this.dimension / 16;\n  var td = this.treeDensities;\n  var c = 0;\n\n  for (var j = 0; j < nbChunksY; ++j) {\n    for (var i = 0; i < nbChunksX; ++i) {\n      switch (td[c]) {\n        case CHUNK_TREES.NONE:\n          break;\n\n        case CHUNK_TREES.FULL:\n          this.fillTrees(i, j, 15);\n          break;\n\n        case CHUNK_TREES.DENSE:\n          this.fillTrees(i, j, 5);\n          break;\n\n        case CHUNK_TREES.LIGHT:\n          this.fillTrees(i, j, 2);\n          break;\n      }\n\n      ++c;\n    }\n  }\n};\n\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/d3math/max.js\n\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = max_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }\n\nfunction max_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return max_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return max_arrayLikeToArray(o, minLen); }\n\nfunction max_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction max_max(values, valueof) {\n  var maximum;\n\n  if (valueof === undefined) {\n    var _iterator = _createForOfIteratorHelper(values),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var value = _step.value;\n\n        if (value !== null && ( // eslint-disable-next-line no-self-compare\n        maximum < value || maximum === undefined && value >= value)) {\n          maximum = value;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else {\n    var index = -1;\n\n    var _iterator2 = _createForOfIteratorHelper(values),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _value = _step2.value;\n\n        if ((_value = valueof(_value, ++index, values)) !== null && ( // eslint-disable-next-line no-self-compare\n        maximum < _value || maximum === undefined && _value >= _value)) {\n          maximum = _value;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return maximum;\n}\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/d3math/min.js\n\n\nfunction min_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = min_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }\n\nfunction min_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return min_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return min_arrayLikeToArray(o, minLen); }\n\nfunction min_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction min_min(values, valueof) {\n  var minimum;\n\n  if (valueof === undefined) {\n    var _iterator = min_createForOfIteratorHelper(values),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var value = _step.value;\n\n        if (value !== null && ( // eslint-disable-next-line no-self-compare\n        minimum > value || minimum === undefined && value >= value)) {\n          minimum = value;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else {\n    var index = -1;\n\n    var _iterator2 = min_createForOfIteratorHelper(values),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _value = _step2.value;\n\n        if ((_value = valueof(_value, ++index, values)) !== null && ( // eslint-disable-next-line no-self-compare\n        minimum > _value || minimum === undefined && _value >= _value)) {\n          minimum = _value;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return minimum;\n}\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/d3math/ascending.js\n\n\n/* harmony default export */ var ascending = (function (a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n});\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/d3math/quickselect.js\n\n\n // Based on https://github.com/mourner/quickselect\n// ISC license, Copyright 2018 Vladimir Agafonkin.\n\nfunction quickselect(array, k) {\n  var left = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var right = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : array.length - 1;\n  var compare = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ascending;\n\n  while (right > left) {\n    if (right - left > 600) {\n      var n = right - left + 1;\n      var m = k - left + 1;\n      var z = Math.log(n);\n      var s = 0.5 * Math.exp(2 * z / 3);\n      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n      var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n      var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n      quickselect(array, k, newLeft, newRight, compare);\n    }\n\n    var t = array[k];\n    var i = left;\n    var j = right;\n    swap(array, left, k);\n    if (compare(array[right], t) > 0) swap(array, left, right);\n\n    while (i < j) {\n      swap(array, i, j);\n      ++i;\n      --j;\n\n      while (compare(array[i], t) < 0) {\n        ++i;\n      }\n\n      while (compare(array[j], t) > 0) {\n        --j;\n      }\n    }\n\n    if (compare(array[left], t) === 0) swap(array, left, j);else {\n      ++j;\n      swap(array, j, right);\n    }\n    if (j <= k) left = j + 1;\n    if (k <= j) right = j - 1;\n  }\n\n  return array;\n}\n\nfunction swap(array, i, j) {\n  var t = array[i];\n  array[i] = array[j];\n  array[j] = t;\n}\n// EXTERNAL MODULE: ./node_modules/regenerator-runtime/runtime.js\nvar runtime = __webpack_require__(71);\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/d3math/number.js\n\n\nvar _marked = /*#__PURE__*/regeneratorRuntime.mark(numbers);\n\nfunction number_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = number_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }\n\nfunction number_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return number_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return number_arrayLikeToArray(o, minLen); }\n\nfunction number_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n/* harmony default export */ var number = (function (x) {\n  return x === null ? NaN : +x;\n});\nfunction numbers(values, valueof) {\n  var _iterator, _step, value, index, _iterator2, _step2, _value;\n\n  return regeneratorRuntime.wrap(function numbers$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!(valueof === undefined)) {\n            _context.next = 21;\n            break;\n          }\n\n          _iterator = number_createForOfIteratorHelper(values);\n          _context.prev = 2;\n\n          _iterator.s();\n\n        case 4:\n          if ((_step = _iterator.n()).done) {\n            _context.next = 11;\n            break;\n          }\n\n          value = _step.value;\n\n          if (!(value !== null && (value = +value) >= value)) {\n            _context.next = 9;\n            break;\n          }\n\n          _context.next = 9;\n          return value;\n\n        case 9:\n          _context.next = 4;\n          break;\n\n        case 11:\n          _context.next = 16;\n          break;\n\n        case 13:\n          _context.prev = 13;\n          _context.t0 = _context["catch"](2);\n\n          _iterator.e(_context.t0);\n\n        case 16:\n          _context.prev = 16;\n\n          _iterator.f();\n\n          return _context.finish(16);\n\n        case 19:\n          _context.next = 40;\n          break;\n\n        case 21:\n          index = -1;\n          _iterator2 = number_createForOfIteratorHelper(values);\n          _context.prev = 23;\n\n          _iterator2.s();\n\n        case 25:\n          if ((_step2 = _iterator2.n()).done) {\n            _context.next = 32;\n            break;\n          }\n\n          _value = _step2.value;\n\n          if (!((_value = valueof(_value, ++index, values)) !== null && (_value = +_value) >= _value)) {\n            _context.next = 30;\n            break;\n          }\n\n          _context.next = 30;\n          return _value;\n\n        case 30:\n          _context.next = 25;\n          break;\n\n        case 32:\n          _context.next = 37;\n          break;\n\n        case 34:\n          _context.prev = 34;\n          _context.t1 = _context["catch"](23);\n\n          _iterator2.e(_context.t1);\n\n        case 37:\n          _context.prev = 37;\n\n          _iterator2.f();\n\n          return _context.finish(37);\n\n        case 40:\n        case "end":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[2, 13, 16, 19], [23, 34, 37, 40]]);\n}\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/d3math/quantile.js\n\n\n\n\n\n\nfunction quantile(values, p) {\n  var n;\n  if (!(n = values.length)) return;\n  if ((p = +p) <= 0 || n < 2) return min_min(values);\n  if (p >= 1) return max_max(values);\n  var i = (n - 1) * p;\n  var i0 = Math.floor(i);\n  var value0 = max_max(quickselect(values, i0).subarray(0, i0 + 1));\n  var value1 = min_min(values.subarray(i0 + 1));\n  return value0 + (value1 - value0) * (i - i0);\n}\nfunction quantileSorted(values, p) {\n  var valueof = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : number;\n  var n;\n  if (!(n = values.length)) return;\n  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);\n  if (p >= 1) return +valueof(values[n - 1], n - 1, values);\n  var i = (n - 1) * p;\n  var i0 = Math.floor(i);\n  var value0 = +valueof(values[i0], i0, values);\n  var value1 = +valueof(values[i0 + 1], i0 + 1, values);\n  return value0 + (value1 - value0) * (i - i0);\n}\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/math.js\n // Math util functions\n\n\nvar d3quantile = quantile;\n\nfunction quantile2(mesh, q) {\n  var h = mesh.buffer;\n  var hl = h.length;\n  var sortedh = new Float64Array(hl);\n\n  for (var i = 0; i < hl; i++) {\n    sortedh[i] = h[i];\n  }\n\n  sortedh.sort(); // ascending\n\n  return d3quantile(sortedh, q);\n}\n\nfunction mean(indexArray, array) {\n  var l = indexArray.length;\n  var m = 0;\n  var n = 0;\n\n  for (var i = 0; i < l; ++i) {\n    m += array[indexArray[i]];\n    ++n;\n  }\n\n  return m / n;\n}\n\nfunction math_min(array) {\n  var m = Infinity;\n\n  for (var i = 0, l = array.length, v; i < l; ++i) {\n    if ((v = array[i]) < m) m = v;\n  }\n\n  return m;\n}\n\nfunction math_max(array) {\n  var m = -Infinity;\n\n  for (var i = 0, l = array.length, v; i < l; ++i) {\n    if ((v = array[i]) > m) m = v;\n  }\n\n  return m;\n}\n\nfunction maxArg(array) {\n  var m = -Infinity;\n  var maxIndex = 0;\n\n  for (var i = 1, l = array.length, v; i < l; ++i) {\n    if ((v = array[i]) > m) {\n      m = v;\n      maxIndex = i;\n    }\n  }\n\n  return maxIndex;\n}\n\nfunction minArg(array, compare) {\n  var minValue = Infinity;\n  var minIndex = 0;\n\n  for (var i = 1, l = array.length, value; i < l; ++i) {\n    value = array[i];\n\n    if (minIndex === 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {\n      minValue = value;\n      minIndex = i;\n    }\n  }\n\n  return minIndex;\n}\n\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/tile/modifier.js\n\n\n\n\n\nvar modifier_FieldModifier = function FieldModifier(mesher, seed) {\n  if (!mesher) throw Error(\'Invalid argument\');\n  this.buffer = [];\n  seed = seed || \'rough\';\n  this.randomGenerator = new Random(seed);\n  this.mesher = mesher;\n  this.nbMountains = 0;\n};\n\nmodifier_FieldModifier.prototype.resetBuffer = function (newBufferLength) {\n  if (this.buffer.length !== newBufferLength) this.buffer = new Float64Array(newBufferLength);else this.buffer.fill(0);\n};\n\nmodifier_FieldModifier.prototype.swapBuffers = function (otherObject) {\n  var tempBuffer = this.buffer;\n  this.buffer = otherObject.buffer;\n  otherObject.buffer = tempBuffer;\n};\n\nmodifier_FieldModifier.prototype.addScalar = function (mesh, buffer, scalar) {\n  for (var i = 0, l = buffer.length; i < l; i++) {\n    buffer[i] += scalar;\n  }\n};\n\nmodifier_FieldModifier.prototype.apply1D = function (mesh, buffer, mapper1D) {\n  for (var i = 0, l = buffer.length; i < l; i++) {\n    var b = buffer[i];\n    buffer[i] = mapper1D(b);\n  }\n};\n\nmodifier_FieldModifier.prototype.apply2D = function (mesh, buffer, mapper2D) {\n  var vxs = mesh.vxs;\n\n  for (var i = 0, l = vxs.length, v; i < l; i++) {\n    v = vxs[i];\n    buffer[i] = mapper2D(v);\n  }\n};\n\nmodifier_FieldModifier.prototype.addSlope = function (mesh, buffer, tileX, tileY) {\n  var vxs = mesh.vxs;\n  var cx = tileX % 2 === 0 ? 0.5 : -0.5;\n  var cy = tileY % 2 === 0 ? 0.5 : -0.5;\n\n  for (var i = 0, l = vxs.length, v; i < l; i++) {\n    v = vxs[i];\n    buffer[i] += Math.sqrt(Math.pow(v[0] - cx, 2) + Math.pow(v[1] - cy, 2));\n  }\n};\n\nmodifier_FieldModifier.prototype.addCone = function (mesh, buffer, slope) {\n  this.apply2D(mesh, buffer, function (v) {\n    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2)) * slope;\n  });\n};\n\nmodifier_FieldModifier.prototype.resetField = function (mesh) {\n  var buffer = mesh.buffer;\n\n  for (var i = 0, l = buffer.length; i < l; ++i) {\n    buffer[i] = 0;\n  }\n};\n\nmodifier_FieldModifier.prototype.addMountains = function (mesh, buffer, n, r) {\n  var rng = this.randomGenerator;\n  r = r || 0.05;\n  var mounts = [];\n\n  for (var i = 0; i < n; i++) {\n    var r1 = rng.uniform();\n    var r2 = rng.uniform();\n    mounts.push([mesh.extent.width * (r1 - 0.5) * 0.85, mesh.extent.height * (r2 - 0.5) * 0.85]);\n  }\n\n  var vxs = mesh.vxs;\n  var r22 = 1 / (2 * r * r);\n  var vl = vxs.length;\n\n  for (var _i = 0; _i < vl; _i++) {\n    var p = vxs[_i];\n    var px = p[0];\n    var py = p[1];\n\n    for (var j = 0; j < n; j++) {\n      var m = mounts[j];\n      var dx = px - m[0];\n      var dy = py - m[1];\n      buffer[_i] += Math.pow(Math.exp(-(Math.pow(dx, 2) + Math.pow(dy, 2)) * r22), 2);\n    }\n  }\n\n  this.nbMountains += n;\n};\n\nmodifier_FieldModifier.prototype.normalize = function (mesh, buffer) {\n  var lo = math_min(buffer);\n  var hi = math_max(buffer);\n  this.apply1D(mesh, buffer, function (x) {\n    return (x - lo) / (hi - lo);\n  });\n};\n\nmodifier_FieldModifier.prototype.peaky = function (mesh, buffer) {\n  this.normalize(mesh, buffer);\n  this.apply1D(mesh, buffer, Math.sqrt);\n};\n\nmodifier_FieldModifier.prototype.relax = function (mesh, tile) {\n  var mesher = this.mesher;\n  var field = tile.buffer;\n  var length = field.length;\n  this.resetBuffer(length);\n  var newh = this.buffer;\n\n  for (var i = 0; i < length; i++) {\n    var nbs = mesher.neighbours(mesh, i);\n\n    if (nbs.length < 3) {\n      newh[i] = field[i];\n      continue;\n    }\n\n    newh[i] = mean(nbs, field);\n  }\n\n  this.swapBuffers(tile);\n};\n\nmodifier_FieldModifier.prototype.setSeaLevel = function (mesh, buffer) // , q)\n{\n  // let delta = quantile2(mesh, q);\n  // console.log(delta);\n  var delta = 0.3;\n  this.addScalar(mesh, buffer, -delta);\n};\n\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/tile/erosion.js\n\n\n\n\nvar EROSION_STEPS = Object.freeze({\n  WAITING: -1,\n  ERODING: 3,\n  FILLING_SINKS: 4,\n  READY: 5,\n  GETTING_FLUX: 0,\n  GETTING_SLOPE: 1,\n  COMPUTING_RATE: 2\n});\n\nvar Eroder = function Eroder(mesher) {\n  if (!mesher) throw Error(\'Invalid argument\'); // this._indexBuffer = [];\n\n  this.buffer = [];\n  this.fluxBuffer = [];\n  this.slopeBuffer = [];\n  this.indexBuffer = [];\n  this.downhillBuffer = [];\n  this.mesher = mesher; // Progressive\n\n  this.amount = 0;\n  this.step = -1;\n  this.erosionPass = 0; // current erosion iteration\n  // this.fillSinksPass = 0; // current filling sinks iteration\n\n  this.doneFillingSinks = false;\n  this.isFillingSinks = false;\n  this.cleanCoastPass = 0;\n  this.cleanCoastPStep = 0;\n  this.doAllAtOnce = false;\n};\n\nEroder.prototype.setErosionAmount = function (amount) {\n  this.amount = amount;\n};\n\nEroder.prototype.stepErosion = function (mesh, tile, n) {\n  var amount = this.amount;\n\n  switch (this.step) {\n    case EROSION_STEPS.WAITING:\n      this.fillSinks(mesh, tile); // First sink fill\n\n      if (this.doneFillingSinks) this.step = EROSION_STEPS.ERODING;\n      break;\n\n    case EROSION_STEPS.FILLING_SINKS:\n      this.fillSinks(mesh, tile);\n\n      if (this.doneFillingSinks) {\n        this.erosionPass++;\n        if (this.erosionPass >= n) this.step = EROSION_STEPS.READY;else this.step = EROSION_STEPS.ERODING;\n      }\n\n      break;\n\n    case EROSION_STEPS.ERODING:\n      this.erode(mesh, tile, amount);\n      this.doneFillingSinks = false;\n      this.isFillingSinks = false;\n      this.step = EROSION_STEPS.FILLING_SINKS;\n      break;\n\n    case EROSION_STEPS.READY:\n      this.doneFillingSinks = false;\n      this.isFillingSinks = false;\n      this.ready = true;\n  }\n};\n\nEroder.prototype.doErosion = function (mesh, tile, amount, n) {\n  n = n || 1;\n  this.fillSinks(mesh, tile);\n\n  for (var i = 0; i < n; i++) {\n    this.erode(mesh, amount);\n    this.fillSinks(mesh, tile);\n  }\n};\n\nEroder.prototype.resetDownhillBuffer = function (newBufferLength) {\n  if (this.downhillBuffer.length !== newBufferLength) this.downhillBuffer = new Int32Array(newBufferLength);else this.downhillBuffer.fill(0);\n};\n\nEroder.prototype.resetSlopeBuffer = function (newBufferLength) {\n  if (this.slopeBuffer.length !== newBufferLength) this.slopeBuffer = new Float64Array(newBufferLength);else this.slopeBuffer.fill(0);\n};\n\nEroder.prototype.resetFluxBuffer = function (newBufferLength) {\n  if (this.fluxBuffer.length !== newBufferLength) this.fluxBuffer = new Float64Array(newBufferLength);else this.fluxBuffer.fill(0);\n};\n\nEroder.prototype.resetIndexBuffer = function (newBufferLength) {\n  if (this.indexBuffer.length !== newBufferLength) this.indexBuffer = new Float64Array(newBufferLength);else this.indexBuffer.fill(0);\n};\n\nEroder.prototype.resetBuffer = function (newBufferLength) {\n  if (this.buffer.length !== newBufferLength) this.buffer = new Float64Array(newBufferLength);else this.buffer.fill(0);\n};\n\nEroder.prototype.swapBuffers = function (otherObject) {\n  var tempBuffer = this.buffer;\n  this.buffer = otherObject.buffer;\n  otherObject.buffer = tempBuffer;\n};\n\nEroder.prototype.downhill = function (mesh, tile) {\n  var nbTris = tile.buffer.length;\n  this.resetDownhillBuffer(nbTris);\n  var downs = this.downhillBuffer;\n\n  for (var i = 0; i < nbTris; i++) {\n    downs[i] = this.downfrom(mesh, tile, i);\n  }\n\n  return downs;\n};\n\nEroder.prototype.downfrom = function (mesh, tile, i) {\n  var mesher = this.mesher;\n  if (mesher.isedge(mesh, i)) return -2;\n  var h = tile.buffer;\n  var best = -1;\n  var besth = h[i];\n  var nbs = mesher.neighbours(mesh, i);\n\n  for (var j = 0, l = nbs.length; j < l; j++) {\n    var b = nbs[j];\n    var hb = h[b];\n\n    if (hb < besth) {\n      besth = hb;\n      best = b;\n    }\n  }\n\n  return best;\n};\n\nEroder.prototype.topologicalFill = function (mesh, tile) {\n  var mesher = this.mesher;\n  var h = tile.buffer;\n  var hl = h.length;\n  var swiper = [];\n\n  for (var i = 0; i < hl; ++i) {\n    var nbs = mesher.neighbours(mesh, i);\n    var nbl = nbs.length;\n\n    if (nbl < 3) {\n      continue;\n    }\n\n    var hi = h[i];\n\n    if (h[nbs[0]] > hi && h[nbs[1]] > hi && h[nbs[2]] > hi) {\n      swiper.push(i);\n    }\n  }\n\n  var eps = 1e-5;\n\n  while (swiper.length) {\n    var _i = swiper.pop();\n\n    var _nbs = mesher.neighbours(mesh, _i);\n\n    var j0 = _nbs[0];\n    var hj0 = h[j0];\n    var j1 = _nbs[1];\n    var hj1 = h[j1];\n    var j2 = _nbs[2];\n    var hj2 = h[j2];\n    var min = void 0; // let minJ;\n\n    if (hj0 <= hj1 && hj0 <= hj2) {\n      min = hj0; // minJ = j0;\n    } else if (hj1 <= hj0 && hj1 <= hj2) {\n      min = hj1; // minJ = j1;\n    } else {\n      min = hj2; // minJ = j2;\n    }\n\n    h[_i] = min + eps; // eps += 1e-9; // for fast approximate erosion\n\n    var nbs2 = mesher.neighbours(mesh, j0);\n    if (nbs2.length === 3 && h[nbs2[0]] > hj0 && h[nbs2[1]] > hj0 && h[nbs2[2]] > hj0) swiper.push(j0);\n    nbs2 = mesher.neighbours(mesh, j1);\n    if (nbs2.length === 3 && h[nbs2[0]] > hj1 && h[nbs2[1]] > hj1 && h[nbs2[2]] > hj1) swiper.push(j1);\n    nbs2 = mesher.neighbours(mesh, j2);\n    if (nbs2.length === 3 && h[nbs2[0]] > hj2 && h[nbs2[1]] > hj2 && h[nbs2[2]] > hj2) swiper.push(j2);\n  }\n};\n\nEroder.prototype.fillSinks = function (mesh, tile, epsilon) {\n  var mesher = this.mesher;\n  var h = tile.buffer;\n  epsilon = epsilon || 1e-5; // let infinity = 999999;\n\n  var hl = h.length;\n  var newh;\n\n  if (!this.isFillingSinks) {\n    this.resetBuffer(hl);\n    newh = this.buffer;\n\n    for (var i = 0; i < hl; ++i) {\n      if (mesher.isnearedge(mesh, i)) {\n        newh[i] = h[i];\n      } else {\n        newh[i] = Infinity;\n      }\n    }\n\n    this.isFillingSinks = true;\n  }\n\n  newh = this.buffer; // Reduce iteration number (not worth it)\n  // let hh = this._indexBuffer;\n  // if (hh.length < hl) {\n  //     this._indexBuffer = new Float64Array(hl);\n  //     hh = this._indexBuffer;\n  // }\n  // for (let i = 0; i < hl; ++i)\n  //     hh[i] = Math.floor((1 + h[i]) * 10000000000) * 100000 + i;\n  // hh.sort();\n  // for (let i = 0; i < hl; ++i) hh[i] %= 100000;\n\n  var performQueue = this.doAllAtOnce;\n\n  if (performQueue) {\n    // const ts1 = window.performance.now();\n    this.topologicalFill(mesh, tile); // const ts2 = window.performance.now();\n    // console.log(`BFS: ${Math.floor((ts2 - ts1) * 1000)} ns.`);\n\n    return;\n  }\n\n  var start = math_time["a" /* default */].getTimeSecMillis();\n  var changed = false;\n  var oh; // let iterations = 0;\n\n  while (true) {\n    // ++iterations;\n    changed = false;\n\n    for (var ii = 0; ii < hl; ++ii) {\n      var _i2 = ii;\n      var hi = h[_i2];\n      if (newh[_i2] === hi) continue;\n      var nbs = mesher.neighbours(mesh, _i2);\n      var nbl = nbs.length;\n\n      for (var j = 0; j < nbl; j++) {\n        oh = newh[nbs[j]] + epsilon;\n\n        if (hi >= oh) {\n          newh[_i2] = hi;\n          changed = true;\n          break;\n        } else if (newh[_i2] > oh) {\n          newh[_i2] = oh;\n          changed = true;\n        }\n      }\n    }\n\n    if (!changed) {\n      // console.log(iterations);\n      this.doneFillingSinks = true;\n      this.isFillingSinks = false;\n      this.swapBuffers(tile);\n      return;\n    } else {\n      var current = math_time["a" /* default */].getTimeSecMillis();\n      var delta = current - start;\n      if (delta > 8) return; // console.log(delta);\n    }\n  }\n};\n\nEroder.prototype.getFlux = function (mesh, tile) {\n  var dh = this.downhill(mesh, tile);\n  var nbTris = tile.buffer.length;\n  this.resetIndexBuffer(nbTris);\n  this.resetFluxBuffer(nbTris);\n  var idxs = this.indexBuffer;\n  var flux = this.fluxBuffer;\n  var h = tile.buffer;\n  var hl = h.length;\n  var hlInv = 1 / hl;\n\n  for (var i = 0; i < hl; ++i) {\n    // idxs[i] = i;\n    idxs[i] = Math.floor((1 + h[i]) * 10000000000) * 100000 + i;\n    flux[i] = hlInv;\n  }\n\n  idxs.sort();\n\n  for (var _i3 = 0; _i3 < hl; ++_i3) {\n    idxs[_i3] %= 100000;\n  } // idxs.sort((a, b) => {\n  //     return h[b] - h[a];\n  // });\n\n\n  for (var _i4 = 0; _i4 < hl; _i4++) {\n    // const j = idxs[i];\n    var j = idxs[hl - 1 - _i4];\n    var dhj = dh[j];\n\n    if (dhj >= 0) {\n      flux[dhj] += flux[j];\n    }\n  }\n\n  return flux;\n};\n\nEroder.prototype.trislope = function (mesh, tile, i) {\n  var nbs = this.mesher.neighbours(mesh, i);\n  if (nbs.length !== 3) return [0, 0];\n  var p0 = mesh.vxs[nbs[0]];\n  var p1 = mesh.vxs[nbs[1]];\n  var p2 = mesh.vxs[nbs[2]];\n  var x1 = p1[0] - p0[0];\n  var x2 = p2[0] - p0[0];\n  var y1 = p1[1] - p0[1];\n  var y2 = p2[1] - p0[1];\n  var det = x1 * y2 - x2 * y1;\n  var h = tile.buffer;\n  var h1 = h[nbs[1]] - h[nbs[0]];\n  var h2 = h[nbs[2]] - h[nbs[0]];\n  return [(y2 * h1 - y1 * h2) / det, (-x2 * h1 + x1 * h2) / det];\n};\n\nEroder.prototype.getSlope = function (mesh, tile) {\n  // let dh = downhill(h);\n  // let slope = zero(h.mesh);\n  this.resetSlopeBuffer(tile.buffer.length);\n  var slope = this.slopeBuffer;\n  var h = tile.buffer;\n\n  for (var i = 0; i < h.length; i++) {\n    var s = this.trislope(mesh, tile, i);\n    slope[i] = Math.sqrt(s[0] * s[0] + s[1] * s[1]); // continue;\n    // if (dh[i] < 0) {\n    //     slope[i] = 0;\n    // } else {\n    //     slope[i] = (h[i] - h[dh[i]]) / distance(h.mesh, i, dh[i]);\n    // }\n  }\n\n  return slope;\n};\n\nEroder.prototype.erosionRate = function (mesh, tile) {\n  var flux = this.getFlux(mesh, tile); // flux buffer\n\n  var slope = this.getSlope(mesh, tile); // slope buffer\n\n  var nbTris = tile.buffer.length;\n  this.resetBuffer(nbTris); // this.buffer\n\n  var newh = this.buffer;\n\n  for (var i = 0; i < nbTris; i++) {\n    var river = Math.sqrt(flux[i]) * slope[i];\n    var creep = slope[i] * slope[i];\n    var total = 1000 * river + creep;\n    total = total > 200 ? 200 : total;\n    newh[i] = total;\n  }\n\n  return newh;\n};\n\nEroder.prototype.erode = function (mesh, tile, amount) {\n  var h = tile.buffer;\n  var er = this.erosionRate(mesh, tile); // this.buffer\n\n  var maxr = math_max(er);\n  var c = amount / maxr;\n  var hl = h.length;\n\n  for (var i = 0; i < hl; i++) {\n    h[i] = h[i] - c * er[i];\n  }\n};\n\nEroder.prototype.cleanCoastP1 = function (mesh, tile) {\n  var mesher = this.mesher;\n  var h = tile.buffer;\n  var nbTris = h.length;\n  var newh;\n  this.resetBuffer(nbTris);\n  newh = this.buffer;\n  h = tile.buffer;\n\n  for (var i = 0; i < h.length; i++) {\n    newh[i] = h[i];\n    var nbs = mesher.neighbours(mesh, i);\n    if (h[i] <= 0 || nbs.length !== 3) continue;\n    var count = 0;\n    var best = -999999;\n\n    for (var j = 0; j < nbs.length; j++) {\n      var hnbsj = h[nbs[j]];\n\n      if (hnbsj > 0) {\n        count++;\n      } else if (hnbsj > best) {\n        best = hnbsj;\n      }\n    }\n\n    if (count > 1) continue;\n    newh[i] = best / 2;\n  }\n\n  this.swapBuffers(tile);\n};\n\nEroder.prototype.cleanCoastP2 = function (mesh, tile) {\n  var mesher = this.mesher;\n  var h = tile.buffer;\n  var nbTris = h.length;\n  var newh;\n  this.resetBuffer(nbTris);\n  newh = this.buffer;\n  h = tile.buffer;\n\n  for (var i = 0; i < h.length; i++) {\n    newh[i] = h[i];\n    var nbs = mesher.neighbours(mesh, i);\n    if (h[i] > 0 || nbs.length !== 3) continue;\n    var count = 0;\n    var best = 999999;\n\n    for (var j = 0; j < nbs.length; j++) {\n      var hnbsj = h[nbs[j]];\n\n      if (hnbsj <= 0) {\n        count++;\n      } else if (hnbsj < best) {\n        best = hnbsj;\n      }\n    }\n\n    if (count > 1) continue;\n    newh[i] = best / 2;\n  }\n\n  this.swapBuffers(tile);\n};\n\nEroder.prototype.cleanCoast = function (mesh, tile) {\n  if (this.cleanCoastPStep === 0) {\n    var start = math_time["a" /* default */].getTimeSecMillis();\n    this.cleanCoastP1(mesh, tile);\n    var current = math_time["a" /* default */].getTimeSecMillis();\n    var delta = current - start;\n\n    if (delta < 6) {\n      this.cleanCoastP2(mesh, tile);\n      this.cleanCoastPass++;\n    } else {\n      this.cleanCoastPStep = 1;\n    }\n  } else if (this.cleanCoastPStep === 1) {\n    this.cleanCoastP2(mesh, tile);\n    this.cleanCoastPass++;\n    this.cleanCoastPStep = 0;\n  }\n};\n\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/tile/cities.js\n\n\n\n\nvar CityPlacer = function CityPlacer(mesher, fieldModifier, eroder) {\n  if (!mesher || !fieldModifier || !eroder) throw Error(\'Invalid argument\');\n  this.buffer = [];\n  this.fluxBuffer = [];\n  this.mesher = mesher;\n  this.fieldModifier = fieldModifier;\n  this.eroder = eroder;\n  this.nbCities = 0;\n};\n\nCityPlacer.prototype.resetBuffer = function (newBufferLength) {\n  if (this.buffer.length !== newBufferLength) this.buffer = new Float64Array(newBufferLength);else this.buffer.fill(0);\n};\n\nCityPlacer.prototype.resetFluxBuffer = function (newBufferLength) {\n  if (this.fluxBuffer.length !== newBufferLength) this.fluxBuffer = new Float64Array(newBufferLength);else this.fluxBuffer.fill(0);\n};\n\nCityPlacer.prototype.copyBuffer = function (source, destination) {\n  if (source.length !== destination.length) throw Error(\'[CityPlacer] Invalid buffer lengths.\');\n  var l = source.length;\n\n  for (var i = 0; i < l; ++i) {\n    destination[i] = source[i];\n  }\n};\n\nCityPlacer.prototype.cityScore = function (mesh, tile, cities) {\n  var eroder = this.eroder;\n  var mesher = this.mesher;\n  var fieldModifier = this.fieldModifier;\n  var h = tile.buffer;\n  this.resetBuffer(h.length);\n\n  if (this.fluxBuffer.length !== h.length) {\n    this.resetFluxBuffer(h.length);\n    var oldFlux = this.fluxBuffer;\n    this.fluxBuffer = eroder.getFlux(mesh, tile);\n    eroder.fluxBuffer = oldFlux;\n  }\n\n  this.copyBuffer(this.fluxBuffer, this.buffer); // let oldBuffer = this.buffer;\n  // this.buffer = eroder.getFlux(mesh); // swap\n  // eroder.fluxBuffer = oldBuffer;\n\n  fieldModifier.apply1D(mesh, this.buffer, Math.sqrt); // let score = applyTransform(getFlux(h), Math.sqrt);\n\n  var score = this.buffer;\n  var mew2 = mesh.extent.width / 2;\n  var meh2 = mesh.extent.height / 2;\n\n  for (var i = 0; i < h.length; i++) {\n    if (h[i] <= 0 || mesher.isnearedge(mesh, i)) {\n      score[i] = -999999;\n      continue;\n    }\n\n    score[i] += 0.01 / (1e-9 + Math.abs(mesh.vxs[i][0]) - mew2);\n    score[i] += 0.01 / (1e-9 + Math.abs(mesh.vxs[i][1]) - meh2);\n\n    for (var j = 0; j < cities.length; j++) {\n      score[i] -= 0.02 / (mesher.distance(mesh, cities[j], i) + 1e-9);\n    }\n  }\n\n  return score;\n};\n\nCityPlacer.prototype.placeCity = function (country, tile) {\n  country.cities = country.cities || [];\n  var score = this.cityScore(country.mesh, tile, country.cities);\n  var newcity = maxArg(score);\n  country.cities.push(newcity);\n  this.nbCities++;\n};\n\nCityPlacer.prototype.placeCities = function (country, tile, n) {\n  // let params = country.params;\n  // let n = params.ncities;\n  for (var i = 0; i < n; i++) {\n    this.placeCity(country, tile);\n  }\n};\n\nCityPlacer.prototype.getRivers = function (mesh, tile, limit) {\n  var eroder = this.eroder;\n  var mesher = this.mesher;\n  var dh = eroder.downhill(mesh, tile);\n  var h = tile.buffer;\n  var vxs = mesh.vxs;\n  var flux;\n  if (this.fluxBuffer.length === h.length) flux = this.fluxBuffer;else flux = eroder.getFlux(mesh, tile);\n  var links = [];\n  var above = 0;\n  var hl = h.length;\n\n  for (var i = 0; i < hl; i++) {\n    if (h[i] > 0) above++;\n  }\n\n  limit *= above / hl;\n  var dhl = dh.length;\n  var mwidth = mesh.extent.width;\n  var mheight = mesh.extent.height;\n\n  for (var _i = 0; _i < dhl; _i++) {\n    var up = vxs[_i];\n    if (mesher.inef(up, mwidth, mheight)) continue;\n    var dhi = dh[_i];\n    var hi = h[_i];\n    var fi = flux[_i];\n\n    if (fi > limit && hi > 0 && dhi >= 0) {\n      var down = vxs[dhi];\n\n      if (h[dhi] > 0) {\n        links.push([up, down]);\n      } else {\n        links.push([up, [(up[0] + down[0]) / 2, (up[1] + down[1]) / 2]]);\n      }\n    }\n  }\n\n  return mesher.mergeSegments(links).map(this.relaxPath);\n}; // Example: topological computation of territories.\n\n\nCityPlacer.prototype.getTerritories = function (country) {\n  var eroder = this.eroder;\n  var mesher = this.mesher;\n  var mesh = country.mesh;\n  var h = mesh.buffer;\n  var cities = country.cities;\n  var n = country.params.nterrs;\n  if (n > country.cities.length) n = country.cities.length;\n  var flux = eroder.getFlux(mesh);\n  var terr = [];\n  var queue = {\n    queue: function queue() {},\n    dequeue: function dequeue() {}\n  }; // new PriorityQueue({comparator(a, b) {return a.score - b.score;}});\n\n  function weight(u, v) {\n    var horiz = mesher.distance(mesh, u, v);\n    var vert = h[v] - h[u];\n    if (vert > 0) vert /= 10;\n    var diff = 1 + 0.25 * Math.pow(vert / horiz, 2);\n    diff += 100 * Math.sqrt(flux[u]);\n    if (h[u] <= 0) diff = 100;\n    if (h[u] > 0 !== h[v] > 0) return 1000;\n    return horiz * diff;\n  }\n\n  for (var i = 0; i < n; i++) {\n    terr[cities[i]] = cities[i];\n    var nbs = mesher.neighbours(mesh, cities[i]);\n\n    for (var j = 0; j < nbs.length; j++) {\n      queue.queue({\n        score: weight(cities[i], nbs[j]),\n        city: cities[i],\n        vx: nbs[j]\n      });\n    }\n  }\n\n  while (queue.length) {\n    var u = queue.dequeue();\n    if (terr[u.vx] !== undefined) continue;\n    terr[u.vx] = u.city;\n\n    var _nbs = mesher.neighbours(mesh, u.vx);\n\n    for (var _i2 = 0; _i2 < _nbs.length; _i2++) {\n      var v = _nbs[_i2];\n      if (terr[v] !== undefined) continue;\n      var newdist = weight(u.vx, v);\n      queue.queue({\n        score: u.score + newdist,\n        city: u.city,\n        vx: v\n      });\n    }\n  } // terr.mesh = h.mesh;\n\n\n  return terr;\n};\n\nCityPlacer.prototype.getBorders = function (country) {\n  var mesher = this.mesher;\n  var terr = country.terr;\n  var mesh = country.mesh;\n  var meshEdges = mesh.edges;\n  var h = mesh.buffer;\n  var edges = [];\n\n  for (var i = 0; i < meshEdges.length; i++) {\n    var e = meshEdges[i];\n    if (e[3] === undefined) continue;\n    if (mesher.isnearedge(mesh, e[0]) || mesher.isnearedge(mesh, e[1])) continue;\n    if (h[e[0]] < 0 || h[e[1]] < 0) continue;\n\n    if (terr[e[0]] !== terr[e[1]]) {\n      edges.push([e[2], e[3]]);\n    }\n  }\n\n  return mesher.mergeSegments(edges).map(this.relaxPath);\n};\n\nCityPlacer.prototype.relaxPath = function (path) {\n  var newpath = [path[0]];\n\n  for (var i = 1; i < path.length - 1; i++) {\n    var newpt = [0.25 * path[i - 1][0] + 0.5 * path[i][0] + 0.25 * path[i + 1][0], 0.25 * path[i - 1][1] + 0.5 * path[i][1] + 0.25 * path[i + 1][1]];\n    newpath.push(newpt);\n  }\n\n  newpath.push(path[path.length - 1]);\n  return newpath;\n}; // XXX [GENERATION] City wards.\n\n\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/tile/terrain.js\n\n\n\n\nvar terrain_TerrainGenerator = function TerrainGenerator(mesher, fieldModifier, eroder, seed) {\n  if (!mesher || !fieldModifier || !eroder) throw Error(\'Invalid argument\');\n  this.buffer = [];\n  seed = seed || \'terrain\';\n  this.randomGenerator = new Random(seed);\n  this.mesher = mesher;\n  this.fieldModifier = fieldModifier;\n  this.eroder = eroder;\n};\n\nterrain_TerrainGenerator.prototype.randomVector = function (scale) {\n  var r1 = this.randomGenerator.rnorm();\n  return [scale * r1, scale * r1];\n};\n\nterrain_TerrainGenerator.prototype.runif = function (lo, hi) {\n  var r = this.randomGenerator.uniform();\n  return lo + r * (hi - lo);\n};\n\nterrain_TerrainGenerator.prototype.generateCoast = function (params) {\n  var mesher = this.mesher;\n  var fieldModifier = this.fieldModifier;\n  var eroder = this.eroder;\n  var mesh = mesher.generateGoodMesh(params.npts, params.extent);\n  fieldModifier.resetBuffer(mesh.tris.length);\n  fieldModifier.addSlope(mesh, this.randomVector(4));\n  fieldModifier.addCone(mesh, this.runif(-1, -1));\n  fieldModifier.addMountains(mesh, 50);\n\n  for (var i = 0; i < 10; i++) {\n    fieldModifier.relax(mesh);\n  }\n\n  fieldModifier.peaky(mesh);\n  var el = this.runif(0, 0.1);\n  eroder.doErosion(mesh, el, 5);\n  var sl = this.runif(0.2, 0.6);\n  fieldModifier.setSeaLevel(mesh, sl);\n  eroder.fillSinks(mesh);\n  eroder.cleanCoast(mesh, 3);\n  console.log(mesh);\n  return mesh;\n};\n\nterrain_TerrainGenerator.prototype.generateUneroded = function (mainSize) {\n  var mesher = this.mesher;\n  var fieldModifier = this.fieldModifier;\n  var eroder = this.eroder;\n  var mesh = mesher.generateGoodMesh(mainSize);\n  fieldModifier.addSlope(mesh, this.randomVector(4));\n  fieldModifier.addCone(mesh, this.runif(-1, 1));\n  fieldModifier.addMountains(mesh, 50);\n  fieldModifier.peaky(mesh);\n  eroder.fillSinks(mesh);\n  fieldModifier.setSeaLevel(mesh, 0.5);\n  return mesh;\n};\n\nvar defaultExtent = {\n  width: 1,\n  height: 1\n};\nvar defaultParams = {\n  extent: defaultExtent,\n  npts: 16384,\n  ncities: 15,\n  nterrs: 5,\n  fontsizes: {\n    region: 40,\n    city: 25,\n    town: 20\n  }\n};\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/language/language.js\n\n\n\n\nvar language_LanguageGenerator = function LanguageGenerator(seed) {\n  seed = seed || \'language\';\n  this.randomGenerator = new Random(seed);\n};\n\nlanguage_LanguageGenerator.prototype.shuffled = function (list) {\n  var newlist = [];\n\n  for (var i = 0; i < list.length; i++) {\n    newlist.push(list[i]);\n  }\n\n  for (var _i = list.length - 1; _i > 0; _i--) {\n    var tmp = newlist[_i];\n    var j = this.randrange(_i);\n    newlist[_i] = newlist[j];\n    newlist[j] = tmp;\n  }\n\n  return newlist;\n};\n\nlanguage_LanguageGenerator.prototype.choose = function (list, exponent) {\n  var rng = this.randomGenerator;\n  exponent = exponent || 1;\n  var r = rng.uniform();\n  return list[Math.floor(Math.pow(r, exponent) * list.length)];\n};\n\nlanguage_LanguageGenerator.prototype.randrange = function (lo, hi) {\n  var rng = this.randomGenerator;\n\n  if (hi === undefined) {\n    hi = lo;\n    lo = 0;\n  }\n\n  var r = rng.uniform();\n  return Math.floor(r * (hi - lo)) + lo;\n};\n\nlanguage_LanguageGenerator.prototype.join = function (list, sep) {\n  if (list.length === 0) return \'\';\n  sep = sep || \'\';\n  var s = list[0];\n\n  for (var i = 1; i < list.length; i++) {\n    s += sep;\n    s += list[i];\n  }\n\n  return s;\n};\n\nlanguage_LanguageGenerator.prototype.capitalize = function (word) {\n  return word[0].toUpperCase() + word.slice(1);\n};\n\nlanguage_LanguageGenerator.prototype.spell = function (lang, syll) {\n  if (lang.noortho) return syll;\n  var s = \'\';\n\n  for (var i = 0; i < syll.length; i++) {\n    var c = syll[i];\n    s += lang.cortho[c] || lang.vortho[c] || defaultOrtho[c] || c;\n  }\n\n  return s;\n};\n\nlanguage_LanguageGenerator.prototype.makeSyllable = function (lang) {\n  var rng = this.randomGenerator;\n\n  while (true) {\n    var syll = \'\';\n\n    for (var i = 0; i < lang.structure.length; i++) {\n      var ptype = lang.structure[i];\n\n      if (lang.structure[i + 1] === \'?\') {\n        i++;\n        var r = rng.uniform();\n\n        if (r < 0.5) {\n          continue;\n        }\n      }\n\n      syll += this.choose(lang.phonemes[ptype], lang.exponent);\n    }\n\n    var bad = false;\n\n    for (var _i2 = 0; _i2 < lang.restricts.length; _i2++) {\n      if (lang.restricts[_i2].test(syll)) {\n        bad = true;\n        break;\n      }\n    }\n\n    if (bad) continue;\n    return this.spell(lang, syll);\n  }\n};\n\nlanguage_LanguageGenerator.prototype.getMorpheme = function (lang, key) {\n  if (lang.nomorph) {\n    return this.makeSyllable(lang);\n  }\n\n  key = key || \'\';\n  var list = lang.morphemes[key] || [];\n  var extras = 10;\n  if (key) extras = 1;\n\n  while (true) {\n    var n = this.randrange(list.length + extras);\n    if (list[n]) return list[n];\n    var morph = this.makeSyllable(lang);\n    var bad = false;\n\n    for (var k in lang.morphemes) {\n      if (lang.morphemes[k].includes(morph)) {\n        bad = true;\n        break;\n      }\n    }\n\n    if (bad) continue;\n    list.push(morph);\n    lang.morphemes[key] = list;\n    return morph;\n  }\n};\n\nlanguage_LanguageGenerator.prototype.makeWord = function (lang, key) {\n  var nsylls = this.randrange(lang.minsyll, lang.maxsyll + 1);\n  var w = \'\';\n  var keys = [];\n  keys[this.randrange(nsylls)] = key;\n\n  for (var i = 0; i < nsylls; i++) {\n    w += this.getMorpheme(lang, keys[i]);\n  }\n\n  return w;\n};\n\nlanguage_LanguageGenerator.prototype.getWord = function (lang, key) {\n  key = key || \'\';\n  var ws = lang.words[key] || [];\n  var extras = 3;\n  if (key) extras = 2;\n\n  while (true) {\n    var n = this.randrange(ws.length + extras);\n    var w = ws[n];\n\n    if (w) {\n      return w;\n    }\n\n    w = this.makeWord(lang, key);\n    var bad = false;\n\n    for (var k in lang.words) {\n      if (lang.words[k].includes(w)) {\n        bad = true;\n        break;\n      }\n    }\n\n    if (bad) continue;\n    ws.push(w);\n    lang.words[key] = ws;\n    return w;\n  }\n};\n\nlanguage_LanguageGenerator.prototype.makeName = function (lang, key) {\n  var rng = this.randomGenerator;\n  key = key || \'\';\n  lang.genitive = lang.genitive || this.getMorpheme(lang, \'of\');\n  lang.definite = lang.definite || this.getMorpheme(lang, \'the\');\n\n  while (true) {\n    var name = null;\n\n    if (rng.uniform() < 0.5) {\n      name = this.capitalize(this.getWord(lang, key));\n    } else {\n      var w1 = this.capitalize(this.getWord(lang, rng.uniform() < 0.6 ? key : \'\'));\n      var w2 = this.capitalize(this.getWord(lang, rng.uniform() < 0.6 ? key : \'\'));\n      if (w1 === w2) continue;\n\n      if (rng.uniform() > 0.5) {\n        name = this.join([w1, w2], lang.joiner);\n      } else {\n        name = this.join([w1, lang.genitive, w2], lang.joiner);\n      }\n    }\n\n    if (rng.uniform() < 0.1) {\n      name = this.join([lang.definite, name], lang.joiner);\n    }\n\n    if (name.length < lang.minchar || name.length > lang.maxchar) continue;\n    var used = false;\n\n    for (var i = 0; i < lang.names.length; i++) {\n      var name2 = lang.names[i];\n\n      if (name.indexOf(name2) !== -1 || name2.indexOf(name) !== -1) {\n        used = true;\n        break;\n      }\n    }\n\n    if (used) continue;\n    lang.names.push(name);\n    return name;\n  }\n};\n\nlanguage_LanguageGenerator.prototype.makeBasicLanguage = function () {\n  return {\n    phonemes: {\n      C: \'ptkmnls\',\n      V: \'aeiou\',\n      S: \'s\',\n      F: \'mn\',\n      L: \'rl\'\n    },\n    structure: \'CVC\',\n    exponent: 2,\n    restricts: [],\n    cortho: {},\n    vortho: {},\n    noortho: true,\n    nomorph: true,\n    nowordpool: true,\n    minsyll: 1,\n    maxsyll: 1,\n    morphemes: {},\n    words: {},\n    names: [],\n    joiner: \' \',\n    maxchar: 12,\n    minchar: 5\n  };\n};\n\nlanguage_LanguageGenerator.prototype.makeOrthoLanguage = function () {\n  var lang = this.makeBasicLanguage();\n  lang.noortho = false;\n  return lang;\n};\n\nlanguage_LanguageGenerator.prototype.makeRandomLanguage = function () {\n  var lang = this.makeBasicLanguage();\n  lang.noortho = false;\n  lang.nomorph = false;\n  lang.nowordpool = false;\n  lang.phonemes.C = this.shuffled(this.choose(consets, 2).C);\n  lang.phonemes.V = this.shuffled(this.choose(vowsets, 2).V);\n  lang.phonemes.L = this.shuffled(this.choose(lsets, 2).L);\n  lang.phonemes.S = this.shuffled(this.choose(ssets, 2).S);\n  lang.phonemes.F = this.shuffled(this.choose(fsets, 2).F);\n  lang.structure = this.choose(syllstructs);\n  lang.restricts = ressets[2].res;\n  lang.cortho = this.choose(corthsets, 2).orth;\n  lang.vortho = this.choose(vorthsets, 2).orth;\n  lang.minsyll = this.randrange(1, 3);\n  if (lang.structure.length < 3) lang.minsyll++;\n  lang.maxsyll = this.randrange(lang.minsyll + 1, 7);\n  lang.joiner = this.choose(\'   -\');\n  return lang;\n};\n\nvar defaultOrtho = {\n  : \'sh\',\n  : \'zh\',\n  : \'ch\',\n  : \'j\',\n  : \'ng\',\n  j: \'y\',\n  x: \'kh\',\n  : \'gh\',\n  : \'\',\n  A: \'\',\n  E: \'\',\n  I: \'\',\n  O: \'\',\n  U: \'\'\n};\nvar corthsets = [{\n  name: \'Default\',\n  orth: {}\n}, {\n  name: \'Slavic\',\n  orth: {\n    : \'\',\n    : \'\',\n    : \'\',\n    : \'\',\n    j: \'j\'\n  }\n}, {\n  name: \'German\',\n  orth: {\n    : \'sch\',\n    : \'zh\',\n    : \'tsch\',\n    : \'dz\',\n    j: \'j\',\n    x: \'ch\'\n  }\n}, {\n  name: \'French\',\n  orth: {\n    : \'ch\',\n    : \'j\',\n    : \'tch\',\n    : \'dj\',\n    x: \'kh\'\n  }\n}, {\n  name: \'Chinese (pinyin)\',\n  orth: {\n    : \'x\',\n    : \'q\',\n    : \'j\'\n  }\n}];\nvar vorthsets = [{\n  name: \'cutes\',\n  orth: {}\n}, {\n  name: \'mlauts\',\n  orth: {\n    A: \'\',\n    E: \'\',\n    I: \'\',\n    O: \'\',\n    U: \'\'\n  }\n}, {\n  name: \'Welsh\',\n  orth: {\n    A: \'\',\n    E: \'\',\n    I: \'y\',\n    O: \'\',\n    U: \'w\'\n  }\n}, {\n  name: \'Diphthongs\',\n  orth: {\n    A: \'au\',\n    E: \'ei\',\n    I: \'ie\',\n    O: \'ou\',\n    U: \'oo\'\n  }\n}, {\n  name: \'Doubles\',\n  orth: {\n    A: \'aa\',\n    E: \'ee\',\n    I: \'ii\',\n    O: \'oo\',\n    U: \'uu\'\n  }\n}];\nvar consets = [{\n  name: \'Minimal\',\n  C: \'ptkmnls\'\n}, {\n  name: \'English-ish\',\n  C: \'ptkbdgmnlrsz\'\n}, {\n  name: \'Pirah (very simple)\',\n  C: \'ptkmnh\'\n}, {\n  name: \'Hawaiian-ish\',\n  C: \'hklmnpw\'\n}, {\n  name: \'Greenlandic-ish\',\n  C: \'ptkqvsgrmnlj\'\n}, {\n  name: \'Arabic-ish\',\n  C: \'tksdbqxmnlrwj\'\n}, {\n  name: \'Arabic-lite\',\n  C: \'tkdgmns\'\n}, {\n  name: \'English-lite\',\n  C: \'ptkbdgmnszhjw\'\n}];\nvar ssets = [{\n  name: \'Just s\',\n  S: \'s\'\n}, {\n  name: \'s \',\n  S: \'s\'\n}, {\n  name: \'s  f\',\n  S: \'sf\'\n}];\nvar lsets = [{\n  name: \'r l\',\n  L: \'rl\'\n}, {\n  name: \'Just r\',\n  L: \'r\'\n}, {\n  name: \'Just l\',\n  L: \'l\'\n}, {\n  name: \'w j\',\n  L: \'wj\'\n}, {\n  name: \'r l w j\',\n  L: \'rlwj\'\n}];\nvar fsets = [{\n  name: \'m n\',\n  F: \'mn\'\n}, {\n  name: \'s k\',\n  F: \'sk\'\n}, {\n  name: \'m n \',\n  F: \'mn\'\n}, {\n  name: \'s  z \',\n  F: \'sz\'\n}];\nvar vowsets = [{\n  name: \'Standard 5-vowel\',\n  V: \'aeiou\'\n}, {\n  name: \'3-vowel a i u\',\n  V: \'aiu\'\n}, {\n  name: \'Extra A E I\',\n  V: \'aeiouAEI\'\n}, {\n  name: \'Extra U\',\n  V: \'aeiouU\'\n}, {\n  name: \'5-vowel a i u A I\',\n  V: \'aiuAI\'\n}, {\n  name: \'3-vowel e o u\',\n  V: \'eou\'\n}, {\n  name: \'Extra A O U\',\n  V: \'aeiouAOU\'\n}];\nvar syllstructs = [\'CVC\', \'CVV?C\', \'CVVC?\', \'CVC?\', \'CV\', \'VC\', \'CVF\', \'C?VC\', \'CVF?\', \'CL?VC\', \'CL?VF\', \'S?CVC\', \'S?CVF\', \'S?CVC?\', \'C?VF\', \'C?VC?\', \'C?VF?\', \'C?L?VC\', \'VC\', \'CVL?C?\', \'C?VL?C\', \'C?VLC?\'];\nvar ressets = [{\n  name: \'None\',\n  res: []\n}, {\n  name: \'Double sounds\',\n  res: [/(.)\\1/]\n}, {\n  name: \'Doubles and hard clusters\',\n  res: [/[sf][s]/, /(.)\\1/, /[rl][rl]/]\n}];\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/names.js\n\n\nvar NameGiver = function NameGiver(languageGenerator) {\n  if (!languageGenerator) throw Error(\'Invalid argument.\');\n  this.buffer = [];\n  this.languageGenerator = languageGenerator;\n};\n\nNameGiver.prototype.giveNames = function (country) {\n  var rlg = this.languageGenerator;\n  var lang = rlg.makeRandomLanguage();\n  var cities = country.cities;\n  var terr = country.terr;\n  var nterrs = country.params.nterrs;\n\n  if (cities) {\n    var cityNames = [];\n\n    for (var i = 0; i < cities.length; i++) {\n      cityNames.push(rlg.makeName(lang, \'city\'));\n    }\n\n    country.cityNames = cityNames;\n  }\n\n  if (terr) {\n    var regionNames = [];\n\n    for (var _i = 0; _i < nterrs; _i++) {\n      regionNames.push(rlg.makeName(lang, \'region\'));\n    }\n\n    country.regionNames = regionNames;\n  }\n};\n\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/voronoi/constant.js\n\n\n/* harmony default export */ var constant = (function (x) {\n  return function () {\n    return x;\n  };\n});\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/voronoi/point.js\n\n\nfunction point_x(d) {\n  return d[0];\n}\nfunction point_y(d) {\n  return d[1];\n}\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/voronoi/RedBlackTree.js\n\n\nfunction RedBlackTree() {\n  this._ = null; // root node\n}\n\nfunction RedBlackNode(node) {\n  node.U = // parent node\n  node.C = // color - true for red, false for black\n  node.L = // left node\n  node.R = // right node\n  node.P = // previous node\n  node.N = null; // next node\n}\nRedBlackTree.prototype = {\n  constructor: RedBlackTree,\n  insert: function insert(after, node) {\n    var parent;\n    var grandpa;\n    var uncle;\n\n    if (after) {\n      node.P = after;\n      node.N = after.N;\n      if (after.N) after.N.P = node;\n      after.N = node;\n\n      if (after.R) {\n        after = after.R;\n\n        while (after.L) {\n          after = after.L;\n        }\n\n        after.L = node;\n      } else {\n        after.R = node;\n      }\n\n      parent = after;\n    } else if (this._) {\n      after = RedBlackFirst(this._);\n      node.P = null;\n      node.N = after;\n      after.P = after.L = node;\n      parent = after;\n    } else {\n      node.P = node.N = null;\n      this._ = node;\n      parent = null;\n    }\n\n    node.L = node.R = null;\n    node.U = parent;\n    node.C = true;\n    after = node;\n\n    while (parent && parent.C) {\n      grandpa = parent.U;\n\n      if (parent === grandpa.L) {\n        uncle = grandpa.R;\n\n        if (uncle && uncle.C) {\n          parent.C = uncle.C = false;\n          grandpa.C = true;\n          after = grandpa;\n        } else {\n          if (after === parent.R) {\n            RedBlackRotateLeft(this, parent);\n            after = parent;\n            parent = after.U;\n          }\n\n          parent.C = false;\n          grandpa.C = true;\n          RedBlackRotateRight(this, grandpa);\n        }\n      } else {\n        uncle = grandpa.L;\n\n        if (uncle && uncle.C) {\n          parent.C = uncle.C = false;\n          grandpa.C = true;\n          after = grandpa;\n        } else {\n          if (after === parent.L) {\n            RedBlackRotateRight(this, parent);\n            after = parent;\n            parent = after.U;\n          }\n\n          parent.C = false;\n          grandpa.C = true;\n          RedBlackRotateLeft(this, grandpa);\n        }\n      }\n\n      parent = after.U;\n    }\n\n    this._.C = false;\n  },\n  remove: function remove(node) {\n    if (node.N) node.N.P = node.P;\n    if (node.P) node.P.N = node.N;\n    node.N = node.P = null;\n    var parent = node.U;\n    var sibling;\n    var left = node.L;\n    var right = node.R;\n    var next;\n    var red;\n    if (!left) next = right;else if (!right) next = left;else next = RedBlackFirst(right);\n\n    if (parent) {\n      if (parent.L === node) parent.L = next;else parent.R = next;\n    } else {\n      this._ = next;\n    }\n\n    if (left && right) {\n      red = next.C;\n      next.C = node.C;\n      next.L = left;\n      left.U = next;\n\n      if (next !== right) {\n        parent = next.U;\n        next.U = node.U;\n        node = next.R;\n        parent.L = node;\n        next.R = right;\n        right.U = next;\n      } else {\n        next.U = parent;\n        parent = next;\n        node = next.R;\n      }\n    } else {\n      red = node.C;\n      node = next;\n    }\n\n    if (node) node.U = parent;\n    if (red) return;\n\n    if (node && node.C) {\n      node.C = false;\n      return;\n    }\n\n    do {\n      if (node === this._) break;\n\n      if (node === parent.L) {\n        sibling = parent.R;\n\n        if (sibling.C) {\n          sibling.C = false;\n          parent.C = true;\n          RedBlackRotateLeft(this, parent);\n          sibling = parent.R;\n        }\n\n        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\n          if (!sibling.R || !sibling.R.C) {\n            sibling.L.C = false;\n            sibling.C = true;\n            RedBlackRotateRight(this, sibling);\n            sibling = parent.R;\n          }\n\n          sibling.C = parent.C;\n          parent.C = sibling.R.C = false;\n          RedBlackRotateLeft(this, parent);\n          node = this._;\n          break;\n        }\n      } else {\n        sibling = parent.L;\n\n        if (sibling.C) {\n          sibling.C = false;\n          parent.C = true;\n          RedBlackRotateRight(this, parent);\n          sibling = parent.L;\n        }\n\n        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\n          if (!sibling.L || !sibling.L.C) {\n            sibling.R.C = false;\n            sibling.C = true;\n            RedBlackRotateLeft(this, sibling);\n            sibling = parent.L;\n          }\n\n          sibling.C = parent.C;\n          parent.C = sibling.L.C = false;\n          RedBlackRotateRight(this, parent);\n          node = this._;\n          break;\n        }\n      }\n\n      sibling.C = true;\n      node = parent;\n      parent = parent.U;\n    } while (!node.C);\n\n    if (node) node.C = false;\n  }\n};\n\nfunction RedBlackRotateLeft(tree, node) {\n  var p = node;\n  var q = node.R;\n  var parent = p.U;\n\n  if (parent) {\n    if (parent.L === p) parent.L = q;else parent.R = q;\n  } else {\n    tree._ = q;\n  }\n\n  q.U = parent;\n  p.U = q;\n  p.R = q.L;\n  if (p.R) p.R.U = p;\n  q.L = p;\n}\n\nfunction RedBlackRotateRight(tree, node) {\n  var p = node;\n  var q = node.L;\n  var parent = p.U;\n\n  if (parent) {\n    if (parent.L === p) parent.L = q;else parent.R = q;\n  } else {\n    tree._ = q;\n  }\n\n  q.U = parent;\n  p.U = q;\n  p.L = q.R;\n  if (p.L) p.L.U = p;\n  q.R = p;\n}\n\nfunction RedBlackFirst(node) {\n  while (node.L) {\n    node = node.L;\n  }\n\n  return node;\n}\n\n/* harmony default export */ var voronoi_RedBlackTree = (RedBlackTree);\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/voronoi/Edge.js\n\n\n\nfunction createEdge(left, right, v0, v1) {\n  var edge = [null, null];\n  var index = Diagram_edges.push(edge) - 1;\n  edge.left = left;\n  edge.right = right;\n  if (v0) setEdgeEnd(edge, left, right, v0);\n  if (v1) setEdgeEnd(edge, right, left, v1);\n  cells[left.index].halfedges.push(index);\n  cells[right.index].halfedges.push(index);\n  return edge;\n}\nfunction createBorderEdge(left, v0, v1) {\n  var edge = [v0, v1];\n  edge.left = left;\n  return edge;\n}\nfunction setEdgeEnd(edge, left, right, vertex) {\n  if (!edge[0] && !edge[1]) {\n    edge[0] = vertex;\n    edge.left = left;\n    edge.right = right;\n  } else if (edge.left === right) {\n    edge[1] = vertex;\n  } else {\n    edge[0] = vertex;\n  }\n} // LiangBarsky line clipping.\n\nfunction clipEdge(edge, x0, y0, x1, y1) {\n  var a = edge[0];\n  var b = edge[1];\n  var ax = a[0];\n  var ay = a[1];\n  var bx = b[0];\n  var by = b[1];\n  var t0 = 0;\n  var t1 = 1;\n  var dx = bx - ax;\n  var dy = by - ay;\n  var r;\n  r = x0 - ax;\n  if (!dx && r > 0) return;\n  r /= dx;\n\n  if (dx < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dx > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = x1 - ax;\n  if (!dx && r < 0) return;\n  r /= dx;\n\n  if (dx < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dx > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  r = y0 - ay;\n  if (!dy && r > 0) return;\n  r /= dy;\n\n  if (dy < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dy > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = y1 - ay;\n  if (!dy && r < 0) return;\n  r /= dy;\n\n  if (dy < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dy > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  if (!(t0 > 0) && !(t1 < 1)) return true;\n  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];\n  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];\n  return true;\n}\n\nfunction connectEdge(edge, x0, y0, x1, y1) {\n  var v1 = edge[1];\n  if (v1) return true;\n  var v0 = edge[0];\n  var left = edge.left;\n  var right = edge.right;\n  var lx = left[0];\n  var ly = left[1];\n  var rx = right[0];\n  var ry = right[1];\n  var fx = (lx + rx) / 2;\n  var fy = (ly + ry) / 2;\n  var fm;\n  var fb;\n\n  if (ry === ly) {\n    if (fx < x0 || fx >= x1) return;\n\n    if (lx > rx) {\n      if (!v0) v0 = [fx, y0];else if (v0[1] >= y1) return;\n      v1 = [fx, y1];\n    } else {\n      if (!v0) v0 = [fx, y1];else if (v0[1] < y0) return;\n      v1 = [fx, y0];\n    }\n  } else {\n    fm = (lx - rx) / (ry - ly);\n    fb = fy - fm * fx;\n\n    if (fm < -1 || fm > 1) {\n      if (lx > rx) {\n        if (!v0) v0 = [(y0 - fb) / fm, y0];else if (v0[1] >= y1) return;\n        v1 = [(y1 - fb) / fm, y1];\n      } else {\n        if (!v0) v0 = [(y1 - fb) / fm, y1];else if (v0[1] < y0) return;\n        v1 = [(y0 - fb) / fm, y0];\n      }\n    } else if (ly < ry) {\n      if (!v0) v0 = [x0, fm * x0 + fb];else if (v0[0] >= x1) return;\n      v1 = [x1, fm * x1 + fb];\n    } else {\n      if (!v0) v0 = [x1, fm * x1 + fb];else if (v0[0] < x0) return;\n      v1 = [x0, fm * x0 + fb];\n    }\n  }\n\n  edge[0] = v0;\n  edge[1] = v1;\n  return true;\n}\n\nfunction clipEdges(x0, y0, x1, y1) {\n  var i = Diagram_edges.length;\n  var edge;\n\n  while (i--) {\n    if (!connectEdge(edge = Diagram_edges[i], x0, y0, x1, y1) || !clipEdge(edge, x0, y0, x1, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > Diagram_epsilon || Math.abs(edge[0][1] - edge[1][1]) > Diagram_epsilon)) {\n      delete Diagram_edges[i];\n    }\n  }\n}\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/voronoi/Cell.js\n\n\n\n\nfunction createCell(site) {\n  // eslint-disable-next-line no-return-assign\n  return cells[site.index] = {\n    site: site,\n    halfedges: []\n  };\n}\n\nfunction cellHalfedgeAngle(cell, edge) {\n  var site = cell.site;\n  var va = edge.left;\n  var vb = edge.right;\n\n  if (site === vb) {\n    vb = va;\n    va = site;\n  }\n\n  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\n\n  if (site === va) {\n    va = edge[1];\n    vb = edge[0];\n  } else {\n    va = edge[0];\n    vb = edge[1];\n  }\n\n  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\n}\n\nfunction cellHalfedgeStart(cell, edge) {\n  return edge[+(edge.left !== cell.site)];\n}\nfunction cellHalfedgeEnd(cell, edge) {\n  return edge[+(edge.left === cell.site)];\n}\nfunction sortCellHalfedges() {\n  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\n    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\n      (function () {\n        var index = new Array(m);\n        var array = new Array(m);\n\n        for (j = 0; j < m; ++j) {\n          index[j] = j;\n          array[j] = cellHalfedgeAngle(cell, Diagram_edges[halfedges[j]]);\n        }\n\n        index.sort(function (a, b) {\n          return array[b] - array[a];\n        });\n\n        for (j = 0; j < m; ++j) {\n          array[j] = halfedges[index[j]];\n        }\n\n        for (j = 0; j < m; ++j) {\n          halfedges[j] = array[j];\n        }\n      })();\n    }\n  }\n}\nfunction clipCells(x0, y0, x1, y1) {\n  var nCells = cells.length;\n  var iCell;\n  var cell;\n  var site;\n  var iHalfedge;\n  var halfedges;\n  var nHalfedges;\n  var start;\n  var startX;\n  var startY;\n  var end;\n  var endX;\n  var endY;\n  var cover = true;\n\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    cell = cells[iCell];\n\n    if (cell) {\n      site = cell.site;\n      halfedges = cell.halfedges;\n      iHalfedge = halfedges.length; // Remove any dangling clipped edges.\n\n      while (iHalfedge--) {\n        if (!Diagram_edges[halfedges[iHalfedge]]) {\n          halfedges.splice(iHalfedge, 1);\n        }\n      } // Insert any border edges as necessary.\n\n\n      iHalfedge = 0;\n      nHalfedges = halfedges.length;\n\n      while (iHalfedge < nHalfedges) {\n        end = cellHalfedgeEnd(cell, Diagram_edges[halfedges[iHalfedge]]);\n        endX = end[0];\n        endY = end[1];\n        start = cellHalfedgeStart(cell, Diagram_edges[halfedges[++iHalfedge % nHalfedges]]);\n        startX = start[0];\n        startY = start[1];\n\n        if (Math.abs(endX - startX) > Diagram_epsilon || Math.abs(endY - startY) > Diagram_epsilon) {\n          var ne = Math.abs(endX - x0) < Diagram_epsilon && y1 - endY > Diagram_epsilon ? [x0, Math.abs(startX - x0) < Diagram_epsilon ? startY : y1] : Math.abs(endY - y1) < Diagram_epsilon && x1 - endX > Diagram_epsilon ? [Math.abs(startY - y1) < Diagram_epsilon ? startX : x1, y1] : Math.abs(endX - x1) < Diagram_epsilon && endY - y0 > Diagram_epsilon ? [x1, Math.abs(startX - x1) < Diagram_epsilon ? startY : y0] : Math.abs(endY - y0) < Diagram_epsilon && endX - x0 > Diagram_epsilon ? [Math.abs(startY - y0) < Diagram_epsilon ? startX : x0, y0] : null;\n          var be = createBorderEdge(site, end, ne);\n          halfedges.splice(iHalfedge, 0, Diagram_edges.push(be) - 1);\n          ++nHalfedges;\n        }\n      }\n\n      if (nHalfedges) cover = false;\n    }\n  } // If there werent any edges, have the closest site cover the extent.\n  // It doesnt matter which corner of the extent we measure!\n\n\n  if (cover) {\n    var dx;\n    var dy;\n    var d2;\n    var dc = Infinity;\n\n    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\n      cell = cells[iCell];\n\n      if (cell) {\n        site = cell.site;\n        dx = site[0] - x0;\n        dy = site[1] - y0;\n        d2 = dx * dx + dy * dy;\n\n        if (d2 < dc) {\n          dc = d2;\n          cover = cell;\n        }\n      }\n    }\n\n    if (cover) {\n      var v00 = [x0, y0];\n      var v01 = [x0, y1];\n      var v11 = [x1, y1];\n      var v10 = [x1, y0];\n      cover.halfedges.push(Diagram_edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1, Diagram_edges.push(createBorderEdge(site, v01, v11)) - 1, Diagram_edges.push(createBorderEdge(site, v11, v10)) - 1, Diagram_edges.push(createBorderEdge(site, v10, v00)) - 1);\n    }\n  } // Lastly delete any cells with no edges; these were entirely clipped.\n\n\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    cell = cells[iCell];\n\n    if (cell) {\n      if (!cell.halfedges.length) {\n        delete cells[iCell];\n      }\n    }\n  }\n}\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/voronoi/Circle.js\n\n\n\n\nvar circlePool = [];\nvar firstCircle;\n\nfunction Circle() {\n  RedBlackNode(this);\n  this.x = this.y = this.arc = this.site = this.cy = null;\n}\n\nfunction attachCircle(arc) {\n  var lArc = arc.P;\n  var rArc = arc.N;\n  if (!lArc || !rArc) return;\n  var lSite = lArc.site;\n  var cSite = arc.site;\n  var rSite = rArc.site;\n  if (lSite === rSite) return;\n  var bx = cSite[0];\n  var by = cSite[1];\n  var ax = lSite[0] - bx;\n  var ay = lSite[1] - by;\n  var cx = rSite[0] - bx;\n  var cy = rSite[1] - by;\n  var d = 2 * (ax * cy - ay * cx);\n  if (d >= -epsilon2) return;\n  var ha = ax * ax + ay * ay;\n  var hc = cx * cx + cy * cy;\n  var x = (cy * ha - ay * hc) / d;\n  var y = (ax * hc - cx * ha) / d;\n  var circle = circlePool.pop() || new Circle();\n  circle.arc = arc;\n  circle.site = cSite;\n  circle.x = x + bx;\n  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom\n\n  arc.circle = circle;\n  var before = null;\n  var node = circles._;\n\n  while (node) {\n    if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {\n      if (node.L) node = node.L;else {\n        before = node.P;\n        break;\n      }\n    } else if (node.R) node = node.R;else {\n      before = node;\n      break;\n    }\n  }\n\n  circles.insert(before, circle);\n  if (!before) firstCircle = circle;\n}\nfunction detachCircle(arc) {\n  var circle = arc.circle;\n\n  if (circle) {\n    if (!circle.P) firstCircle = circle.N;\n    circles.remove(circle);\n    circlePool.push(circle);\n    RedBlackNode(circle);\n    arc.circle = null;\n  }\n}\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/voronoi/Beach.js\n\n\n\n\n\n\n\nvar beachPool = [];\n\nfunction Beach() {\n  RedBlackNode(this);\n  this.edge = this.site = this.circle = null;\n}\n\nfunction createBeach(site) {\n  var beach = beachPool.pop() || new Beach();\n  beach.site = site;\n  return beach;\n}\n\nfunction detachBeach(beach) {\n  detachCircle(beach);\n  beaches.remove(beach);\n  beachPool.push(beach);\n  RedBlackNode(beach);\n}\n\nfunction removeBeach(beach) {\n  var circle = beach.circle;\n  var x = circle.x;\n  var y = circle.cy;\n  var vertex = [x, y];\n  var previous = beach.P;\n  var next = beach.N;\n  var disappearing = [beach];\n  detachBeach(beach);\n  var lArc = previous;\n\n  while (lArc.circle && Math.abs(x - lArc.circle.x) < Diagram_epsilon && Math.abs(y - lArc.circle.cy) < Diagram_epsilon) {\n    previous = lArc.P;\n    disappearing.unshift(lArc);\n    detachBeach(lArc);\n    lArc = previous;\n  }\n\n  disappearing.unshift(lArc);\n  detachCircle(lArc);\n  var rArc = next;\n\n  while (rArc.circle && Math.abs(x - rArc.circle.x) < Diagram_epsilon && Math.abs(y - rArc.circle.cy) < Diagram_epsilon) {\n    next = rArc.N;\n    disappearing.push(rArc);\n    detachBeach(rArc);\n    rArc = next;\n  }\n\n  disappearing.push(rArc);\n  detachCircle(rArc);\n  var nArcs = disappearing.length;\n  var iArc;\n\n  for (iArc = 1; iArc < nArcs; ++iArc) {\n    rArc = disappearing[iArc];\n    lArc = disappearing[iArc - 1];\n    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n  }\n\n  lArc = disappearing[0];\n  rArc = disappearing[nArcs - 1];\n  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\nfunction addBeach(site) {\n  var x = site[0];\n  var directrix = site[1];\n  var lArc;\n  var rArc;\n  var dxl;\n  var dxr;\n  var node = beaches._;\n\n  while (node) {\n    dxl = leftBreakPoint(node, directrix) - x;\n    if (dxl > Diagram_epsilon) node = node.L;else {\n      dxr = x - rightBreakPoint(node, directrix);\n\n      if (dxr > Diagram_epsilon) {\n        if (!node.R) {\n          lArc = node;\n          break;\n        }\n\n        node = node.R;\n      } else {\n        if (dxl > -Diagram_epsilon) {\n          lArc = node.P;\n          rArc = node;\n        } else if (dxr > -Diagram_epsilon) {\n          lArc = node;\n          rArc = node.N;\n        } else {\n          lArc = rArc = node;\n        }\n\n        break;\n      }\n    }\n  }\n\n  createCell(site);\n  var newArc = createBeach(site);\n  beaches.insert(lArc, newArc);\n  if (!lArc && !rArc) return;\n\n  if (lArc === rArc) {\n    detachCircle(lArc);\n    rArc = createBeach(lArc.site);\n    beaches.insert(newArc, rArc);\n    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);\n    attachCircle(lArc);\n    attachCircle(rArc);\n    return;\n  }\n\n  if (!rArc) {\n    // && lArc\n    newArc.edge = createEdge(lArc.site, newArc.site);\n    return;\n  } // else lArc !== rArc\n\n\n  detachCircle(lArc);\n  detachCircle(rArc);\n  var lSite = lArc.site;\n  var ax = lSite[0];\n  var ay = lSite[1];\n  var bx = site[0] - ax;\n  var by = site[1] - ay;\n  var rSite = rArc.site;\n  var cx = rSite[0] - ax;\n  var cy = rSite[1] - ay;\n  var d = 2 * (bx * cy - by * cx);\n  var hb = bx * bx + by * by;\n  var hc = cx * cx + cy * cy;\n  var vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];\n  setEdgeEnd(rArc.edge, lSite, rSite, vertex);\n  newArc.edge = createEdge(lSite, site, null, vertex);\n  rArc.edge = createEdge(site, rSite, null, vertex);\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\n\nfunction leftBreakPoint(arc, directrix) {\n  var site = arc.site;\n  var rfocx = site[0];\n  var rfocy = site[1];\n  var pby2 = rfocy - directrix;\n  if (!pby2) return rfocx;\n  var lArc = arc.P;\n  if (!lArc) return -Infinity;\n  site = lArc.site;\n  var lfocx = site[0];\n  var lfocy = site[1];\n  var plby2 = lfocy - directrix;\n  if (!plby2) return lfocx;\n  var hl = lfocx - rfocx;\n  var aby2 = 1 / pby2 - 1 / plby2;\n  var b = hl / plby2;\n  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n  return (rfocx + lfocx) / 2;\n}\n\nfunction rightBreakPoint(arc, directrix) {\n  var rArc = arc.N;\n  if (rArc) return leftBreakPoint(rArc, directrix);\n  var site = arc.site;\n  return site[1] === directrix ? site[0] : Infinity;\n}\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/voronoi/Diagram.js\n\n\n\n\n\n\n\nvar Diagram_epsilon = 1e-6;\nvar epsilon2 = 1e-12;\nvar beaches;\nvar cells;\nvar circles;\nvar Diagram_edges;\n\nfunction triangleArea(a, b, c) {\n  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);\n}\n\nfunction lexicographic(a, b) {\n  return b[1] - a[1] || b[0] - a[0];\n}\n\nfunction Diagram(sites, extent) {\n  var site = sites.sort(lexicographic).pop();\n  var x;\n  var y;\n  var circle;\n  Diagram_edges = [];\n  cells = new Array(sites.length);\n  beaches = new voronoi_RedBlackTree();\n  circles = new voronoi_RedBlackTree();\n\n  while (true) {\n    circle = firstCircle;\n\n    if (site && (!circle || site[1] < circle.y || site[1] === circle.y && site[0] < circle.x)) {\n      if (site[0] !== x || site[1] !== y) {\n        addBeach(site);\n        x = site[0];\n        y = site[1];\n      }\n\n      site = sites.pop();\n    } else if (circle) {\n      removeBeach(circle.arc);\n    } else {\n      break;\n    }\n  }\n\n  sortCellHalfedges();\n\n  if (extent) {\n    var x0 = +extent[0][0];\n    var y0 = +extent[0][1];\n    var x1 = +extent[1][0];\n    var y1 = +extent[1][1];\n    clipEdges(x0, y0, x1, y1);\n    clipCells(x0, y0, x1, y1);\n  }\n\n  this.edges = Diagram_edges;\n  this.cells = cells;\n  beaches = circles = Diagram_edges = cells = null;\n}\nDiagram.prototype = {\n  constructor: Diagram,\n  polygons: function polygons() {\n    var edg = this.edges;\n    return this.cells.map(function (cell) {\n      var polygon = cell.halfedges.map(function (i) {\n        return cellHalfedgeStart(cell, edg[i]);\n      });\n      polygon.data = cell.site.data;\n      return polygon;\n    });\n  },\n  triangles: function triangles() {\n    var triangles = [];\n    var edg = this.edges;\n    this.cells.forEach(function (cell, i) {\n      if (!(m = (halfedges = cell.halfedges).length)) return;\n      var site = cell.site;\n      var halfedges;\n      var j = -1;\n      var m;\n      var s0;\n      var e1 = edg[halfedges[m - 1]];\n      var s1 = e1.left === site ? e1.right : e1.left;\n\n      while (++j < m) {\n        s0 = s1;\n        e1 = edg[halfedges[j]];\n        s1 = e1.left === site ? e1.right : e1.left;\n\n        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {\n          triangles.push([site.data, s0.data, s1.data]);\n        }\n      }\n    });\n    return triangles;\n  },\n  links: function links() {\n    return this.edges.filter(function (edge) {\n      return edge.right;\n    }).map(function (edge) {\n      return {\n        source: edge.left.data,\n        target: edge.right.data\n      };\n    });\n  },\n  find: function find(x, y, radius) {\n    var that = this;\n    var i0;\n    var i1 = that._found || 0;\n    var n = that.cells.length;\n    var cell; // Use the previously-found cell, or start with an arbitrary one.\n\n    while (!(cell = that.cells[i1])) {\n      if (++i1 >= n) return null;\n    }\n\n    var dx = x - cell.site[0];\n    var dy = y - cell.site[1];\n    var d2 = dx * dx + dy * dy;\n\n    var callback = function callback(e) {\n      var edge = that.edges[e];\n      var v = edge.left;\n      if ((v === cell.site || !v) && !(v = edge.right)) return;\n      var vx = x - v[0];\n      var vy = y - v[1];\n      var v2 = vx * vx + vy * vy;\n\n      if (v2 < d2) {\n        d2 = v2;\n        i1 = v.index;\n      }\n    }; // Traverse the half-edges to find a closer cell, if any.\n\n\n    do {\n      cell = that.cells[i0 = i1];\n      i1 = null;\n      cell.halfedges.forEach(callback);\n    } while (i1 !== null);\n\n    that._found = i0;\n    return radius === null || d2 <= radius * radius ? cell.site : null;\n  }\n};\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/voronoi/voronoi.js\n\n\n\n\n\n/* harmony default export */ var voronoi_voronoi = (function () {\n  var x = point_x;\n  var y = point_y;\n  var extent = null;\n\n  function voronoi(data) {\n    return new Diagram(data.map(function (d, i) {\n      var s = [Math.round(x(d, i, data) / Diagram_epsilon) * Diagram_epsilon, Math.round(y(d, i, data) / Diagram_epsilon) * Diagram_epsilon];\n      s.index = i;\n      s.data = d;\n      return s;\n    }), extent);\n  }\n\n  voronoi.polygons = function (data) {\n    return voronoi(data).polygons();\n  };\n\n  voronoi.links = function (data) {\n    return voronoi(data).links();\n  };\n\n  voronoi.triangles = function (data) {\n    return voronoi(data).triangles();\n  };\n\n  voronoi.x = function (_) {\n    // eslint-disable-next-line no-return-assign\n    return arguments.length ? (x = typeof _ === \'function\' ? _ : constant(+_), voronoi) : x;\n  };\n\n  voronoi.y = function (_) {\n    // eslint-disable-next-line no-return-assign\n    return arguments.length ? (y = typeof _ === \'function\' ? _ : constant(+_), voronoi) : y;\n  };\n\n  voronoi.extent = function (_) {\n    // eslint-disable-next-line no-return-assign\n    return arguments.length ? (extent = _ === null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];\n  };\n\n  voronoi.size = function (_) {\n    // eslint-disable-next-line no-return-assign\n    return arguments.length ? (extent = _ === null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];\n  };\n\n  return voronoi;\n});\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/voronoi/index.js\n\n\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/mesh.js\n\n\n\n\n\nvar d3voronoi = voronoi_voronoi;\n\nvar mesh_Mesher = function Mesher() {\n  this.buffer = [];\n  this.randomGenerator = new Random(\'mesher\');\n};\n\nmesh_Mesher.prototype.generatePoints = function (n, extent) {\n  extent = extent || defaultExtent;\n  var pts = [];\n  var rng = this.randomGenerator; // let side = Math.sqrt(n);\n  // for (let x = 0; x < side; ++x) {\n  //     for (let y = 0; y < side; ++y) {\n  //         let r1 = randomGenerator.uniform();\n  //         let r2 = randomGenerator.uniform();\n  //         pts.push(\n  //             [\n  //                 ((x + 0.5 * (r1)) / side - 0.5) * extent.width,\n  //                 ((y + 0.5 * (r2)) / side - 0.5) * extent.height\n  //             ]\n  //         );\n  //     }\n  // }\n\n  for (var i = 0; i < n; i++) {\n    var r1 = rng.uniform();\n    var r2 = rng.uniform();\n    pts.push([(r1 - 0.5) * extent.width, (r2 - 0.5) * extent.height]);\n  }\n\n  return pts;\n};\n\nmesh_Mesher.prototype.centroid = function (pts) {\n  var x = 0;\n  var y = 0;\n\n  for (var i = 0; i < pts.length; i++) {\n    x += pts[i][0];\n    y += pts[i][1];\n  }\n\n  return [x / pts.length, y / pts.length];\n};\n\nmesh_Mesher.prototype.improvePoints = function (pts, n, extent) {\n  n = n || 1;\n  extent = extent || defaultExtent;\n\n  for (var i = 0; i < n; i++) {\n    pts = this.voronoi(pts, extent).polygons(pts).map(this.centroid);\n  }\n\n  return pts;\n};\n\nmesh_Mesher.prototype.generateGoodPoints = function (n, extent) {\n  extent = extent || defaultExtent;\n  var pts = this.generatePoints(n, extent);\n  pts = pts.sort(function (a, b) {\n    return a[0] - b[0];\n  });\n  return this.improvePoints(pts, 1, extent);\n};\n\nmesh_Mesher.prototype.voronoi = function (pts, extent) {\n  extent = extent || defaultExtent;\n  var w = extent.width / 2;\n  var h = extent.height / 2;\n  return d3voronoi().extent([[-w, -h], [w, h]])(pts);\n};\n\nmesh_Mesher.prototype.makeMesh = function (pts, extent) {\n  extent = extent || defaultExtent;\n  var vor = this.voronoi(pts, extent);\n  var vxs = [];\n  var vxids = new Map();\n  var adj = [];\n  var edges = [];\n  var tris = [];\n  var voronoiEdges = vor.edges;\n\n  for (var i = 0; i < voronoiEdges.length; i++) {\n    var e = voronoiEdges[i];\n    if (e === undefined) continue;\n    var e0 = vxids.get(e[0]);\n    var e1 = vxids.get(e[1]);\n\n    if (e0 === undefined) {\n      e0 = vxs.length;\n      vxids.set(e[0], e0);\n      vxs.push(e[0]);\n    }\n\n    if (e1 === undefined) {\n      e1 = vxs.length;\n      vxids.set(e[1], e1);\n      vxs.push(e[1]);\n    }\n\n    adj[e0] = adj[e0] || [];\n    adj[e0].push(e1);\n    adj[e1] = adj[e1] || [];\n    adj[e1].push(e0);\n    var left = e.left;\n    var right = e.right;\n    edges.push([e0, e1, left, right]);\n    tris[e0] = tris[e0] || [];\n    if (!tris[e0].includes(left)) tris[e0].push(left);\n    if (right && !tris[e0].includes(right)) tris[e0].push(right);\n    tris[e1] = tris[e1] || [];\n    if (!tris[e1].includes(left)) tris[e1].push(left);\n    if (right && !tris[e1].includes(right)) tris[e1].push(right);\n  }\n\n  var borderStart = vxs.length; // Border surgery\n\n  var w = extent.width / 2;\n  var h = extent.height / 2;\n  var topRight = [-w, -h];\n  var topLeft = [w, -h];\n  var bottomRight = [-w, h];\n  var bottomLeft = [w, h];\n\n  for (var _i = 0; _i < tris.length; ++_i) {\n    var ns = adj[_i];\n    if (!ns.length || ns.length === 3) continue;\n    var t = tris[_i];\n\n    if (ns.length === 2) {\n      if (t.length !== 2) continue;\n      var _e = t[0];\n      var e2 = t[1];\n      var e3 = t[2];\n      var ea = _e !== undefined ? _e : e2;\n      var eb = _e !== undefined && e2 !== undefined ? e2 : e3;\n      var midX = (ea[0] + eb[0]) / 2;\n      var midY = (ea[1] + eb[1]) / 2;\n      var newP1 = void 0;\n      var newP2 = void 0;\n      var newTri1 = void 0;\n      var newTri2 = void 0;\n      var newIndex1 = vxs.length;\n      var newIndex2 = vxs.length + 1;\n\n      if (Math.abs(midX) > Math.abs(midY)) {\n        // centered in 0\n        if (midX > 0) {\n          newP1 = [w, ea[1]];\n          newP2 = [w, eb[1]];\n          if (Math.max(ea[1], eb[1]) > topRight[1]) topRight[1] = Math.max(ea[1], eb[1]);\n          if (Math.min(ea[1], eb[1]) < bottomRight[1]) bottomRight[1] = Math.min(ea[1], eb[1]);\n          newTri1 = [ea, eb, [newP1[0], newP1[1]]];\n          newTri1[2].index = newIndex1;\n          newTri2 = [eb, newTri1[2], [newP2[0], newP2[1]]];\n          newTri2[2].index = newIndex2;\n        } else {\n          newP1 = [-w, ea[1]];\n          newP2 = [-w, eb[1]];\n          if (Math.max(ea[1], eb[1]) > topLeft[1]) topLeft[1] = Math.max(ea[1], eb[1]);\n          if (Math.min(ea[1], eb[1]) < bottomLeft[1]) bottomLeft[1] = Math.min(ea[1], eb[1]);\n          newTri1 = [ea, eb, [newP1[0], newP1[1]]];\n          newTri1[2].index = newIndex1;\n          newTri2 = [eb, newTri1[2], [newP2[0], newP2[1]]];\n          newTri2[2].index = newIndex2;\n        }\n      } else if (midY > 0) {\n        newP1 = [ea[0], h];\n        newP2 = [eb[0], h];\n        if (Math.max(ea[0], eb[0]) > topRight[0]) topRight[0] = Math.max(ea[0], eb[0]);\n        if (Math.min(ea[0], eb[0]) < topLeft[0]) topLeft[0] = Math.min(ea[0], eb[0]);\n        newTri1 = [ea, eb, [newP1[0], newP1[1]]];\n        newTri1[2].index = newIndex1;\n        newTri2 = [eb, newTri1[2], [newP2[0], newP2[1]]];\n        newTri2[2].index = newIndex2;\n      } else {\n        newP1 = [ea[0], -h];\n        newP2 = [eb[0], -h];\n        if (Math.max(ea[0], eb[0]) > bottomRight[0]) bottomRight[0] = Math.max(ea[0], eb[0]);\n        if (Math.min(ea[0], eb[0]) < bottomLeft[0]) bottomLeft[0] = Math.min(ea[0], eb[0]);\n        newTri1 = [ea, eb, [newP1[0], newP1[1]]];\n        newTri1[2].index = newIndex1;\n        newTri2 = [eb, newTri1[2], [newP2[0], newP2[1]]];\n        newTri2[2].index = newIndex2;\n      }\n\n      vxs.push(newP1);\n      tris.push(newTri1);\n      adj.push([]);\n      vxs.push(newP2);\n      tris.push(newTri2);\n      adj.push([]);\n    }\n  } // Corner surgery\n\n\n  function makeTris(a, b, c, d) {\n    var newTri1 = [a, b, c];\n    var newTri2 = [b, c, d];\n    vxs.push(a);\n    tris.push(newTri1);\n    adj.push([]);\n    vxs.push(d);\n    tris.push(newTri2);\n    adj.push([]);\n  }\n\n  var p1 = [topRight[0], topRight[1]];\n  var p2 = [topRight[0], h];\n  var p3 = [w, topRight[1]];\n  var p4 = [w, h];\n  makeTris(p1, p2, p3, p4);\n  p1 = [bottomRight[0], bottomRight[1]];\n  p2 = [bottomRight[0], -h];\n  p3 = [w, bottomRight[1]];\n  p4 = [w, -h];\n  makeTris(p1, p2, p3, p4);\n  p1 = [bottomLeft[0], bottomLeft[1]];\n  p2 = [bottomLeft[0], -h];\n  p3 = [-w, bottomLeft[1]];\n  p4 = [-w, -h];\n  makeTris(p1, p2, p3, p4);\n  p1 = [topLeft[0], topLeft[1]];\n  p2 = [topLeft[0], h];\n  p3 = [-w, topLeft[1]];\n  p4 = [-w, h];\n  makeTris(p1, p2, p3, p4); // Pre-compute tri indexes\n\n  var z = new Map();\n  var idx = 0;\n  var tidx = [];\n\n  for (var _i2 = 0; _i2 < tris.length; ++_i2) {\n    var _t = tris[_i2];\n    var ctidx = [];\n\n    if (_t.length === 3) {\n      for (var j = 0; j < 3; ++j) {\n        var p = _t[j];\n        var index = "".concat(p[0].toFixed(5), ",").concat(p[1].toFixed(5));\n        var oi = z.get(index);\n\n        if (oi !== undefined) {\n          ctidx.push(oi);\n        } else {\n          ctidx.push(idx);\n          z.set(index, idx);\n          idx++;\n        }\n      }\n    }\n\n    tidx.push(ctidx);\n  }\n\n  var mesh = {\n    vor: vor,\n    pts: pts,\n    edges: edges,\n    extent: extent,\n    vxs: vxs,\n    adj: adj,\n    tris: tris,\n    triPointIndexes: tidx,\n    nbTriPointIndexes: idx,\n    nbInteriorTris: borderStart\n  };\n  var vl = vxs.length;\n  if (vl !== adj.length || vl !== tris.length) console.error(\'Incompatible mesh.\');\n  mesh.buffer = new Array(vl); // console.log(mesh);\n\n  return mesh;\n};\n\nmesh_Mesher.prototype.generateGoodMesh = function (n, extent) {\n  extent = extent || defaultExtent;\n  var pts = this.generateGoodPoints(n, extent);\n  return this.makeMesh(pts, extent);\n};\n\nmesh_Mesher.prototype.mergeSegments = function (segs) {\n  var adj = new Map();\n  var nbSegs = segs.length;\n\n  for (var i = 0; i < nbSegs; i++) {\n    var seg = segs[i];\n    var a0 = adj.get(seg[0]) || [];\n    var a1 = adj.get(seg[1]) || [];\n    a0.push(seg[1]);\n    a1.push(seg[0]);\n    adj.set(seg[0], a0);\n    adj.set(seg[1], a1);\n  }\n\n  var done = new Uint8Array(nbSegs);\n  var paths = [];\n  var path = null;\n\n  while (true) {\n    if (path === null) {\n      for (var _i3 = 0; _i3 < nbSegs; _i3++) {\n        if (done[_i3]) continue;\n        done[_i3] = 1;\n        path = [segs[_i3][0], segs[_i3][1]];\n        break;\n      }\n\n      if (path === null) break;\n    }\n\n    var changed = false;\n\n    for (var _i4 = 0; _i4 < nbSegs; _i4++) {\n      if (done[_i4]) continue;\n      var ap0 = adj.get(path[0]);\n      var apl = adj.get(path[path.length - 1]);\n      if (ap0 && ap0.length === 2 && segs[_i4][0] === path[0]) path.unshift(segs[_i4][1]);else if (ap0 && ap0.length === 2 && segs[_i4][1] === path[0]) path.unshift(segs[_i4][0]);else if (apl && apl.length === 2 && segs[_i4][0] === path[path.length - 1]) path.push(segs[_i4][1]);else if (apl && apl.length === 2 && segs[_i4][1] === path[path.length - 1]) path.push(segs[_i4][0]);else continue;\n      done[_i4] = 1;\n      changed = true;\n      break;\n    }\n\n    if (!changed) {\n      paths.push(path);\n      path = null;\n    }\n  }\n\n  return paths;\n};\n\nmesh_Mesher.prototype.contour = function (mesh, level) {\n  var meshEdges = mesh.edges;\n  var field = mesh.buffer;\n  level = level || 0;\n  var edges = [];\n\n  for (var i = 0; i < meshEdges.length; i++) {\n    var e = meshEdges[i];\n    if (e[3] === undefined) continue;\n    if (this.isnearedge(mesh, e[0]) || this.isnearedge(mesh, e[1])) continue;\n\n    if (field[e[0]] > level && field[e[1]] <= level || field[e[1]] > level && field[e[0]] <= level) {\n      edges.push([e[2], e[3]]);\n    }\n  }\n\n  return this.mergeSegments(edges);\n};\n\nmesh_Mesher.prototype.isedge = function (mesh, i) {\n  return mesh.adj[i].length < 3;\n};\n\nmesh_Mesher.prototype.inef = function (v, w, h) {\n  var x = v[0];\n  var y = v[1];\n  return x < -0.45 * w || x > 0.45 * w || y < -0.45 * h || y > 0.45 * h;\n};\n\nmesh_Mesher.prototype.isnearedge = function (mesh, i) {\n  var x = mesh.vxs[i][0];\n  var y = mesh.vxs[i][1];\n  var w = mesh.extent.width;\n  var h = mesh.extent.height;\n  return x < -0.45 * w || x > 0.45 * w || y < -0.45 * h || y > 0.45 * h;\n};\n\nmesh_Mesher.prototype.neighbours = function (mesh, i) {\n  return mesh.adj[i];\n};\n\nmesh_Mesher.prototype.distance = function (mesh, i, j) {\n  var p = mesh.vxs[i];\n  var q = mesh.vxs[j];\n  return Math.sqrt(Math.pow(p[0] - q[0], 2) + Math.pow(p[1] - q[1], 2));\n};\n\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/tile/tile.js\n\n\n\n\n\n\n\n\n\n\nvar STEPS = Object.freeze({\n  WAITING: -1,\n  START: 0,\n  HEIGHTMAP_INIT: 1,\n  // macro Gaussian\n  HEIGHTMAP_MOUNTAINS: 2,\n  // 50 Gaussian\n  HEIGHTMAP_RELAX: 3,\n  // relax + peaky\n  HEIGHTMAP_EROSION: 4,\n  // MULTIPLE PASSES\n  HEIGHTMAP_LEVEL: 5,\n  // set sea level + fill sinks\n  HEIGHTMAP_CLEAN: 6,\n  // clean coast\n  OBJECTS_RIVERS: 7,\n  //\n  OBJECTS_CITIES: 8,\n  //\n  OBJECTS_BIOMES: 9,\n  //\n  RASTER_TRIMESH: 10,\n  // compute trimesh + init buffer\n  RASTER_RASTERIZE: 11,\n  // MULTIPLE PASSES\n  RASTER_NOISE_PASS: 12,\n  RASTER_RIVER_PASS: 13,\n  RASTER_TREE_PASS: 14,\n  RASTER_CITY_PASS: 15,\n  READY: 16\n});\n\nvar tile_Tile = function Tile(coordX, coordY, dimension, country) {\n  this.coordX = coordX;\n  this.coordY = coordY;\n  this.dimension = dimension;\n  this.country = country; // contains pre-computed Voronoi in country.mesh\n\n  this.buffer = new Float64Array(country.mesh.tris.length);\n  var tileSeed = "a".concat(coordX, ",").concat(coordY);\n  this.tileSeed = tileSeed;\n  this.rasterizer = new pixel_Rasterizer(this.dimension);\n  this.mesher = new mesh_Mesher();\n  this.fieldModifier = new modifier_FieldModifier(this.mesher, tileSeed);\n  this.eroder = new Eroder(this.mesher);\n  this.cityPlacer = new CityPlacer(this.mesher, this.fieldModifier, this.eroder);\n  this.terrainGenerator = new terrain_TerrainGenerator(this.mesher, this.fieldModifier, this.eroder, tileSeed); // this.biomePlacer = new BiomePlacer(tileSeed);\n\n  this.languageGenerator = new language_LanguageGenerator(tileSeed);\n  this.nameGiver = new NameGiver(this.languageGenerator); // Progressive\n\n  this.needsGeneration = false;\n  this.step = STEPS.WAITING;\n  this.ready = false;\n  this.presentInScene = false; // when added\n};\n\ntile_Tile.prototype.setNoiseTile = function (noiseTile) {\n  this.rasterizer.setNoiseTile(noiseTile);\n};\n\ntile_Tile.prototype.stepGeneration = function () {\n  if (this.ready) return;\n  var mesh = this.country.mesh;\n  var fieldModifier = this.fieldModifier;\n  var terrainGenerator = this.terrainGenerator;\n  var eroder = this.eroder;\n  var country = this.country;\n  var cityPlacer = this.cityPlacer;\n  var rasterizer = this.rasterizer;\n\n  switch (this.step) {\n    case STEPS.WAITING:\n      this.step++;\n      break;\n\n    case STEPS.START:\n      var bl = mesh.tris.length;\n      this.fieldModifier.resetBuffer(bl);\n      this.fieldModifier.swapBuffers(this);\n      this.fieldModifier.resetBuffer(bl);\n      this.step++;\n      break;\n\n    case STEPS.HEIGHTMAP_INIT:\n      // fieldModifier.addSlope(mesh, terrainGenerator.randomVector(4));\n      fieldModifier.addCone(mesh, this.buffer, -1);\n      fieldModifier.addSlope(mesh, this.buffer, this.coordX, this.coordY);\n      this.step++;\n      break;\n\n    case STEPS.HEIGHTMAP_MOUNTAINS:\n      // 50 passes to optimize\n      fieldModifier.addMountains(mesh, this.buffer, 5);\n      if (fieldModifier.nbMountains >= 50) this.step++;\n      break;\n\n    case STEPS.HEIGHTMAP_RELAX:\n      // relax + peaky + set erosion amount for next pass\n      for (var i = 0; i < 10; i++) {\n        fieldModifier.relax(mesh, this);\n      }\n\n      fieldModifier.peaky(mesh, this.buffer);\n      var el = terrainGenerator.runif(0.04, 0.1);\n      eroder.setErosionAmount(el);\n      this.step++;\n      break;\n\n    case STEPS.HEIGHTMAP_EROSION:\n      // fill sinks multiple passes\n      eroder.stepErosion(mesh, this, 5); // eroder.doErosion(mesh, eroder.amount, 5);\n\n      if (eroder.ready) this.step++;\n      break;\n\n    case STEPS.HEIGHTMAP_LEVEL:\n      var sl = terrainGenerator.runif(0.2, 0.6);\n      fieldModifier.setSeaLevel(mesh, this.buffer, sl);\n      this.step++;\n      break;\n\n    case STEPS.HEIGHTMAP_CLEAN:\n      // eroder.fillSinks(mesh);\n      eroder.cleanCoast(mesh, this);\n      if (eroder.cleanCoastPass >= 3) // 3 iterations\n        this.step++;\n      break;\n\n    case STEPS.OBJECTS_RIVERS:\n      country.rivers = cityPlacer.getRivers(country.mesh, this, 0.01);\n      this.step++;\n      break;\n\n    case STEPS.OBJECTS_CITIES:\n      cityPlacer.placeCities(country, this, 3);\n      if (cityPlacer.nbCities >= country.params.ncities) this.step++;\n      break;\n\n    case STEPS.OBJECTS_BIOMES:\n      // let biomePlacer = this.biomePlacer;\n      // biomePlacer.initBuffer(country.mesh.vxs.length);\n      // biomePlacer.computeBiomes(country.mesh);\n      rasterizer.seedChunkRandom(this.tileSeed);\n      rasterizer.computeChunkTreeDensity();\n      this.step++;\n      break;\n    // country.coasts = mesher.contour(country.mesh, 0);\n    // country.terr = cityPlacer.getTerritories(country);\n    // country.borders = cityPlacer.getBorders(country);\n\n    case STEPS.RASTER_TRIMESH:\n      var triMesh = rasterizer.computeTriMesh(country.mesh, this);\n      this.triMesh = triMesh;\n      rasterizer.initBuffers();\n      this.step++;\n      break;\n\n    case STEPS.RASTER_RASTERIZE:\n      rasterizer.heightPass(this.triMesh);\n      if (rasterizer.heightPassDone) this.step++;\n      break;\n\n    case STEPS.RASTER_NOISE_PASS:\n      // rasterizer.noisePass(5.0);\n      this.step++;\n      break;\n\n    case STEPS.RASTER_RIVER_PASS:\n      rasterizer.riverPass(country.rivers);\n      this.step++;\n      break;\n\n    case STEPS.RASTER_TREE_PASS:\n      rasterizer.treePass();\n      this.step++;\n      break;\n\n    case STEPS.RASTER_CITY_PASS:\n      rasterizer.cityPass(country.mesh, country.cities);\n      this.step++;\n      break;\n\n    case STEPS.READY:\n      // console.log(this.getRaster());\n      this.ready = true;\n      break;\n  }\n};\n\ntile_Tile.prototype.processHeightMap = function () {\n  var fieldModifier = this.fieldModifier;\n  var mesh = this.country.mesh;\n  var eroder = this.eroder;\n  var terrainGenerator = this.terrainGenerator;\n  fieldModifier.resetBuffer(mesh.tris.length);\n  fieldModifier.addSlope(mesh, terrainGenerator.randomVector(4));\n  fieldModifier.addCone(mesh, terrainGenerator.runif(-1, -1));\n  fieldModifier.addMountains(mesh, 50);\n\n  for (var i = 0; i < 10; i++) {\n    fieldModifier.relax(mesh);\n  }\n\n  fieldModifier.peaky(mesh);\n  var el = terrainGenerator.runif(0, 0.1);\n  eroder.doErosion(mesh, el, 5);\n  var sl = terrainGenerator.runif(0.2, 0.6);\n  fieldModifier.setSeaLevel(mesh, sl);\n  eroder.fillSinks(mesh);\n  eroder.cleanCoast(mesh, 3);\n};\n\ntile_Tile.prototype.placeObjects = function () {\n  var country = this.country;\n  var cityPlacer = this.cityPlacer;\n  var mesher = this.mesher;\n  cityPlacer.placeCities(country);\n  country.rivers = cityPlacer.getRivers(country.mesh, 0.01);\n  country.coasts = mesher.contour(country.mesh, 0);\n  country.terr = cityPlacer.getTerritories(country);\n  country.borders = cityPlacer.getBorders(country);\n};\n\ntile_Tile.prototype.renderToRaster = function () {\n  var rasterizer = this.rasterizer;\n  var country = this.country;\n  var triMesh = rasterizer.computeTriMesh(country.mesh);\n  this.triMesh = triMesh;\n  rasterizer.initBuffers(triMesh);\n  rasterizer.heightPass(triMesh);\n  rasterizer.noisePass(5.0); // console.log(rasterizer.heightBuffer);\n\n  rasterizer.riverPass(country.rivers);\n  rasterizer.cityPass(country.mesh, country.cities);\n};\n\ntile_Tile.prototype.getRaster = function () {\n  return this.rasterizer.heightBuffer;\n};\n\ntile_Tile.prototype.getSurfaceRaster = function () {\n  return this.rasterizer.surfaceBuffer;\n};\n\ntile_Tile.prototype.getCountry = function () {\n  return this.country;\n};\n\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/terrain/world.js\n\n\n\n\n\n\n\nvar world_WorldMap = function WorldMap() {\n  this.tiles = new Map();\n  this.tileDimension = 1024;\n  this.mesher = new mesh_Mesher();\n  this.mesh = null;\n  this.rasterizer = new pixel_Rasterizer(this.tileDimension);\n  this.noiseTile = null;\n};\n\nworld_WorldMap.prototype.seedWorld = function () // seed)\n{\n  // XXX [GENERATION] link seed\n  // console.log(`XXX link seed ${seed}.`);\n  // Init generators, voronoi and buffers.\n  var mesher = this.mesher;\n  var mesh = mesher.generateGoodMesh(16384, {\n    width: 1,\n    height: 1\n  }); // console.log(mesh);\n\n  this.mesh = mesh;\n  var rasterizer = this.rasterizer;\n  rasterizer.precomputeNoiseTile(5);\n  this.noiseTile = rasterizer.noiseTile;\n};\n\nworld_WorldMap.prototype.stepTileGeneration = function (tile) {\n  if (!tile.ready) tile.stepGeneration();\n  return tile.ready;\n};\n\nworld_WorldMap.prototype.loadTile = function (i, j) {\n  var c = {\n    params: defaultParams,\n    mesh: this.mesh\n  };\n  var t = new tile_Tile(i, j, this.tileDimension, c);\n  t.setNoiseTile(this.noiseTile);\n  t.processHeightMap();\n  t.placeObjects();\n  t.renderToRaster();\n  this.tiles.set("".concat(i, ",").concat(j), t);\n};\n\nworld_WorldMap.prototype.makeNewTileIfNeeded = function (i, j) {\n  var tid = "".concat(i, ",").concat(j);\n  var t = this.tiles.get(tid);\n  if (t) return t;\n  t = new tile_Tile(i, j, this.tileDimension, {\n    params: defaultParams,\n    mesh: this.mesh\n  });\n  t.setNoiseTile(this.noiseTile);\n  t.needsGeneration = true;\n  this.tiles.set(tid, t);\n  return t;\n};\n\nworld_WorldMap.prototype.generateIfNeeded = function (x, y) // scene, camera)\n{\n  // let p = camera.position;\n  // const x = p.x;\n  // const y = p.y;\n  var i = Math.round(x);\n  var j = Math.round(y);\n  var tid = "".concat(i, ",").concat(j);\n  var t = this.tiles.get(tid); // console.log(t);\n\n  if (!t) {\n    t = new tile_Tile(i, j, this.tileDimension, {\n      params: defaultParams,\n      mesh: this.mesh\n    });\n    t.setNoiseTile(this.noiseTile);\n    this.tiles.set(tid, t);\n  } else if (!t.ready) {\n    t.stepGeneration();\n  } else {// let buffer = this.makeImageBufferFromRaster(\n    //     t,\n    //     t.getRaster(),\n    //     t.getSurfaceRaster()\n    // );\n  }\n};\n\nworld_WorldMap.prototype.getTiles = function () {\n  return this.tiles;\n};\n\nworld_WorldMap.prototype.makeImageBufferFromRaster = function (tile, heightBuffer, surfaceBuffer) {\n  var width = tile.dimension;\n  var height = tile.dimension;\n  var rb = heightBuffer;\n  var sb = surfaceBuffer;\n  var buffer = new Uint8ClampedArray(width * height * 4);\n\n  for (var i = 0; i < height; ++i) {\n    for (var j = 0; j < width; ++j) {\n      var s = i * width + j;\n      var stride = s * 4;\n      var si = (width - i - 1) * width + j;\n      var v = rb[si] >> 0;\n      var t = sb[si] >> 0;\n\n      if (v > 0) {\n        buffer[stride] = t < 1 ? v : 255;\n        buffer[stride + 1] = t < 1 ? v : 0;\n        buffer[stride + 2] = t < 1 ? v : 0;\n      } else {\n        buffer[stride] = 0;\n        buffer[stride + 1] = 0;\n        buffer[stride + 2] = 255;\n      }\n\n      buffer[stride + 3] = 255;\n    }\n  }\n\n  return buffer;\n};\n\n\n// CONCATENATED MODULE: ./server/app/engine/game3d/engine_generation/generation.js\n\n\nfunction generation_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction generation_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction generation_createClass(Constructor, protoProps, staticProps) { if (protoProps) generation_defineProperties(Constructor.prototype, protoProps); if (staticProps) generation_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n/**\n * WorldMap\n * Only for FlatWorld.\n */\n\nvar generation_GenerationEngine = /*#__PURE__*/function () {\n  function GenerationEngine(game) {\n    generation_classCallCheck(this, GenerationEngine);\n\n    this._game = game; // Chunks and entity positions\n\n    this._worldModel = game.worldModel;\n    this._worldMaps = new Map();\n  }\n\n  generation_createClass(GenerationEngine, [{\n    key: "update",\n    value: function update() {\n      var worlds = this._worldModel.worlds; // XXX [GENERATION] time budget.\n      // Generate meta-tile for entities on edge.\n\n      if (this._game.kind === GameType.FANTASY) this.stepWorldMapGeneration(); // Generate blocks for waiting chunks.\n\n      this.stepChunkBlockGeneration(worlds);\n    } // N.B. No need to do that in case of non-fantasy (e.g. Perlin-only) world.\n\n  }, {\n    key: "initializeWorldMap",\n    value: function initializeWorldMap(worldId) {\n      var worldMap = new world_WorldMap();\n      worldMap.seedWorld();\n\n      this._worldMaps.set(worldId, worldMap);\n    }\n  }, {\n    key: "stepChunkBlockGeneration",\n    value: function stepChunkBlockGeneration(worlds) {\n      var _this = this;\n\n      var done = false;\n      worlds.forEach(function (world, worldId) {\n        if (done) return;\n        var nextChunk = world.getNextChunkForGeneration();\n\n        var worldMap = _this._worldMaps.get(worldId);\n\n        if (world.worldInfo.type === model_WorldType.FANTASY && !worldMap) {\n          _this.initializeWorldMap(worldId);\n\n          worldMap = _this._worldMaps.get(worldId);\n        }\n\n        if (nextChunk) {\n          chunkgenerator.generateChunkBlocks(nextChunk, worldMap);\n\n          if (nextChunk.blocksReady) {\n            world.popChunkForGeneration();\n            done = true;\n          }\n        }\n      });\n    }\n  }, {\n    key: "stepWorldMapGeneration",\n    value: function stepWorldMapGeneration() {\n      var done = false;\n      var worldMaps = this._worldMaps;\n      worldMaps.forEach(function (worldMap) {\n        if (done) return;\n        var tiles = worldMap.tiles;\n        tiles.forEach(function (tile) {\n          if (done) return;\n\n          if (tile.needsGeneration) {\n            // console.log(tile.tileSeed);\n            tile.stepGeneration();\n          }\n\n          if (tile.ready) {\n            tile.needsGeneration = false;\n          }\n        });\n      });\n    }\n  }, {\n    key: "stepWorldMapGenerationAt",\n    value: function stepWorldMapGenerationAt(worldId, x, y) {\n      var worldMap = this._worldMaps.get(worldId);\n\n      if (!worldMap) {\n        console.error("Invalid world id ".concat(worldId, "."));\n      }\n\n      worldMap.generateIfNeeded(x, y);\n    }\n  }]);\n\n  return GenerationEngine;\n}();\n\n/* harmony default export */ var generation = (generation_GenerationEngine);\n// CONCATENATED MODULE: ./server/app/engine/game3d/game.js\n/**\n *\n */\n\n\nfunction game_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { game_typeof = function _typeof(obj) { return typeof obj; }; } else { game_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return game_typeof(obj); }\n\nfunction game3d_game_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction game3d_game_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction game3d_game_createClass(Constructor, protoProps, staticProps) { if (protoProps) game3d_game_defineProperties(Constructor.prototype, protoProps); if (staticProps) game3d_game_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction game_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) game_setPrototypeOf(subClass, superClass); }\n\nfunction game_setPrototypeOf(o, p) { game_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return game_setPrototypeOf(o, p); }\n\nfunction game_createSuper(Derived) { var hasNativeReflectConstruct = game_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = game_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = game_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return game_possibleConstructorReturn(this, result); }; }\n\nfunction game_possibleConstructorReturn(self, call) { if (call && (game_typeof(call) === "object" || typeof call === "function")) { return call; } return game_assertThisInitialized(self); }\n\nfunction game_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction game_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction game_getPrototypeOf(o) { game_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return game_getPrototypeOf(o); }\n\nfunction game_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n // import TimeUtils from \'../math/time\';\n\n\nvar GameType = Object.freeze({\n  FLAT: Symbol(\'flat\'),\n  CUBE: Symbol(\'cube\'),\n  DEMO: Symbol(\'demo\'),\n  UNSTRUCTURED: Symbol(\'unstructured\'),\n  FANTASY: Symbol(\'fantasy\')\n});\n\nvar game_Game3D = /*#__PURE__*/function (_Game) {\n  game_inherits(Game3D, _Game);\n\n  var _super = game_createSuper(Game3D);\n\n  // Increase to reduce the netload!\n  // Client must have entity / self interpolation activated.\n  function Game3D(hub, gameId, connector, gameInfo, isServerLocal) {\n    var _this;\n\n    game3d_game_classCallCheck(this, Game3D);\n\n    _this = _super.call(this, hub, gameId, connector, isServerLocal); // Utility parameters\n\n    _this._kind = gameInfo.kind;\n    _this._gameInfo = gameInfo;\n    _this._refreshRate = Game3D.serverRefreshRate; //this._refreshRate = 1000;\n\n    _this._tt = 0;\n    _this._frameMod1000 = 0; // Misc.\n\n    _this._chat = new chat(game_assertThisInitialized(_this)); // Models (autonomous).\n\n    _this._worldModel = new model_WorldModel(game_assertThisInitialized(_this));\n    _this._entityModel = new model_entity_model(game_assertThisInitialized(_this));\n    _this._xModel = new model_x_model(game_assertThisInitialized(_this), _this._worldModel);\n    _this._consistencyModel = new model_consistency_model(game_assertThisInitialized(_this)); // Engines (need models).\n\n    _this._ai = new ai(game_assertThisInitialized(_this));\n    _this._physicsEngine = new physics(game_assertThisInitialized(_this));\n    _this._topologyEngine = new topology(game_assertThisInitialized(_this));\n    _this._consistencyEngine = new consistency(game_assertThisInitialized(_this));\n    _this._generationEngine = new generation(game_assertThisInitialized(_this)); // I/O (need engines).\n\n    _this._internalInput = new input_input(game_assertThisInitialized(_this)); // A.I.\n\n    _this._internalOutput = new output_output(game_assertThisInitialized(_this)); // A.I.\n\n    _this._externalInput = new input(game_assertThisInitialized(_this)); // Human.\n\n    _this._externalOutput = new output(game_assertThisInitialized(_this)); // Human.\n    // Generate then listen players.\n\n    _this.generate();\n\n    return _this;\n  } // Model\n\n\n  game3d_game_createClass(Game3D, [{\n    key: "update",\n    //^\n    value: function update() {\n      if (!this._isRunning) {\n        // This happens when on FF when the user has created a local\n        // sandbox game  in which no one else is present.\n        // console.log(\'[Game3D] Called update on non-running game.\');\n        return;\n      }\n\n      this._frameMod1000 = (this._frameMod1000 + 1) % 1000; // Idea maybe split in several loops (purposes).\n      // let debugThresh = 4000; // microsecs\n\n      /** Inputs **/\n      // Update intents.\n\n      this._ai.update(); // Update human spawn/leave requests.\n\n\n      this._externalInput.update(); // Update artificial inputs.\n\n\n      this._internalInput.update();\n      /** Updates **/\n      // Update topological (terrain) model.\n\n\n      this._topologyEngine.update(); // Update physical simulation.\n\n\n      this._physicsEngine.update();\n      /** Chunk and WorldMap Generation **/\n      // Update fantasy map generation.\n\n\n      this._generationEngine.update();\n      /** Consistency solving: mediator between player and server models **/\n      // Make client models consistent. Needs other engines.\n\n\n      var updateEntities = this._frameMod1000 % Game3D.waitFramesToOutputEntities === 0;\n\n      this._consistencyEngine.update(updateEntities);\n      /** Outputs **/\n      // Send updates.\n\n\n      this._externalOutput.update(updateEntities); // Update perceptions.\n\n\n      this._internalOutput.update(); // var n = this._playerManager.nbPlayers;\n      // console.log("There " + (n>1?"are ":"is ") + n + " player" + (n>1?"s":"") + " connected.");\n      // this._tt += 1;\n      // if (this._tt % 1000 === 0) console.log((TimeUtils.getTimeSecNano(time)[1]/1000) + " s a loop.");\n      // const t1 = TimeUtils.getTimeSecNano(t0)[1] / 1000;\n      // if (t1 > 4000 && Game3D.bench) console.log(`${t1} s.`);\n      // Pause game with idle timeout when no-one is connected.\n\n\n      if (this._playerManager.nbPlayers < 1) this.pause(false);\n    }\n  }, {\n    key: "generate",\n    value: function generate() {\n      var _this2 = this;\n\n      // The following takes a while to generate Voronoi\n      if (this.gameInfo.kind === GameType.FANTASY) this._generationEngine.initializeWorldMap(-1); // Create empty chunks (these will be generated when the WorldMap is ready)\n\n      this._consistencyEngine.generateWorld().then(function () {\n        _this2._playerManager.setAddPlayerBehaviour(function (p) {\n          _this2._externalInput.addPlayer(p);\n        });\n\n        _this2._playerManager.setRemovePlayerBehaviour(function (player) {\n          _this2._externalInput.removePlayer(player.avatar.entityId);\n        });\n\n        _this2._ready = true;\n      })["catch"](function (e) {\n        return console.log(e);\n      });\n    }\n  }, {\n    key: "save",\n    value: function save() {// XXX [SAVE] write world and entities into file.\n    }\n  }, {\n    key: "gameInfo",\n    get: function get() {\n      return this._gameInfo;\n    }\n  }, {\n    key: "entityModel",\n    get: function get() {\n      return this._entityModel;\n    }\n  }, {\n    key: "worldModel",\n    get: function get() {\n      return this._worldModel;\n    }\n  }, {\n    key: "xModel",\n    get: function get() {\n      return this._xModel;\n    }\n  }, {\n    key: "consistencyModel",\n    get: function get() {\n      return this._consistencyModel;\n    }\n  }, {\n    key: "ai",\n    get: function get() {\n      return this._ai;\n    }\n  }, {\n    key: "physicsEngine",\n    get: function get() {\n      return this._physicsEngine;\n    }\n  }, {\n    key: "topologyEngine",\n    get: function get() {\n      return this._topologyEngine;\n    }\n  }, {\n    key: "consistencyEngine",\n    get: function get() {\n      return this._consistencyEngine;\n    }\n  }, {\n    key: "chat",\n    get: function get() {\n      return this._chat;\n    }\n  }, {\n    key: "refreshRate",\n    get: function get() {\n      return this._refreshRate;\n    }\n  }]);\n\n  return Game3D;\n}(game_game);\n\ngame_defineProperty(game_Game3D, "serverRefreshRate", 16);\n\ngame_defineProperty(game_Game3D, "waitFramesToOutputEntities", 3);\n\ngame_defineProperty(game_Game3D, "bench", false);\n\n\n// CONCATENATED MODULE: ./server/app/engine/factory.js\n/**\n *\n */\n\n\nfunction factory_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction factory_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction factory_createClass(Constructor, protoProps, staticProps) { if (protoProps) factory_defineProperties(Constructor.prototype, protoProps); if (staticProps) factory_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar factory_GameFactory = /*#__PURE__*/function () {\n  function GameFactory() {\n    factory_classCallCheck(this, GameFactory);\n  }\n\n  factory_createClass(GameFactory, null, [{\n    key: "createGame",\n    value: function createGame(hub, kind, gameId, connector, options) {\n      var game;\n\n      var isServerLocal = hub._isServerLocal();\n\n      switch (kind) {\n        case \'flat\':\n          var flatHillsType = parseInt(options.hills, 10);\n          var trees = parseInt(options.trees, 10);\n          game = new game_Game3D(hub, gameId, connector, {\n            kind: GameType.FLAT,\n            flatHillsType: flatHillsType,\n            trees: trees\n          }, isServerLocal);\n          break;\n\n        case \'cube\':\n          var threeHillsType = parseInt(options.hills, 10);\n          var size = parseInt(options.size, 10);\n          game = new game_Game3D(hub, gameId, connector, {\n            kind: GameType.CUBE,\n            threeHillsType: threeHillsType,\n            size: size\n          }, isServerLocal);\n          break;\n\n        case \'demo\':\n          game = new game_Game3D(hub, gameId, connector, {\n            kind: GameType.DEMO\n          }, isServerLocal);\n          break;\n\n        case \'fantasy\':\n          game = new game_Game3D(hub, gameId, connector, {\n            kind: GameType.FANTASY\n          }, isServerLocal);\n          break;\n\n        case \'unstructured\':\n          console.log(\'[Server/GameFactory] Unstructured not yet supported.\');\n          return;\n\n        default:\n          console.error(\'[Server/GameFactory] Unknown game kind requested.\');\n          return;\n      }\n\n      return game;\n    }\n  }]);\n\n  return GameFactory;\n}();\n\n/* harmony default export */ var factory = (factory_GameFactory);\n// CONCATENATED MODULE: ./server/app/model/factory.js\n/**\n *\n */\n\n\nfunction model_factory_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction model_factory_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction model_factory_createClass(Constructor, protoProps, staticProps) { if (protoProps) model_factory_defineProperties(Constructor.prototype, protoProps); if (staticProps) model_factory_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\n\n\n\n\nvar factory_Factory = /*#__PURE__*/function () {\n  function Factory() {\n    model_factory_classCallCheck(this, Factory);\n  }\n\n  model_factory_createClass(Factory, null, [{\n    key: "createUserDB",\n\n    /** App-level classes */\n    value: function createUserDB(connector) {\n      return new user_db(connector);\n    }\n  }, {\n    key: "createHub",\n    value: function createHub(app) {\n      return new game_hub(app);\n    }\n  }, {\n    key: "createUser",\n    value: function createUser(hub, socket, nick, id) {\n      return new client_user(hub, socket, nick, id);\n    }\n    /** Gaming classes */\n\n  }, {\n    key: "createGame",\n    value: function createGame(hub, kind, gameId, connector, options) {\n      return factory.createGame(hub, kind, gameId, connector, options);\n    }\n  }, {\n    key: "createPlayer",\n    value: function createPlayer(user, game) {\n      return new client_player(user, game);\n    }\n  }, {\n    key: "createPlayerManager",\n    value: function createPlayerManager() {\n      return new player_manager();\n    }\n    /** Connection classes */\n\n  }, {\n    key: "createConnection",\n    value: function createConnection(app) {\n      return new connection_connection(app);\n    }\n  }, {\n    key: "createUserConnection",\n    value: function createUserConnection(user, socket) {\n      return new user_connection(user, socket);\n    }\n  }, {\n    key: "createPlayerConnection",\n    value: function createPlayerConnection(socket) {\n      return new player_connection(socket);\n    }\n  }]);\n\n  return Factory;\n}();\n\n/* harmony default export */ var model_factory = (factory_Factory);\n// CONCATENATED MODULE: ./server/app/app.js\n/**\n * Server app main logic.\n */\n\n\nfunction app_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction app_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction app_createClass(Constructor, protoProps, staticProps) { if (protoProps) app_defineProperties(Constructor.prototype, protoProps); if (staticProps) app_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar app_App = /*#__PURE__*/function () {\n  function App() {\n    app_classCallCheck(this, App);\n\n    this._hub = model_factory.createHub(this);\n    this._connection = model_factory.createConnection(this);\n    this._isLocal = false;\n  } // Model\n\n\n  app_createClass(App, [{\n    key: "connect",\n    value: function connect(socketio) {\n      this._connection.configure(socketio);\n    }\n  }, {\n    key: "connectRTC",\n    value: function connectRTC(userID, socket) {\n      this._connection.configureFromSocket(socket, userID);\n    }\n  }, {\n    key: "_setLocal",\n    value: function _setLocal(isLocal) {\n      this._isLocal = isLocal;\n    }\n  }, {\n    key: "_updateGameLoops",\n    value: function _updateGameLoops() {\n      this._hub._updateGameLoops();\n    }\n  }, {\n    key: "hub",\n    get: function get() {\n      return this._hub;\n    }\n  }, {\n    key: "connection",\n    get: function get() {\n      return this._connection;\n    }\n  }]);\n\n  return App;\n}();\n\n/* harmony default export */ var app_app = (app_App);\n// CONCATENATED MODULE: ./client/app/localserver/io.js\n/**\n * local synchronous socketIO emulator\n */\n\n\n // Socket internals\n\nvar Socket = function Socket() {\n  this.actions = {};\n  this.request = {\n    connection: {\n      remoteAddress: \'localhost:sandbox\',\n      remotePort: \'noport\'\n    }\n  };\n  this.nsp = {\n    name: \'nonsp\'\n  };\n  this.address = \'localhost:sandbox\';\n\n  this.off = function () {\n    console.log(\'[Socket] Default off function.\');\n  };\n\n  this.otherSocket = {};\n  this.debugListeners = false;\n};\n\nextend(Socket.prototype, {\n  setOtherEndPoint: function setOtherEndPoint(s) {\n    this.otherSocket = s;\n  },\n  // Override\n  on: function on(message, action) {\n    this.actions[message] = action; // console.log(`[Socket] added \'${message}\' listener`);\n  },\n  removeListener: function removeListener(message) {\n    var has = this.actions.hasOwnProperty(message);\n\n    if (has) {\n      delete this.actions[message];\n      if (this.debugListeners) console.log("[Socket] Removed \'".concat(message, "\' listener"));\n    }\n  },\n  // Override\n  removeAllListeners: function removeAllListeners(message) {\n    var has = this.actions.hasOwnProperty(message);\n\n    if (has) {\n      delete this.actions[message];\n      if (this.debugListeners) console.log("[Socket] Removed \'".concat(message, "\' listener"));\n    }\n  },\n  disconnect: function disconnect() {\n    var has = this.actions.hasOwnProperty(\'disconnect\');\n\n    if (has) {\n      this.actions.disconnect();\n    }\n  },\n  // Override\n  emit: function emit(message, data) {\n    // console.log(`emit ${message} with ${data}`);\n    // Forward action\n    var s = this.otherSocket;\n    var has = s.actions.hasOwnProperty(message);\n\n    if (has) {\n      s.actions[message](data);\n    }\n  }\n}); // Socket provider\n\nvar IO = function IO() {\n  this.connectionCallback = function () {\n    console.log(\'[IO] No connection behavior specified.\');\n  };\n\n  this.socketServer = new Socket();\n  this.socketClient = new Socket();\n  this.socketServer.setOtherEndPoint(this.socketClient);\n  this.socketClient.setOtherEndPoint(this.socketServer);\n};\n\nextend(IO.prototype, {\n  on: function on(message, action) {\n    if (message === \'connection\') {\n      this.connectionCallback = action;\n    }\n  },\n  connect: function connect(socket) {\n    this.connectionCallback(socket);\n  },\n  disconnect: function disconnect(socket) {\n    if (socket && socket.disconnect) socket.disconnect();\n    console.log(\'[IO] Disconnect \');\n    this.socketServer.disconnect();\n  }\n}); // Only expose IO\n\n\n// CONCATENATED MODULE: ./client/app/localserver/standalone.js\n/**\n * Wrapper for integrating a full server client-wise.\n * Dummy object when not bundling server.\n */\n //////////////\n\n /////////\n/////////////////////////////////////////////////\n/////////////////////////////////\n//\n//////////\n\n\n\n\nvar standalone_Standalone = function Standalone(app) {\n  this.app = app;\n  this.io = new IO();\n  this.server = new app_app();\n  this._isRunning = false; // FF perf fix\n\n  var isFirefox = navigator.userAgent.toLowerCase().indexOf(\'firefox\') > -1;\n\n  this.server._setLocal(isFirefox);\n};\n\nextend(standalone_Standalone.prototype, {\n  start: function start() {\n    console.log(\'[Standalone] Starting local server.\');\n    this.server.connect(this.io); // setup IO object\n\n    this.io.connect(this.io.socketServer); // handshake\n\n    this._isRunning = true;\n  },\n  stop: function stop() {\n    this._isRunning = false;\n    console.log(\'[Standalone] Stopping local server.\');\n    this.io.disconnect(this.io.socketServer);\n  },\n  connectUser: function connectUser(userID, socketClient) {\n    this.server.connectRTC(userID, socketClient);\n  },\n  // disconnectUser(socketClient)\n  // {\n  //     this.io.disconnect(socketClient);\n  // },\n  isRunning: function isRunning() {\n    return this._isRunning;\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/localserver/middleware.js\n/**\n * Middleware for client I/O and prediction in high-latency networks\n */\n// (Idea -> obsolete with client interpolation setup in entity/self model?)\n//  1. client/server lockstep (lan)\n//  2. client standalone lockstep accepting webrtc\n//  3. (this) client/server selfpos model\nvar Middleware = function Middleware(app) {\n  this.app = app;\n};\n\n\n// CONCATENATED MODULE: ./client/app/modules/chat/chat.js\n/**\n *\n */\n\n\n\n\nvar chat_Chat = function Chat(register) {\n  this.register = register;\n};\n\nextend(chat_Chat.prototype, {\n  /**\n   * Called whenever a game starts.\n   * Init HTML elements here.\n   */\n  initModule: function initModule() {},\n\n  /**\n   * Dispose of HTML elements here.\n   * Called whenever a game stops.\n   */\n  disposeModule: function disposeModule() {},\n\n  /**\n   * Called on socket \'chat\' receive.\n   */\n  updateChat: function updateChat(data) {\n    console.log(data);\n  },\n\n  /**\n   * To call when a message has to be sent to the server.\n   * @param message\n   */\n  sendMessage: function sendMessage(message) {\n    this.register.sendMessage(\'chat\', message);\n  }\n});\n\n// EXTERNAL MODULE: ./node_modules/sigma/build/sigma.require.js\nvar sigma_require = __webpack_require__(41);\n\n// CONCATENATED MODULE: ./client/app/modules/hud/hud.worlds.js\n/**\n * Multiverse topology display.\n * (portal connectivity)\n */\n\n\n // import \'sigma/plugins/sigma.renderers.edgeLabels/settings\';\n// import \'sigma/plugins/sigma.renderers.edgeLabels/sigma.canvas.edges.labels.def\';\n// import \'sigma/plugins/sigma.renderers.edgeLabels/sigma.canvas.edges.labels.curve\';\n// import \'sigma/plugins/sigma.renderers.edgeLabels/sigma.canvas.edges.labels.curvedArrow\';\n\nvar HUDWorldsModule = {\n  initSigma: function initSigma() {\n    if (this.sigma) {// sigma == renderer, no need for a new one\n      // console.log(\'[Sigma] Sigma already declared.\');\n      // return;\n    }\n\n    this.sigma = new sigma_require["sigma"]({\n      graph: {\n        nodes: [],\n        edges: []\n      },\n      renderer: {\n        container: document.getElementById(\'network-graph\'),\n        type: \'canvas\'\n      },\n      // container: \'network-graph\',\n      // container: \'diagram\',\n      settings: {\n        minArrowSize: 20,\n        defaultNodeColor: \'#ec5148\',\n        drawLabels: true,\n        labelThreshold: 0 // enableHovering: false\n        // defaultEdgeLabelSize: 20,\n        // edgeLabelSize: \'fixed\',\n\n      }\n    });\n  },\n  killSigma: function killSigma() {\n    if (!this.sigma || !this.sigma.graph) return;\n    this.sigma.kill();\n    this.sigma = null;\n  },\n  refreshHUDWorldGraph: function refreshHUDWorldGraph(newDiagram) {\n    if (!this.sigma || !this.sigma.graph) {\n      console.warn(\'[HUD] Sigma failed to update.\');\n      return;\n    }\n\n    var graph = this.sigma.graph; // this.sigma.stopForceAtlas2();\n\n    graph.clear();\n    var nodeSet = new Set();\n    var depthMap = new Map();\n    var d = newDiagram;\n\n    for (var i = 0, l = d.length; i < l; ++i) {\n      var di = d[i];\n      if (!di.origin || !di.destination) continue;\n\n      if (!nodeSet.has(di.origin)) {\n        var currentDepth = parseInt(di.depth, 10);\n        var currentH = depthMap.get(currentDepth);\n        if (!currentH) currentH = 0;\n        depthMap.set(currentDepth, currentH + 1);\n        nodeSet.add(di.origin);\n        graph.addNode({\n          id: di.origin,\n          label: di.origin.toString(),\n          size: 1,\n          y: 0.2 * currentDepth,\n          x: 0.2 * (currentH + 1),\n          color: i === 0 ? \'blue\' : \'orange\'\n        });\n      }\n\n      if (!nodeSet.has(di.destination)) {\n        var _currentDepth = parseInt(di.depth, 10);\n\n        var _currentH = depthMap.get(_currentDepth + 1);\n\n        if (!_currentH) _currentH = 0;\n        depthMap.set(_currentDepth + 1, _currentH + 1);\n        nodeSet.add(di.destination);\n        graph.addNode({\n          id: di.destination,\n          label: di.destination.toString(),\n          size: 1,\n          y: 0.2 * (_currentDepth + 1),\n          x: 0.2 * (_currentH + 1),\n          color: \'orange\'\n        });\n      }\n\n      graph.addEdge({\n        id: di.pid,\n        // path\n        color: di.type,\n        // [\'lime\', \'orange\', \'red\', \'cyan\', yellow];\n        source: di.origin,\n        target: di.destination // label: di.pid,\n        // edgeLabelColor: di.type\n\n      });\n    } // console.log(\'[HUD] New flat graph:\');\n    // console.log(d);\n\n\n    this.sigma.refresh(); // this.sigma.startForceAtlas2();\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/modules/hud/hud.inventory.js\n/**\n * Inventory display.\n * (quick items slots)\n */\n\n\n\nvar HUDInventoryModule = {\n  initInventory: function initInventory() {\n    jquery_default()(\'#item0\').html("\\n            <img src=\\"app/assets/icons/block-planks.jpg\\" />\\n        ");\n    jquery_default()(\'#item1\').html("\\n            <img src=\\"app/assets/icons/katana.png\\" />\\n        ");\n    jquery_default()(\'#item2\').html("\\n            <img src=\\"app/assets/icons/bow.png\\" />\\n        "); // $(\'#item3\').html(`\n    //      <img src="app/assets/icons/portal-gun.png" />\n    // `);\n\n    jquery_default()(\'#item4\').html("\\n            <img src=\\"app/assets/icons/world-gun.png\\" />\\n        ");\n  }\n};\n\n// CONCATENATED MODULE: ./client/app/modules/hud/hud.js\n/**\n * In-game user interface.\n */\n\n\n\n\n\n\n\nvar Hud = function Hud(register) {\n  this.register = register;\n  this.orangeColor = \'#c96530\';\n  this.sigma = null;\n  this.html = "\\n        <div id=\\"hud\\" class=\\"noselect\\">\\n            <div id=\\"position\\"></div>\\n            <div id=\\"network-graph\\"></div>\\n            <div id=\\"diagram\\"></div>\\n            <div id=\\"mini-map\\"></div>\\n            \x3c!-- <div id=\\"chat\\"></div>--\x3e\\n        </div>\\n        <div id=\\"items\\" class=\\"noselect\\">\\n            <div id=\\"item-table\\">\\n            <div class=\\"square\\"><div class=\\"content selected\\" id=\\"item0\\"></div></div>\\n            <div class=\\"square\\"><div class=\\"content\\" id=\\"item1\\"></div></div>\\n            <div class=\\"square\\"><div class=\\"content\\" id=\\"item2\\"></div></div>\\n            <div class=\\"square\\"><div class=\\"content\\" id=\\"item3\\"></div></div>\\n            <div class=\\"square\\"><div class=\\"content\\" id=\\"item4\\"></div></div>\\n            <div class=\\"square\\"><div class=\\"content\\" id=\\"item5\\"></div></div>\\n            <div class=\\"square\\"><div class=\\"content\\" id=\\"item6\\"></div></div>\\n            <div class=\\"square\\"><div class=\\"content\\" id=\\"item7\\"></div></div>\\n            </div>\\n        </div>\\n    ";\n};\n\nextend(Hud.prototype, {\n  // Game started\n  initModule: function initModule() {\n    var announce = jquery_default()(\'#announce\');\n    announce.before(this.html); // World map renderer\n\n    this.initSigma(); // Quick items\n\n    this.initInventory();\n  },\n  // Game ended\n  disposeModule: function disposeModule() {\n    jquery_default()(\'#hud\').remove(); // $(\'#network-graph\').remove();\n\n    jquery_default()(\'#items\').remove();\n    this.killSigma();\n  },\n  updateSelfState: function updateSelfState(newState) {\n    if (newState.hasOwnProperty(\'position\')) {\n      var f = Math.floor;\n      var p = newState.position;\n      var text = "".concat(f(p[0]), ", ").concat(f(p[1]), ", ").concat(f(p[2]));\n      jquery_default()(\'#position\').text(text).css(\'color\', this.orangeColor);\n    }\n\n    if (newState.hasOwnProperty(\'diagram\')) {\n      this.refreshHUDWorldGraph(newState.diagram);\n    }\n\n    if (newState.hasOwnProperty(\'itemSelect\')) {\n      var newSlot = newState.itemSelect[0];\n      var oldSlot = newState.itemSelect[1];\n\n      if (newSlot < 0 || newSlot > 7 || oldSlot < 0 || oldSlot > 7) {\n        console.error(\'[HUD] Invalid item slot.\');\n      }\n\n      jquery_default()("#item".concat(oldSlot)).removeClass(\'selected\');\n      jquery_default()("#item".concat(newSlot)).addClass(\'selected\');\n    } // if (newState.hasOwnProperty(\'itemOrientation\')) {\n    // let or = newState.itemOrientation;\n    // $(\'#item_orientation\')\n    //     .text(or)\n    //     .css(\'color\', this.orangeColor);\n    // }\n    // if (newState.hasOwnProperty(\'itemOffset\')) {\n    // let of = newState.itemOffset;\n    // $(\'#item_offset\')\n    //     .text(of)\n    //     .css(\'color\', this.orangeColor);\n    // }\n\n  }\n});\nextend(Hud.prototype, HUDWorldsModule);\nextend(Hud.prototype, HUDInventoryModule);\n\n// CONCATENATED MODULE: ./client/app/modules/register/register.js\n/**\n *\n */\n\n\n\n\n\n\nvar Register = function Register() //, app\n{\n  this.modules = {};\n};\n\nextend(Register.prototype, {\n  registerDefaultModules: function registerDefaultModules() {\n    this.registerModule(\'chat\', new chat_Chat(this));\n    this.registerModule(\'hud\', new Hud(this));\n  },\n  registerModule: function registerModule(moduleName, module) {\n    if (this.modules.hasOwnProperty(moduleName)) {\n      throw Error(\'Error: module already registered.\');\n    }\n\n    this.modules[moduleName] = module;\n  },\n  gameStarted: function gameStarted() {\n    for (var m in this.modules) {\n      if (!this.modules.hasOwnProperty(m)) continue;\n      var module = this.modules[m];\n\n      if (typeof module.initModule === \'function\') {\n        module.initModule();\n      }\n    }\n  },\n  gameStopped: function gameStopped() {\n    for (var m in this.modules) {\n      if (!this.modules.hasOwnProperty(m)) continue;\n      var module = this.modules[m];\n\n      if (typeof module.disposeModule === \'function\') {\n        module.disposeModule();\n      }\n    }\n  },\n  updateSelfState: function updateSelfState(data) {\n    this.modules.hud.updateSelfState(data);\n  },\n  updateChat: function updateChat(data) {\n    this.modules.chat.updateChat(data);\n  },\n  sendMessage: function sendMessage() // message\n  {\n    console.log(\'Sending message.\');\n  }\n});\n\n// CONCATENATED MODULE: ./client/app/app.js\n/**\n * Client application entry point.\n */\n\n\n\n // State\n\n // Engine\n\n\n\n\n\n // Model\n\n\n\n\n // Local Netcode\n\n\n // Modules\n\n // import { Polyfills }    from \'modules/polyfills/polyfills.js\';\n// Global application structure.\n\nvar app_app_App = app_app_App || {\n  Core: {}\n}; // Main entry point.\n\napp_app_App.Core = function () {\n  // State pattern manages in-game, loading, menus.\n  // Also acts as a Mediator between engine, model(s) and modules\n  this.state = new states_StateManager(this); // Standalone server for solo mode (or local client)\n  // Middleware for high latency discrepancy networks (non-LAN)\n\n  this.localServer = {\n    standalone: new standalone_Standalone(this),\n    middleware: new Middleware(this)\n  }; // Engine manages client-side rendering, audio, inputs/outputs\n\n  this.engine = {\n    connection: new connection_Connection(this),\n    graphics: new Graphics(this),\n    audio: new Audio(this),\n    controls: new UI(this),\n    settings: new Settings(this)\n  }; // Model buffers server and client objects\n\n  this.model = {\n    hub: new hub_Hub(this),\n    server: new server_Server(this),\n    client: new client_Client(this),\n    localServer: new LocalServer(this)\n  }; // Modules can be registered to add custom behaviours\n\n  this.register = new Register(this);\n  this.register.registerDefaultModules();\n}; // Application entry point.\n\n\nextend(app_app_App.Core.prototype, {\n  // The only intended way to play.\n  startFromRemoteServer: function startFromRemoteServer(socketAddress, port) {\n    this.setState(\'loading\');\n    this.engine.connection.connectSocket(socketAddress, port, true); // connects\n\n    this.engine.connection.listen(); // listens\n  },\n  startDemo: function startDemo() {\n    this.setState(\'loading\');\n    var s = this.localServer.standalone.io.socketClient;\n    this.engine.connection.setupLocalSocket(s);\n    this.engine.connection.listenQuick(); // only listen to hub and join\n\n    this.model.server.isDirty = true;\n    this.localServer.standalone.start();\n\n    this._forceRequestGameCreation(\'demo\');\n  },\n  startFromLocalServer: function startFromLocalServer() {\n    this.setState(\'loading\');\n    var s = this.localServer.standalone.io.socketClient;\n    this.engine.connection.setupLocalSocket(s);\n    this.engine.connection.listen();\n    this.localServer.standalone.start();\n  },\n  startFromRemoteSandbox: function startFromRemoteSandbox(socket) {\n    this.setState(\'loading\');\n    this.engine.connection.setupLocalSocket(socket);\n    this.engine.connection.listen();\n    console.log(\'[App/Core] Awaiting remote sandbox answer...\');\n  },\n  // Careful with what clients may execute in the local sandbox!\n  clientConnectedToLocalSandbox: function clientConnectedToLocalSandbox(userID, socket) {\n    this.localServer.standalone.connectUser(userID, socket);\n  },\n  start: function start() {\n    var _this = this;\n\n    this.setState(\'loading\');\n    this.engine.graphics.preload().then(function () {\n      return _this.setState(\'main\');\n    });\n  },\n  stop: function stop() {\n    this.setState(\'loading\');\n    this.engine.connection.disconnect();\n    this.stopGame();\n  }\n}); // Application utility.\n\nextend(app_app_App.Core.prototype, {\n  getState: function getState() {\n    return this.state.state;\n  },\n  setState: function setState(state, opt) {\n    this.state.setState(state, opt);\n  },\n  isLoading: function isLoading() {\n    return this.getState() === \'loading\';\n  },\n  isFocused: function isFocused() {\n    return this.state.focus;\n  },\n  setFocused: function setFocused(isFocused) {\n    // Ensure output type.\n    this.state.focus = !!isFocused;\n  },\n  // Called when the socket is connected.\n  connectionEstablished: function connectionEstablished() {\n    console.log(\'Connected.\');\n    setTimeout(function () {\n      this.engine.connection.requestHubState();\n    }.bind(this), 1500);\n  },\n  // Called when a \'creation\' request is emitted from Hub state.\n  requestGameCreation: function requestGameCreation(gameType, options) {\n    if (this.getState() !== \'hub\') {\n      console.error(\'Could not request game creation outside of Hub.\');\n      return;\n    }\n\n    this.engine.connection.requestGameCreation(gameType, options);\n  },\n  _forceRequestGameCreation: function _forceRequestGameCreation(gameType, options) {\n    this.engine.connection.requestGameCreation(gameType, options);\n  },\n  _forceJoin: function _forceJoin(gameType, gameId) {\n    this.setState(\'preingame\');\n    this.engine.connection.configureGame(gameType, gameId);\n    this.model.client.init(gameType);\n    this.model.server.init(gameType);\n    this.engine.connection.join(gameType, gameId);\n  },\n  // Called when a \'join\' request is emitted from Hub state.\n  join: function join(gameType, gameId) {\n    if (this.getState() !== \'hub\') throw Error(\'Could not request game joining outside of Hub.\');\n    console.log(\'Join request...\'); // Configuration.\n\n    this.setState(\'preingame\');\n    this.engine.connection.configureGame(gameType, gameId); // Start model loop.\n\n    this.model.client.init(gameType);\n    this.model.server.init(gameType);\n    console.log(\'Game effectively started.\'); // Try to join specified game.\n\n    this.engine.connection.join(gameType, gameId);\n  },\n  // Run game when joining confirmed.\n  joinedServer: function joinedServer() {\n    console.log(\'[Game/Client] Joined server.\'); // Run game\n\n    this.runGame();\n  },\n  runGame: function runGame() {\n    this.engine.graphics.run();\n    this.engine.controls.run();\n    this.engine.audio.run();\n    this.register.gameStarted();\n  },\n  stopGame: function stopGame() {\n    this.register.gameStopped();\n    this.engine.connection.unregisterSocketForGame3D();\n    this.engine.graphics.stop();\n    this.engine.controls.stop();\n    this.engine.audio.stop();\n    this.model.server.cleanupFullModel();\n    this.model.client.cleanupFullModel();\n    this.engine.graphics.cleanupFullGraphics();\n    this.state.cleanupDOM();\n  }\n}); // Modules, for extending the core functionality.\n// To be done:\n// [MOD] register/reload modules\n// [MOD] error reporting\n// [MOD] wrapping DOM queries\n\nextend(app_app_App.Core.prototype, {\n  registerModule: function registerModule() {},\n  restartModule: function restartModule() {}\n});\n\nwindow.register = function () {\n  var app = new app_app_App.Core();\n  app.start();\n  return app.register;\n}();\n\n//# sourceURL=webpack:///./client/app/app.js_+_216_modules?')}},[[74,1,2]]]);